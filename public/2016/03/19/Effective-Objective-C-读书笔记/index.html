<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Norcy" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective-Objective-C-读书笔记">
<meta property="og:url" content="http://yoursite.com/2016/03/19/Effective-Objective-C-读书笔记/index.html">
<meta property="og:site_name" content="Norcy">
<meta property="og:description" content="《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xsd8c.com1.z0.glb.clouddn.com/isa.png">
<meta property="og:image" content="http://img.blog.csdn.net/20150803102818758">
<meta property="og:updated_time" content="2017-12-17T09:35:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective-Objective-C-读书笔记">
<meta name="twitter:description" content="《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》">
<meta name="twitter:image" content="http://7xsd8c.com1.z0.glb.clouddn.com/isa.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Effective-Objective-C-读书笔记 | Norcy </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?254282e11dbc3b9d82a87c07d3c21e0d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Norcy</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">等下一个天亮...</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            ME
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Effective-Objective-C-读书笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-19T00:00:00+08:00" content="2016-03-19">
              2016-03-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/19/Effective-Objective-C-读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/19/Effective-Objective-C-读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第1章-熟悉Objective—C"><a href="#第1章-熟悉Objective—C" class="headerlink" title="第1章 熟悉Objective—C"></a>第1章 熟悉Objective—C</h1><h2 id="第1条：了解Objective—C语言的起源"><a href="#第1条：了解Objective—C语言的起源" class="headerlink" title="第1条：了解Objective—C语言的起源"></a>第1条：了解Objective—C语言的起源</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *s1 = <span class="string">@"Hello"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *s2 = s1;</span><br></pre></td></tr></table></figure>
<ul>
<li>s1 和s2 的内存分配在栈上</li>
<li>@”Hello”的内存分配在堆上</li>
<li>s1 和 s2 指向同一块内存</li>
</ul>
<h2 id="第2条：在类的头文件中尽量少引入其他头文件"><a href="#第2条：在类的头文件中尽量少引入其他头文件" class="headerlink" title="第2条：在类的头文件中尽量少引入其他头文件"></a>第2条：在类的头文件中尽量少引入其他头文件</h2><h2 id="第3条：多用字面量语法，少用与之等价的方法"><a href="#第3条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第3条：多用字面量语法，少用与之等价的方法"></a>第3条：多用字面量语法，少用与之等价的方法</h2><h3 id="使用字面量语法，它是一种语法糖："><a href="#使用字面量语法，它是一种语法糖：" class="headerlink" title="使用字面量语法，它是一种语法糖："></a>使用字面量语法，它是一种语法糖：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"Hello"</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *intNum = @<span class="number">1</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *doubleNum = @<span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *charNum = @<span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *boolNum = @YES;</span><br><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"hello"</span>, @<span class="number">1</span>, @<span class="number">2.5</span>, @<span class="string">'a'</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = array[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *dic = @&#123;<span class="string">@"1"</span>:@<span class="number">1</span>, <span class="string">@"2"</span>:@<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="这个语法糖更容易暴露隐藏的问题"><a href="#这个语法糖更容易暴露隐藏的问题" class="headerlink" title="这个语法糖更容易暴露隐藏的问题"></a>这个语法糖更容易暴露隐藏的问题</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array1 = [<span class="built_in">NSArray</span> arrayWithObjects: obj1, obj2, obj3, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array2 = @[obj1, obj2, obj3];</span><br></pre></td></tr></table></figure>
<p>如果 obj1 和 obj3 非空，而 obj2 是 nil</p>
<p>那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常</p>
<h3 id="使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份："><a href="#使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：" class="headerlink" title="使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份："></a>使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMuatableArray</span> *mArray = [@[@<span class="number">1</span>, @<span class="number">2</span>] mutableCopy];</span><br></pre></td></tr></table></figure>
<h2 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用#define预处理指令</h2><p>详见<a href="http://www.cnblogs.com/chenyg32/p/5080301.html" target="_blank" rel="noopener">NSNotification Name 最佳写法</a></p>
<h2 id="第5条：用枚举表示状态、选项、状态码"><a href="#第5条：用枚举表示状态、选项、状态码" class="headerlink" title="第5条：用枚举表示状态、选项、状态码"></a>第5条：用枚举表示状态、选项、状态码</h2><h3 id="使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，"><a href="#使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，" class="headerlink" title="使用 NS_ENUM 和 NS_OPTIONS 来表示状态机，"></a>使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 来表示<code>状态机</code>，</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NS_ENUM，定义状态等普通枚举</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, TTGState) &#123;</span><br><span class="line">    TTGStateOK = <span class="number">0</span>,</span><br><span class="line">    TTGStateError,</span><br><span class="line">    TTGStateUnknow</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NS_OPTIONS，定义选项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, TTGDirection) &#123;</span><br><span class="line">    TTGDirectionNone = <span class="number">0</span>,</span><br><span class="line">    TTGDirectionTop = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    TTGDirectionLeft = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    TTGDirectionRight = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    TTGDirectionBottom = <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示"><a href="#如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示" class="headerlink" title="如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用 NS_OPTIONS，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用或操作将其组合起来进行表示"></a>如果一个<code>枚举变量</code>可以同时表示一个或多个选项的集合，那么应当使用 <code>NS_OPTIONS</code>，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用<code>或操作</code>将其组合起来进行表示</h3><h3 id="相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型"><a href="#相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型" class="headerlink" title="相比较 C 语言中的枚举，使用 NS_ENUM 和 NS_OPTIONS 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型"></a>相比较 C 语言中的枚举，使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _TTGState &#123;</span><br><span class="line">    TTGStateOK  = <span class="number">0</span>,</span><br><span class="line">    TTGStateError,</span><br><span class="line">    TTGStateUnknow</span><br><span class="line">&#125; TTGState;</span><br></pre></td></tr></table></figure>
<h3 id="处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举"><a href="#处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举" class="headerlink" title="处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举"></a>处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举</h3><h3 id="参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5"><a href="#参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5" class="headerlink" title="参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5"></a>参考链接：<a href="http://tutuge.me/2015/03/21/effective-objective-c-5-enum/" target="_blank" rel="noopener">Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5</a></h3><h1 id="第2章-对象、消息、运行期"><a href="#第2章-对象、消息、运行期" class="headerlink" title="第2章 对象、消息、运行期"></a>第2章 对象、消息、运行期</h1><h2 id="第6条：理解“属性”这一概念"><a href="#第6条：理解“属性”这一概念" class="headerlink" title="第6条：理解“属性”这一概念"></a>第6条：理解“属性”这一概念</h2><h3 id="理解好属性和实例变量的区别"><a href="#理解好属性和实例变量的区别" class="headerlink" title="理解好属性和实例变量的区别"></a>理解好<code>属性</code>和<code>实例变量</code>的区别</h3><p>属性 = 实例变量 + setter + getter</p>
<p>如果声明属性</p>
<pre><code>@property (nonatomic, copy) NSString *str;
</code></pre><p>则编译器会默认实现</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)str;</span><br><span class="line">- (<span class="keyword">void</span>)setStr:(<span class="built_in">NSString</span> *)str;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)str</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setStr:(<span class="built_in">NSString</span> *)str</span><br><span class="line">&#123;</span><br><span class="line">	_str = [str <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>_str</code> 就是<code>实例变量</code></p>
<h3 id="使用点语法访问属性-调用-setter-getter-方法"><a href="#使用点语法访问属性-调用-setter-getter-方法" class="headerlink" title="使用点语法访问属性 = 调用 setter/getter 方法"></a>使用<code>点语法</code>访问属性 = 调用 setter/getter 方法</h3><h3 id="Property-的4种-attribute"><a href="#Property-的4种-attribute" class="headerlink" title="Property 的4种 attribute"></a>Property 的4种 attribute</h3><ul>
<li>原子性(atomic, nonatomic)</li>
<li>读写权限(readonly, readwrite)</li>
<li>内存管理(strong, weak, unsafe_unretained, retain, assign, copy)</li>
<li>存取方法(getter, setter)</li>
</ul>
<h3 id="非-ARC-下，没有-weak"><a href="#非-ARC-下，没有-weak" class="headerlink" title="非 ARC 下，没有 weak"></a>非 ARC 下，没有 weak</h3><h3 id="ARC下，修饰指针的内存修饰符"><a href="#ARC下，修饰指针的内存修饰符" class="headerlink" title="ARC下，修饰指针的内存修饰符"></a>ARC下，修饰指针的内存修饰符</h3><ul>
<li><code>__weak</code>:不retain，如果对象被回收，该指针会被置nil</li>
<li><code>__strong</code>:默认，如果对象被回收，需要手动将指针置为nil？</li>
<li><code>__unsafe__unretained</code>:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）</li>
<li><code>__autoreleasing</code>:实现把对象”按引用传递”给方法，变量在方法返回时自动释放</li>
</ul>
<p>编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量</p>
<h3 id="常见数据类型的内存修饰符（待补充）"><a href="#常见数据类型的内存修饰符（待补充）" class="headerlink" title="常见数据类型的内存修饰符（待补充）"></a>常见数据类型的内存修饰符（待补充）</h3><table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">内存修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本数据类型(int, NSInteger)</td>
<td style="text-align:center">assign</td>
</tr>
<tr>
<td style="text-align:center">block</td>
<td style="text-align:center">copy</td>
</tr>
<tr>
<td style="text-align:center">NSString</td>
<td style="text-align:center">copy</td>
</tr>
<tr>
<td style="text-align:center">NSMutableString</td>
<td style="text-align:center">strong</td>
</tr>
<tr>
<td style="text-align:center">NSArray</td>
<td style="text-align:center">copy</td>
</tr>
<tr>
<td style="text-align:center">NSMutableArray</td>
<td style="text-align:center">strong</td>
</tr>
</tbody>
</table>
<h3 id="NSArray-用-strong-还是-copy-修饰"><a href="#NSArray-用-strong-还是-copy-修饰" class="headerlink" title="NSArray 用 strong 还是 copy 修饰"></a>NSArray 用 strong 还是 copy 修饰</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *strongArray;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSArray</span> *copyedArray;</span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line"><span class="keyword">self</span>.strongArray = [<span class="built_in">NSArray</span> array];</span><br><span class="line"><span class="keyword">self</span>.copyedArray = [<span class="built_in">NSArray</span> array];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [@[<span class="string">@"1"</span>] mutableCopy];</span><br><span class="line"><span class="keyword">self</span>.strongArray = mutableArray;</span><br><span class="line"><span class="keyword">self</span>.copyedArray = mutableArray;</span><br><span class="line">    </span><br><span class="line">[mutableArray addObject:<span class="string">@"2"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@\n%@\n%@"</span>, mutableArray, <span class="keyword">self</span>.strongArray, <span class="keyword">self</span>.copyedArray); <span class="comment">//输出 (1,2) (1,2) (1)</span></span><br></pre></td></tr></table></figure>
<p>可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。</p>
<h2 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h2><h3 id="类内使用-self-xxx-和-xxx-的区别"><a href="#类内使用-self-xxx-和-xxx-的区别" class="headerlink" title="类内使用 self.xxx 和 _xxx 的区别"></a>类内使用 self.xxx 和 _xxx 的区别</h3><ul>
<li>访问 _xxx 不经过 setter/getter 方法，速度更快</li>
<li>访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作</li>
<li>访问 _xxx 不经过 setter/getter 方法，无法触发 KVO</li>
<li>访问 _xxx 不经过 setter/getter 方法，无法断点</li>
</ul>
<h3 id="什么时候使用-xxx"><a href="#什么时候使用-xxx" class="headerlink" title="什么时候使用 _xxx"></a>什么时候使用 _xxx</h3><ul>
<li>折中方案，读的时候使用 _xxx，写的时候使用 self.xxx</li>
<li>父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错</li>
<li>如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性</li>
<li>使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)str</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!_str)</span><br><span class="line">		_str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line">	<span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h2><h2 id="第9条：以“类族模式”隐藏实现细节"><a href="#第9条：以“类族模式”隐藏实现细节" class="headerlink" title="第9条：以“类族模式”隐藏实现细节"></a>第9条：以“类族模式”隐藏实现细节</h2><h2 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h2><p>“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject (<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObject(<span class="keyword">id</span> object);    <span class="comment">// 移除object上的所有关联对象</span></span><br></pre></td></tr></table></figure>
<p>其中 objc_AssociationPolicy 是关联对象的属性，如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSOCIATION_ASSIGN             --- <span class="keyword">assign</span></span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC   --- <span class="keyword">nonatomic</span>, <span class="keyword">retain</span></span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC     --- <span class="keyword">nonatomic</span>, <span class="keyword">copy</span></span><br><span class="line">OBJC_ASSOCIATION_RETAIN             --- <span class="keyword">retain</span></span><br><span class="line">OBJC_ASSOCIATION_COPY               --- <span class="keyword">copy</span></span><br></pre></td></tr></table></figure>
<h3 id="与-NSDictionary-的区别"><a href="#与-NSDictionary-的区别" class="headerlink" title="与 NSDictionary 的区别"></a>与 NSDictionary 的区别</h3><p>设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。</p>
<p>所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @”xxx”</p>
<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>假如一个页面有2个弹窗，那么代码可能是这样写</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)askUserAQuestion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc]</span><br><span class="line">            initWithTitle:<span class="string">@"Question"</span></span><br><span class="line">                  message:<span class="string">@"What do you want to do?"</span></span><br><span class="line">                 delegate:<span class="keyword">self</span></span><br><span class="line">        cancelButtonTitle:<span class="string">@"Cancel"</span></span><br><span class="line">        otherButtonTitles:<span class="string">@"Continue"</span>, <span class="literal">nil</span>];</span><br><span class="line">    [alert show];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></span><br><span class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> doCancel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> doContinue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *EOCMyAlertViewKey = <span class="string">"EOCMyAlertViewKey"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)askUserAQuestion</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc]</span><br><span class="line">	        initWithTitle:<span class="string">@"Question"</span></span><br><span class="line">	              message:<span class="string">@"What do you want to do?"</span></span><br><span class="line">	             delegate:<span class="keyword">self</span></span><br><span class="line">	    cancelButtonTitle:<span class="string">@"Cancel"</span></span><br><span class="line">	    otherButtonTitles:<span class="string">@"Continue"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = ^(<span class="built_in">NSInteger</span> buttonIndex) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		    [<span class="keyword">self</span> doCancel];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">		    [<span class="keyword">self</span> doContinue];</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	objc_setAssociatedObject(alert,</span><br><span class="line">                             EOCMyAlertViewKey,</span><br><span class="line">                             block,</span><br><span class="line">                             OBJC_ASSOCIATION_COPY);</span><br><span class="line"></span><br><span class="line">	[alert show];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></span><br><span class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView</span><br><span class="line">    clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);</span><br><span class="line">	block(buttonIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView</p>
<h3 id="例子2-为协议文件添加属性"><a href="#例子2-为协议文件添加属性" class="headerlink" title="例子2 为协议文件添加属性"></a>例子2 为协议文件添加属性</h3><p>.h</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"QLJCEONAVRSSFeed.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QLJCEONAVRSSFeed</span> (<span class="title">contentOffset</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>)<span class="built_in">CGPoint</span> savedOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"QLJCEONAVRSSFeed+contentOffset.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define feed_saved_Off_set_x_key @<span class="meta-string">"feed_saved_Off_set_x_key"</span></span></span><br><span class="line"><span class="meta">#define feed_saved_Off_set_y_key @<span class="meta-string">"feed_saved_Off_set_y_key"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QLJCEONAVRSSFeed</span> (<span class="title">contentOffset</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> savedOffset;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGPoint</span>)savedOffset</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *xObj = objc_getAssociatedObject(<span class="keyword">self</span>, feed_saved_Off_set_x_key);</span><br><span class="line">    <span class="built_in">NSNumber</span> *yObj = objc_getAssociatedObject(<span class="keyword">self</span>, feed_saved_Off_set_y_key);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> point = <span class="built_in">CGPointMake</span>([xObj floatValue], [yObj floatValue]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSavedOffset:(<span class="built_in">CGPoint</span>)savedOffset</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h2><p>见 <a href="http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">Objective-C中的消息转发机制</a></p>
<h2 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h2><p>见 <a href="http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">Objective-C中的消息转发机制</a></p>
<h2 id="第13条：用“方法调配技术”调试“黑盒方法”"><a href="#第13条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第13条：用“方法调配技术”调试“黑盒方法”"></a>第13条：用“方法调配技术”调试“黑盒方法”</h2><p>创建自己的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSString+MyAdditions.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">MyAdditions</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)myLowercaseString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *lowercase = [<span class="keyword">self</span> myLowercaseString];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"This is my own method: %@"</span>, lowercase);</span><br><span class="line">    <span class="keyword">return</span> lowercase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>替换</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(lowercaseString));</span><br><span class="line">Method swappedMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(myLowercaseString));</span><br><span class="line">method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure>
<h2 id="第14条：理解“类对象”的用意"><a href="#第14条：理解“类对象”的用意" class="headerlink" title="第14条：理解“类对象”的用意"></a>第14条：理解“类对象”的用意</h2><h3 id="我们所说的-Objective-C-对象究竟是什么"><a href="#我们所说的-Objective-C-对象究竟是什么" class="headerlink" title="我们所说的 Objective-C 对象究竟是什么"></a>我们所说的 Objective-C 对象究竟是什么</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object&#123;</span><br><span class="line">  Class isa;  <span class="comment">//=&gt; 指向对象所属的类</span></span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>结论：Objective-C 对象 = id = objc_object</p>
<h3 id="那么-Class-是什么"><a href="#那么-Class-是什么" class="headerlink" title="那么 Class 是什么"></a>那么 Class 是什么</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<h3 id="那么-objc-class-又是什么"><a href="#那么-objc-class-又是什么" class="headerlink" title="那么 objc_class 又是什么"></a>那么 objc_class 又是什么</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;  </span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  </span><br><span class="line">    <span class="keyword">long</span> version;  </span><br><span class="line">    <span class="keyword">long</span> info;  </span><br><span class="line">    <span class="keyword">long</span> instance_size;  </span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;  </span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;  </span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;  </span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类的继承体系"><a href="#类的继承体系" class="headerlink" title="类的继承体系"></a>类的继承体系</h3><p><img src="http://7xsd8c.com1.z0.glb.clouddn.com/isa.png" alt=""></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"Hello"</span>;</span><br></pre></td></tr></table></figure>
<p>str 是一个对象，is a NSString</p>
<p>NSString 是类，is a NSString metaclass</p>
<p>NSString metaclass 是元类，类方法就定义在这里</p>
<h1 id="第3章-接口与API设计"><a href="#第3章-接口与API设计" class="headerlink" title="第3章 接口与API设计"></a>第3章 接口与API设计</h1><h2 id="done-第15条：用前缀避免命名空间冲突"><a href="#done-第15条：用前缀避免命名空间冲突" class="headerlink" title="done 第15条：用前缀避免命名空间冲突"></a>done 第15条：用前缀避免命名空间冲突</h2><h2 id="done-第16条：提供“全能初始化方法”"><a href="#done-第16条：提供“全能初始化方法”" class="headerlink" title="done 第16条：提供“全能初始化方法”"></a>done 第16条：提供“全能初始化方法”</h2><p>详见<a href="http://www.cnblogs.com/chenyg32/p/4870303.html" target="_blank" rel="noopener">Designated Initializer</a></p>
<h2 id="done-第17条：实现description方法"><a href="#done-第17条：实现description方法" class="headerlink" title="done 第17条：实现description方法"></a>done 第17条：实现description方法</h2><h2 id="done-第18条：尽量使用不可变对象"><a href="#done-第18条：尽量使用不可变对象" class="headerlink" title="done 第18条：尽量使用不可变对象"></a>done 第18条：尽量使用不可变对象</h2><ul>
<li>如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite</li>
<li>不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法</li>
</ul>
<h2 id="done-第19条：使用清晰而协调的命名方式"><a href="#done-第19条：使用清晰而协调的命名方式" class="headerlink" title="done 第19条：使用清晰而协调的命名方式:"></a>done 第19条：使用清晰而协调的命名方式:</h2><h3 id="如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了"><a href="#如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了" class="headerlink" title="如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了"></a>如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了</h3><h3 id="对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX"><a href="#对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX" class="headerlink" title="对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX"></a>对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX</h3><pre><code>@property (nonatomic, assign, getter = isOn) on;
</code></pre><h2 id="done-第20条：为私有方法名加前缀"><a href="#done-第20条：为私有方法名加前缀" class="headerlink" title="done 第20条：为私有方法名加前缀"></a>done 第20条：为私有方法名加前缀</h2><h2 id="done-第21条：理解Objective—C错误模型"><a href="#done-第21条：理解Objective—C错误模型" class="headerlink" title="done 第21条：理解Objective—C错误模型"></a>done 第21条：理解Objective—C错误模型</h2><h2 id="done-第22条：理解NSCopying协议"><a href="#done-第22条：理解NSCopying协议" class="headerlink" title="done 第22条：理解NSCopying协议"></a>done 第22条：理解NSCopying协议</h2><p>详见<a href="http://www.cnblogs.com/chenyg32/p/5167194.html" target="_blank" rel="noopener">浅析Objective-C的copy</a></p>
<h1 id="第4章-协议与分类"><a href="#第4章-协议与分类" class="headerlink" title="第4章 协议与分类"></a>第4章 协议与分类</h1><h2 id="第23条：通过委托与数据源协议进行对象间通信"><a href="#第23条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条：通过委托与数据源协议进行对象间通信"></a>第23条：通过委托与数据源协议进行对象间通信</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>([_delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData:)])</span><br><span class="line">&#123; </span><br><span class="line">    [_delegate networkFetcher:<span class="keyword">self</span> didReceiveData:data];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面的代码写了很多次，则可以考虑以下优化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在扩展中定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span>(</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">struct</span> &#123; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> didReceiveData : <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> didFailWithError : <span class="number">1</span>; </span><br><span class="line">    &#125; _delegateFlags; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> </span></span><br><span class="line">EOCNetworkFetcher </span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(<span class="keyword">id</span>)delegate</span><br><span class="line">&#123; </span><br><span class="line">    _delegate = delegate; <span class="comment">// 缓存委托对象相应方法能力 </span></span><br><span class="line">    _delegateFlags.didReceiveData = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData:)]; </span><br><span class="line">    _delegateFlags.didFailWithError = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didFailWithError:)]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">这样每次调用delegate相关方法之前就只需要直接查询标志：</span><br><span class="line"><span class="keyword">if</span>(_delegateFlags.didReceiveData)</span><br><span class="line">&#123; </span><br><span class="line">    [_delegate networkFetcher:<span class="keyword">self</span> didReceiveData:data]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="done-第24条：将类的实现代码分散到便于管理的数个分类之中"><a href="#done-第24条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="done 第24条：将类的实现代码分散到便于管理的数个分类之中"></a>done 第24条：将类的实现代码分散到便于管理的数个分类之中</h2><h2 id="第25条：总是为第三方类的分类名称加前缀"><a href="#第25条：总是为第三方类的分类名称加前缀" class="headerlink" title="第25条：总是为第三方类的分类名称加前缀"></a>第25条：总是为第三方类的分类名称加前缀</h2><ol>
<li>为第三方类添加分类时，总应给其名称加上你专用的前缀</li>
<li>为第三方类添加分类时，总应给方法名加上你专用的前缀</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">ABC_HTTP</span>)</span></span><br><span class="line">-(<span class="built_in">NSString</span> *)abc_urlEncodedString;</span><br><span class="line">-(<span class="built_in">NSString</span> *)abc_urlDecodedString;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="第26条：勿在分类中声明属性"><a href="#第26条：勿在分类中声明属性" class="headerlink" title="第26条：勿在分类中声明属性"></a>第26条：勿在分类中声明属性</h2><p>属性应该在主类中声明</p>
<p>如果分类中声明属性需要自己重写 setter 和 getter</p>
<p>方法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *kFriendsPropertyKey = <span class="string">"kFriendsPropertyKey"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span>(<span class="title">Friendship</span>)</span></span><br><span class="line"><span class="keyword">@dynamic</span> friends;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSArray</span>*)friends </span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, kFriendsPropertyKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setFriends:(<span class="built_in">NSArray</span>*)friends </span><br><span class="line">&#123;</span><br><span class="line">　　objc_setAssociaedObject(<span class="keyword">self</span>, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>缺点如下</p>
<ol>
<li>相似的代码要写很多遍</li>
<li>极易忽略属性定义的内存管理语义，且不好维护</li>
</ol>
<h2 id="第27条：使用“class—continuation分类”隐藏实现细节"><a href="#第27条：使用“class—continuation分类”隐藏实现细节" class="headerlink" title="第27条：使用“class—continuation分类”隐藏实现细节"></a>第27条：使用“class—continuation分类”隐藏实现细节</h2><p>声明私有实例变量的3种方法</p>
<ul>
<li><p>方法1：对外暴露，声明为 private（暴露了细节，不建议）</p>
<p>  .h</p>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ABC</span>:<span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    XYZ *_xyz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ol>
<li>把私有变量放在头文件，暴露了细节，不好</li>
<li>假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题</li>
<li>所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？</li>
</ol>
</li>
</ul>
<ul>
<li><p>方法2：不对外暴露</p>
<p>  .m</p>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ABC</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    XYZ *_xyz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) XYZ *xyz2;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法3：对外只读，对内读写</p>
<p>  .h</p>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) XYZ *xyz;</span><br></pre></td></tr></table></figure>
<p>  .m</p>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ABC</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) XYZ *xyz;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="done-第28条：通过协议提供匿名对象"><a href="#done-第28条：通过协议提供匿名对象" class="headerlink" title="done 第28条：通过协议提供匿名对象"></a>done 第28条：通过协议提供匿名对象</h2><h1 id="第5章-内存管理"><a href="#第5章-内存管理" class="headerlink" title="第5章 内存管理"></a>第5章 内存管理</h1><h2 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h2><h3 id="悬浮指针"><a href="#悬浮指针" class="headerlink" title="悬浮指针"></a>悬浮指针</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">1</span>];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line">number = <span class="literal">nil</span>;   <span class="comment">//如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知</span></span><br></pre></td></tr></table></figure>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)stringValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hello"</span>];</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放</p>
<p>但是，这是十分不合理的，因为从方法名上看（不含<code>alloc/new/copy/mutableCopy</code>），调用者并不知道它需要负责释放该对象</p>
<p>所以此时，autorelease 就应运而生了</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)stringValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hello"</span>];</span><br><span class="line">    <span class="keyword">return</span> [str autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>str 对象会在其所在的释放池释放的时候被释放</p>
<p>如果外部需要 retain 该返回值，则需要这样做</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = [[<span class="keyword">self</span> stringValue] <span class="keyword">retain</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[str release];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间</p>
</blockquote>
<h2 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h2><h3 id="ARC-的本质是自动添加-release-retian-autorelease-等"><a href="#ARC-的本质是自动添加-release-retian-autorelease-等" class="headerlink" title="ARC 的本质是自动添加 release/retian/autorelease 等"></a>ARC 的本质是自动添加 release/retian/autorelease 等</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (XYZ *)newXYZ</span><br><span class="line">&#123;</span><br><span class="line">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class="line">    <span class="keyword">return</span> xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (XYZ *)createXYZ</span><br><span class="line">&#123;</span><br><span class="line">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class="line">    <span class="comment">/*ARC自动添加</span></span><br><span class="line"><span class="comment">    xyz = [xyz autorelease];</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)f</span><br><span class="line">&#123;</span><br><span class="line">    XYZ *xyz1 = [XYZ newXYZ];</span><br><span class="line">    XYZ *xyz2 = [XYZ createXYZ];</span><br><span class="line">    <span class="comment">/*ARC自动添加</span></span><br><span class="line"><span class="comment">    [xyz1 release];</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展阅读：iOS开发ARC内存管理技术要点"><a href="#扩展阅读：iOS开发ARC内存管理技术要点" class="headerlink" title="扩展阅读：iOS开发ARC内存管理技术要点"></a>扩展阅读：<a href="http://www.cnblogs.com/flyFreeZn/p/4264220.html" target="_blank" rel="noopener">iOS开发ARC内存管理技术要点</a></h3><h2 id="done-第31条：在dealloc方法中只释放引用并解除监听"><a href="#done-第31条：在dealloc方法中只释放引用并解除监听" class="headerlink" title="done 第31条：在dealloc方法中只释放引用并解除监听"></a>done 第31条：在dealloc方法中只释放引用并解除监听</h2><h2 id="done-第32条：编写“异常安全代码”时留意内存管理问题"><a href="#done-第32条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="done 第32条：编写“异常安全代码”时留意内存管理问题"></a>done 第32条：编写“异常安全代码”时留意内存管理问题</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class="line"> [object doSomethingThatMayThrow];</span><br><span class="line"> [object release];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (...) &#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Whoops, there was an error. Oh well..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏</p>
<p>解决方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EOCSomeClass *object;</span><br><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line"> object = [[EOCSomeClass alloc] init];</span><br><span class="line"> [object doSomethingThatMayThrow];&#125;</span><br><span class="line"><span class="keyword">@catch</span> (...) &#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Whoops, there was an error. Oh well..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@finally</span> &#123;</span><br><span class="line"> [object release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，ARC 下也会发生这个问题</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class="line"> [object doSomethingThatMayThrow];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (...) &#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Whoops, there was an error. Oh well..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题</p>
<p>总结：</p>
<ol>
<li>当捕获到异常,应该注意确保@try中创建的对象被清理完成.</li>
<li>ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.</li>
</ol>
<h2 id="done-第33条：以弱引用避免保留环"><a href="#done-第33条：以弱引用避免保留环" class="headerlink" title="done 第33条：以弱引用避免保留环"></a>done 第33条：以弱引用避免保留环</h2><h2 id="done-第34条：以“自动释放池块”降低内存峰值"><a href="#done-第34条：以“自动释放池块”降低内存峰值" class="headerlink" title="done 第34条：以“自动释放池块”降低内存峰值"></a>done 第34条：以“自动释放池块”降低内存峰值</h2><p>ARC下，可以使用 @autoreleasepool 来降低内存峰值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9999</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        A *a = [[A alloc] init];</span><br><span class="line">        [<span class="keyword">self</span> handle:a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值</p>
<p>使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="comment">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用</p>
<p>另外，关于降低内存峰值的之前也有学习过，见<a href="http://www.cnblogs.com/chenyg32/p/3859110.html" target="_blank" rel="noopener">Objective-C 内存管理</a></p>
<h2 id="done-第35条：用“僵尸对象”调试内存管理问题"><a href="#done-第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="done 第35条：用“僵尸对象”调试内存管理问题"></a>done 第35条：用“僵尸对象”调试内存管理问题</h2><p>僵尸对象是调试内存管理问题的最佳方式</p>
<p>被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。</p>
<p>打开僵尸对象的方法：</p>
<p>Xcode -&gt; Run -&gt; Diagnostics -&gt; Enable Zombie Objects<br><img src="http://img.blog.csdn.net/20150803102818758" alt=""></p>
<p>僵尸对象的原理：</p>
<p>替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存</p>
<p>原理代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtain the class of the object being deallocated</span></span><br><span class="line">Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the class's name</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepend _NSZombie_ to the class name</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *zombieClsName = <span class="string">@"_NSZombie_"</span> + clsName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See if the specific zombie class exists</span></span><br><span class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the specific zombie class doesn't exists,</span></span><br><span class="line"><span class="comment">// then it needs to be created</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!zombieCls)&#123;</span><br><span class="line"><span class="comment">// Obtain the template  zombie class, where the new class's </span></span><br><span class="line"><span class="comment">// name is the prepended string from above</span></span><br><span class="line">   zombieCls = objc_duplicateClass(baseZombieCls,   </span><br><span class="line">   zombieClsName,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform normal destruction of the object being deallocated</span></span><br><span class="line">objc_destructInstance(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the class of the object being deallocated</span></span><br><span class="line"><span class="comment">// to the zombie class</span></span><br><span class="line">objc_setClass(<span class="keyword">self</span>, zombieCls) </span><br><span class="line"></span><br><span class="line"><span class="comment">// The class of "self" is now _NSZombie_OriginalClass</span></span><br></pre></td></tr></table></figure>
<h2 id="done-第36条：不要使用retainCount"><a href="#done-第36条：不要使用retainCount" class="headerlink" title="done 第36条：不要使用retainCount"></a>done 第36条：不要使用retainCount</h2><h1 id="第6章-块与大中枢派发"><a href="#第6章-块与大中枢派发" class="headerlink" title="第6章 块与大中枢派发"></a>第6章 块与大中枢派发</h1><h2 id="done-第37条：理解“块”这一概念"><a href="#done-第37条：理解“块”这一概念" class="headerlink" title="done 第37条：理解“块”这一概念"></a>done 第37条：理解“块”这一概念</h2><pre><code>在Objective-C语言中，一共有3种类型的block：
_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。
_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。
_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。
</code></pre><ul>
<li><p>全局 Block：_NSConcreteGlobalBlock</p>
<ul>
<li>定义在函数外面的 block 是全局静态的，没有访问任何外部变量</li>
<li><p>定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的</p>
<p>问题：那么定义在函数外部的，捕获变量的，是 global 吗？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> f()</span><br><span class="line">&#123;</span><br><span class="line">    ^&#123; printf(<span class="string">"Hello, World!\n"</span>); &#125; ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>栈 Block：_NSConcreteStackBlock</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> f()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line">    ^&#123; printf(<span class="string">"%c\n"</span>,a); &#125; ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆 Block：_NSConcreteMallocBlock</p>
<p>  NSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> f()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block)() = [^&#123; printf(<span class="string">"%c\n"</span>,a); &#125; <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>对全局 Block 进行 copy 后，什么事也不会发生
对栈 Block 进行 copy 后，会得到一个堆 Block
对堆 Block 进行 copy 后，其引用计数会加1
</code></pre></li>
<li><p>例子</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blcok)();</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>
<p>  block执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放</p>
<p>  正确做法是</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blcok)();</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    block = [^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">    &#125; <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>
</li>
<li><p>更多细节见<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">《谈Objective-C block的实现》</a></p>
</li>
</ul>
<h2 id="done-第38条：为常用的块类型创建typedef"><a href="#done-第38条：为常用的块类型创建typedef" class="headerlink" title="done 第38条：为常用的块类型创建typedef"></a>done 第38条：为常用的块类型创建typedef</h2><h2 id="done-第39条：用handler块降低代码分散程度"><a href="#done-第39条：用handler块降低代码分散程度" class="headerlink" title="done 第39条：用handler块降低代码分散程度"></a>done 第39条：用handler块降低代码分散程度</h2><h2 id="第40条：用块引用其所属对象时不要出现保留环"><a href="#第40条：用块引用其所属对象时不要出现保留环" class="headerlink" title="第40条：用块引用其所属对象时不要出现保留环"></a>第40条：用块引用其所属对象时不要出现保留环</h2><p>例子1</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOCNetworkFetcher.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class="built_in">NSData</span> *data);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *url;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span>*)url;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOCNetworkFetcher.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"EOCNetworkFetcher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSURL</span> *url;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) EOCNetworkFetcherCompletionHandler completionHandler;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *downloadedData;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCNetworkFetcher</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span>*)url</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">				_url = url;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">self</span>.completionHandler = completion;</span><br><span class="line">		<span class="comment">// Start the request</span></span><br><span class="line">		<span class="comment">// Request sets downloadedData property</span></span><br><span class="line">		<span class="comment">// When request is finished, p_requestCompleted is called</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)p_requestCompleted &#123;</span><br><span class="line">		<span class="keyword">if</span> (_completionHandler) &#123;</span><br><span class="line">				_completionHandler(_downloadedData);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCClass</span></span></span><br><span class="line">&#123;</span><br><span class="line">    EOCNetworkFetcher* _networkFetcher;</span><br><span class="line">    <span class="built_in">NSData</span>* _fetchedData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span>* url = [[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"http://www.example.com/something.dat"</span>];</span><br><span class="line">		</span><br><span class="line">    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class="line"></span><br><span class="line">		[_networkFetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data)&#123;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">NSLog</span>(<span class="string">@"Request URL %@ finished"</span>, _networkFetcher.url);</span><br><span class="line">				_fetchedData = data;</span><br><span class="line"></span><br><span class="line">		&#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>EoCClass -&gt; networkFetcher -&gt; block -&gt; self(通过_fetchedData)</p>
<p>例子2</p>
<p>将 networkFetcher 变为局部变量，修改如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadData &#123;</span><br><span class="line"> <span class="built_in">NSURL</span> *url = [[<span class="built_in">NSURL</span> alloc] initWithString:</span><br><span class="line"> <span class="string">@"http://www.example.com/something.dat"</span>];</span><br><span class="line"> EOCNetworkFetcher *networkFetcher =</span><br><span class="line"> [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class="line"> [networkFetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data)&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Request URL %@ finished"</span>, networkFetcher.url);</span><br><span class="line"> _fetchedData = data;</span><br><span class="line"> &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>networkFetcher -&gt; block -&gt; networkFetcher(通过url)</p>
<h2 id="第41条：多用派发队列，少用同步锁"><a href="#第41条：多用派发队列，少用同步锁" class="headerlink" title="第41条：多用派发队列，少用同步锁"></a>第41条：多用派发队列，少用同步锁</h2><h2 id="第42条：多用GCD，少用performSelector系列方法"><a href="#第42条：多用GCD，少用performSelector系列方法" class="headerlink" title="第42条：多用GCD，少用performSelector系列方法"></a>第42条：多用GCD，少用performSelector系列方法</h2><h3 id="如何延迟执行一个方法"><a href="#如何延迟执行一个方法" class="headerlink" title="如何延迟执行一个方法"></a>如何延迟执行一个方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：使用 performSelector</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(foo) withObject:<span class="literal">nil</span> afterDelay:<span class="number">5.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：使用 dispatch_after</span></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> foo];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>
<p>当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消</p>
<h3 id="如何让一个方法在主线程执行"><a href="#如何让一个方法在主线程执行" class="headerlink" title="如何让一个方法在主线程执行"></a>如何让一个方法在主线程执行</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：使用 performSelector</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(foo) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：使用 dispatch_after</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> foo];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>
<h2 id="第43条：掌握GCD及操作队列的使用时机"><a href="#第43条：掌握GCD及操作队列的使用时机" class="headerlink" title="第43条：掌握GCD及操作队列的使用时机"></a>第43条：掌握GCD及操作队列的使用时机</h2><p>要知道有个东西叫做 NSOperationQueue 就行了</p>
<h2 id="第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第44条：通过Dispatch Group机制，根据系统资源状况来执行任务"></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务</h2><h2 id="第45条：使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#第45条：使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="第45条：使用dispatch_once来执行只需运行一次的线程安全代码"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h2><p>以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once</p>
<p>比如单例的书写方式<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第46条：不要使用dispatch-get-current-queue"><a href="#第46条：不要使用dispatch-get-current-queue" class="headerlink" title="第46条：不要使用dispatch_get_current_queue"></a>第46条：不要使用<code>dispatch_get_current_queue</code></h2><p>尽量别用，该接口已废弃</p>
<h1 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h1><h2 id="第47条：熟悉系统框架"><a href="#第47条：熟悉系统框架" class="headerlink" title="第47条：熟悉系统框架"></a>第47条：熟悉系统框架</h2><ul>
<li>CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）</li>
<li>CoreAudio:音频处理 API（C语言）</li>
<li>AVFoundation:视频处理接口（Objective-C）</li>
<li>CoreData:数据库接口（Objective-C）</li>
<li>CoreText:文字渲染排版接口（C语言）</li>
</ul>
<h2 id="done-第48条：多用块枚举，少用for循环"><a href="#done-第48条：多用块枚举，少用for循环" class="headerlink" title="done 第48条：多用块枚举，少用for循环"></a>done 第48条：多用块枚举，少用for循环</h2><h2 id="第49条：对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条：对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条：对自定义其内存管理语义的collection使用无缝桥接"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h2><h3 id="使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构"><a href="#使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构" class="headerlink" title="使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构"></a>使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br><span class="line"><span class="built_in">CFArrayRef</span> cfArray = (__bridge <span class="built_in">CFArrayRef</span>)array;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ count: %li"</span>, cfArray, <span class="built_in">CFArrayGetCount</span>(cfArray));</span><br></pre></td></tr></table></figure>
<ul>
<li>NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray</li>
<li>CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数</li>
</ul>
<h3 id="桥式转换"><a href="#桥式转换" class="headerlink" title="桥式转换"></a>桥式转换</h3><ul>
<li><code>__bridge</code>：只做类型转换，不修改对象（内存）管理权；</li>
<li><code>__bridge_retained</code>：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；</li>
<li><code>__bridge_transfer</code>：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br><span class="line"><span class="built_in">CFArrayRef</span> cfArray = (__bridge_retained <span class="built_in">CFArrayRef</span>)array;</span><br><span class="line"><span class="built_in">CFRelease</span>(cfArray);  <span class="comment">// 因为是 __bridge_retained，所以需要调用 CFRelease</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br><span class="line"><span class="built_in">CFArrayRef</span> cfArray = (__bridge_retained <span class="built_in">CFArrayRef</span>)array;</span><br><span class="line"><span class="built_in">NSArray</span> *array2 = (__bridge_transfer <span class="built_in">NSArray</span> *)cfArray;</span><br><span class="line"><span class="comment">//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理</span></span><br></pre></td></tr></table></figure>
<h3 id="使用无缝桥接修改-Collection-的内存管理语义"><a href="#使用无缝桥接修改-Collection-的内存管理语义" class="headerlink" title="使用无缝桥接修改 Collection 的内存管理语义"></a>使用无缝桥接修改 Collection 的内存管理语义</h3><p>NSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error</p>
<p>关于拷贝协议可以查看：<a href="http://www.cnblogs.com/chenyg32/p/5167194.html" target="_blank" rel="noopener">浅析Objective-C的copy</a></p>
<p>无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典</p>
<p>创建函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableDictionaryRef</span> <span class="built_in">CFDictionaryCreateMutable</span>(</span><br><span class="line">    <span class="built_in">CFAllocatorRef</span> allocator,  <span class="comment">// 一般传NULL，采用系统默认的内存分配器</span></span><br><span class="line">    <span class="built_in">CFIndex</span> capacity,          <span class="comment">// 初始大小，并非最大容量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CFDictionaryKeyCallBacks</span> *keyCallBacks,    <span class="comment">// 回调</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CFDictionaryValueCallBacks</span> *valueCallBacks <span class="comment">// 回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>键值回调</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>				version;    <span class="comment">//一般为0</span></span><br><span class="line">    <span class="built_in">CFDictionaryRetainCallBack</span>		<span class="keyword">retain</span>; <span class="comment">//遇到retain的回调</span></span><br><span class="line">    <span class="built_in">CFDictionaryReleaseCallBack</span>		release;<span class="comment">//遇到release的回调</span></span><br><span class="line">    <span class="built_in">CFDictionaryCopyDescriptionCallBack</span>	copyDescription;<span class="comment">//一般传NULL，采用系统默认</span></span><br><span class="line">    <span class="built_in">CFDictionaryEqualCallBack</span>		equal;  <span class="comment">//一般传CFEqual</span></span><br><span class="line">    <span class="built_in">CFDictionaryHashCallBack</span>		hash;   <span class="comment">//一般传CFHash</span></span><br><span class="line">&#125; <span class="built_in">CFDictionaryKeyCallBacks</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>				version;    <span class="comment">//一般为0</span></span><br><span class="line">    <span class="built_in">CFDictionaryRetainCallBack</span>		<span class="keyword">retain</span>; <span class="comment">//遇到retain的回调</span></span><br><span class="line">    <span class="built_in">CFDictionaryReleaseCallBack</span>		release;<span class="comment">//遇到release的回调</span></span><br><span class="line">    <span class="built_in">CFDictionaryCopyDescriptionCallBack</span>	copyDescription;    <span class="comment">//一般传NULL，采用系统默认</span></span><br><span class="line">    <span class="built_in">CFDictionaryEqualCallBack</span>		equal;  <span class="comment">//一般传CFEqual</span></span><br><span class="line">&#125; <span class="built_in">CFDictionaryValueCallBacks</span>;</span><br></pre></td></tr></table></figure>
<p>创建“保留”键，“保留”值的 NSDictionary</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>* EOCRetainCallback (<span class="built_in">CFAllocatorRef</span> allocator , <span class="keyword">const</span> <span class="keyword">void</span> *value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRetain</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> EOCReleaseCallback(<span class="built_in">CFAllocatorRef</span> allocator , <span class="keyword">const</span> <span class="keyword">void</span> *value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRelease</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFDictionaryKeyCallBacks</span> keyCallbacks = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    EOCRetainCallback,</span><br><span class="line">    EOCReleaseCallback,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="built_in">CFEqual</span>,</span><br><span class="line">    <span class="built_in">CFHash</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFDictionaryValueCallBacks</span> valueCallbacks = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    EOCRetainCallback,</span><br><span class="line">    EOCReleaseCallback,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="built_in">CFEqual</span>,</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">CFMutableDictionaryRef</span> aCFDictionary = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;keyCallbacks, &amp;valueCallbacks);</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *anNSdictionary = (__bridge_transfer <span class="built_in">NSMutableDictionary</span> *)aCFDictionary;</span><br></pre></td></tr></table></figure>
<h2 id="第50条：构建缓存时选用NSCache而非NSDictionary"><a href="#第50条：构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="第50条：构建缓存时选用NSCache而非NSDictionary"></a>第50条：构建缓存时选用NSCache而非NSDictionary</h2><ul>
<li>实现缓存时应选用 NSCache 而非 NSDictionary</li>
<li>可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据</li>
<li>NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）</li>
<li>NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）</li>
<li>使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除</li>
</ul>
<p>扩展阅读：<a href="https://www.ganlvji.com/nscache/" target="_blank" rel="noopener">利用NSCache提升效率</a></p>
<h2 id="第51条：精简initialize与load的实现代码"><a href="#第51条：精简initialize与load的实现代码" class="headerlink" title="第51条：精简initialize与load的实现代码"></a>第51条：精简initialize与load的实现代码</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">load</th>
<th style="text-align:center">initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">执行次数</td>
<td style="text-align:center">1次</td>
<td style="text-align:center">1次</td>
</tr>
<tr>
<td style="text-align:center">执行时机</td>
<td style="text-align:center">app启动时所有运行时需要用到的类</td>
<td style="text-align:center">惰性调用，需要使用到具体类的时候才调用</td>
</tr>
<tr>
<td style="text-align:center">作用</td>
<td style="text-align:center">调试 现基本不用</td>
<td style="text-align:center">初始化全局oc对象（普通对象可以在声明的时候初始化）</td>
</tr>
<tr>
<td style="text-align:center">执行时环境</td>
<td style="text-align:center">系统不稳定，许多东西尚未初始化</td>
<td style="text-align:center">系统处于正常状态</td>
</tr>
<tr>
<td style="text-align:center">调用顺序</td>
<td style="text-align:center">1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类</td>
<td style="text-align:center">跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名</td>
</tr>
<tr>
<td style="text-align:center">相同点</td>
<td style="text-align:center">1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁</td>
<td style="text-align:center">同左</td>
</tr>
</tbody>
</table>
<h3 id="initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）"><a href="#initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）" class="headerlink" title="initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）"></a>initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）</h3><p>假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">A</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>此时创建一个B对象，输出是</p>
<blockquote>
<p>A<br>B</p>
</blockquote>
<p>初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B</p>
<p>所以 A 的 initialize 方法应该这样写</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [A <span class="keyword">class</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时创建一个B对象，输出是</p>
<blockquote>
<p>B</p>
</blockquote>
<h2 id="第52条：别忘了NSTimer会保留其目标对象"><a href="#第52条：别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条：别忘了NSTimer会保留其目标对象"></a>第52条：别忘了NSTimer会保留其目标对象</h2><p>参见：<a href="http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">NSTimer 会保留目标对象</a></p>

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/28/UITableView 中，UICollectionView 相互复用之间 contentOffset/" rel="next" title="UITableView 中，UICollectionView 相互复用之间 contentOffset">
                <i class="fa fa-chevron-left"></i> UITableView 中，UICollectionView 相互复用之间 contentOffset
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/02/18/iOS技能树/" rel="prev" title="iOS 技能树">
                iOS 技能树 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/03/19/Effective-Objective-C-读书笔记/"
           data-title="Effective-Objective-C-读书笔记" data-url="http://yoursite.com/2016/03/19/Effective-Objective-C-读书笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            博客概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://p3.music.126.net/JBP9iipdDGfVgImBMMmfKw==/3264450032066237.jpg"
               alt="Norcy" />
          <p class="site-author-name" itemprop="name">Norcy</p>
          <p class="site-description motion-element" itemprop="description">iOS 修煉ing</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-熟悉Objective—C"><span class="nav-number">1.</span> <span class="nav-text">第1章 熟悉Objective—C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第1条：了解Objective—C语言的起源"><span class="nav-number">1.1.</span> <span class="nav-text">第1条：了解Objective—C语言的起源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第2条：在类的头文件中尽量少引入其他头文件"><span class="nav-number">1.2.</span> <span class="nav-text">第2条：在类的头文件中尽量少引入其他头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第3条：多用字面量语法，少用与之等价的方法"><span class="nav-number">1.3.</span> <span class="nav-text">第3条：多用字面量语法，少用与之等价的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用字面量语法，它是一种语法糖："><span class="nav-number">1.3.1.</span> <span class="nav-text">使用字面量语法，它是一种语法糖：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#这个语法糖更容易暴露隐藏的问题"><span class="nav-number">1.3.2.</span> <span class="nav-text">这个语法糖更容易暴露隐藏的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份："><span class="nav-number">1.3.3.</span> <span class="nav-text">使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第4条：多用类型常量，少用-define预处理指令"><span class="nav-number">1.4.</span> <span class="nav-text">第4条：多用类型常量，少用#define预处理指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第5条：用枚举表示状态、选项、状态码"><span class="nav-number">1.5.</span> <span class="nav-text">第5条：用枚举表示状态、选项、状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，"><span class="nav-number">1.5.1.</span> <span class="nav-text">使用 NS_ENUM 和 NS_OPTIONS 来表示状态机，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示"><span class="nav-number">1.5.2.</span> <span class="nav-text">如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用 NS_OPTIONS，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用或操作将其组合起来进行表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型"><span class="nav-number">1.5.3.</span> <span class="nav-text">相比较 C 语言中的枚举，使用 NS_ENUM 和 NS_OPTIONS 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举"><span class="nav-number">1.5.4.</span> <span class="nav-text">处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5"><span class="nav-number">1.5.5.</span> <span class="nav-text">参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第2章-对象、消息、运行期"><span class="nav-number">2.</span> <span class="nav-text">第2章 对象、消息、运行期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第6条：理解“属性”这一概念"><span class="nav-number">2.1.</span> <span class="nav-text">第6条：理解“属性”这一概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解好属性和实例变量的区别"><span class="nav-number">2.1.1.</span> <span class="nav-text">理解好属性和实例变量的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用点语法访问属性-调用-setter-getter-方法"><span class="nav-number">2.1.2.</span> <span class="nav-text">使用点语法访问属性 = 调用 setter/getter 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Property-的4种-attribute"><span class="nav-number">2.1.3.</span> <span class="nav-text">Property 的4种 attribute</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非-ARC-下，没有-weak"><span class="nav-number">2.1.4.</span> <span class="nav-text">非 ARC 下，没有 weak</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC下，修饰指针的内存修饰符"><span class="nav-number">2.1.5.</span> <span class="nav-text">ARC下，修饰指针的内存修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见数据类型的内存修饰符（待补充）"><span class="nav-number">2.1.6.</span> <span class="nav-text">常见数据类型的内存修饰符（待补充）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSArray-用-strong-还是-copy-修饰"><span class="nav-number">2.1.7.</span> <span class="nav-text">NSArray 用 strong 还是 copy 修饰</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第7条：在对象内部尽量直接访问实例变量"><span class="nav-number">2.2.</span> <span class="nav-text">第7条：在对象内部尽量直接访问实例变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类内使用-self-xxx-和-xxx-的区别"><span class="nav-number">2.2.1.</span> <span class="nav-text">类内使用 self.xxx 和 _xxx 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候使用-xxx"><span class="nav-number">2.2.2.</span> <span class="nav-text">什么时候使用 _xxx</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8条：理解“对象等同性”这一概念"><span class="nav-number">2.3.</span> <span class="nav-text">第8条：理解“对象等同性”这一概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第9条：以“类族模式”隐藏实现细节"><span class="nav-number">2.4.</span> <span class="nav-text">第9条：以“类族模式”隐藏实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第10条：在既有类中使用关联对象存放自定义数据"><span class="nav-number">2.5.</span> <span class="nav-text">第10条：在既有类中使用关联对象存放自定义数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法"><span class="nav-number">2.5.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与-NSDictionary-的区别"><span class="nav-number">2.5.2.</span> <span class="nav-text">与 NSDictionary 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子1"><span class="nav-number">2.5.3.</span> <span class="nav-text">例子1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子2-为协议文件添加属性"><span class="nav-number">2.5.4.</span> <span class="nav-text">例子2 为协议文件添加属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第11条：理解objc-msgSend的作用"><span class="nav-number">2.6.</span> <span class="nav-text">第11条：理解objc_msgSend的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第12条：理解消息转发机制"><span class="nav-number">2.7.</span> <span class="nav-text">第12条：理解消息转发机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第13条：用“方法调配技术”调试“黑盒方法”"><span class="nav-number">2.8.</span> <span class="nav-text">第13条：用“方法调配技术”调试“黑盒方法”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第14条：理解“类对象”的用意"><span class="nav-number">2.9.</span> <span class="nav-text">第14条：理解“类对象”的用意</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#我们所说的-Objective-C-对象究竟是什么"><span class="nav-number">2.9.1.</span> <span class="nav-text">我们所说的 Objective-C 对象究竟是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#那么-Class-是什么"><span class="nav-number">2.9.2.</span> <span class="nav-text">那么 Class 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#那么-objc-class-又是什么"><span class="nav-number">2.9.3.</span> <span class="nav-text">那么 objc_class 又是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承体系"><span class="nav-number">2.9.4.</span> <span class="nav-text">类的继承体系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第3章-接口与API设计"><span class="nav-number">3.</span> <span class="nav-text">第3章 接口与API设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第15条：用前缀避免命名空间冲突"><span class="nav-number">3.1.</span> <span class="nav-text">done 第15条：用前缀避免命名空间冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第16条：提供“全能初始化方法”"><span class="nav-number">3.2.</span> <span class="nav-text">done 第16条：提供“全能初始化方法”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第17条：实现description方法"><span class="nav-number">3.3.</span> <span class="nav-text">done 第17条：实现description方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第18条：尽量使用不可变对象"><span class="nav-number">3.4.</span> <span class="nav-text">done 第18条：尽量使用不可变对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第19条：使用清晰而协调的命名方式"><span class="nav-number">3.5.</span> <span class="nav-text">done 第19条：使用清晰而协调的命名方式:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了"><span class="nav-number">3.5.1.</span> <span class="nav-text">如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX"><span class="nav-number">3.5.2.</span> <span class="nav-text">对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第20条：为私有方法名加前缀"><span class="nav-number">3.6.</span> <span class="nav-text">done 第20条：为私有方法名加前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第21条：理解Objective—C错误模型"><span class="nav-number">3.7.</span> <span class="nav-text">done 第21条：理解Objective—C错误模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第22条：理解NSCopying协议"><span class="nav-number">3.8.</span> <span class="nav-text">done 第22条：理解NSCopying协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第4章-协议与分类"><span class="nav-number">4.</span> <span class="nav-text">第4章 协议与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第23条：通过委托与数据源协议进行对象间通信"><span class="nav-number">4.1.</span> <span class="nav-text">第23条：通过委托与数据源协议进行对象间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第24条：将类的实现代码分散到便于管理的数个分类之中"><span class="nav-number">4.2.</span> <span class="nav-text">done 第24条：将类的实现代码分散到便于管理的数个分类之中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第25条：总是为第三方类的分类名称加前缀"><span class="nav-number">4.3.</span> <span class="nav-text">第25条：总是为第三方类的分类名称加前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第26条：勿在分类中声明属性"><span class="nav-number">4.4.</span> <span class="nav-text">第26条：勿在分类中声明属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第27条：使用“class—continuation分类”隐藏实现细节"><span class="nav-number">4.5.</span> <span class="nav-text">第27条：使用“class—continuation分类”隐藏实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第28条：通过协议提供匿名对象"><span class="nav-number">4.6.</span> <span class="nav-text">done 第28条：通过协议提供匿名对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第5章-内存管理"><span class="nav-number">5.</span> <span class="nav-text">第5章 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第29条：理解引用计数"><span class="nav-number">5.1.</span> <span class="nav-text">第29条：理解引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#悬浮指针"><span class="nav-number">5.1.1.</span> <span class="nav-text">悬浮指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autorelease"><span class="nav-number">5.1.2.</span> <span class="nav-text">autorelease</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第30条：以ARC简化引用计数"><span class="nav-number">5.2.</span> <span class="nav-text">第30条：以ARC简化引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC-的本质是自动添加-release-retian-autorelease-等"><span class="nav-number">5.2.1.</span> <span class="nav-text">ARC 的本质是自动添加 release/retian/autorelease 等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展阅读：iOS开发ARC内存管理技术要点"><span class="nav-number">5.2.2.</span> <span class="nav-text">扩展阅读：iOS开发ARC内存管理技术要点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第31条：在dealloc方法中只释放引用并解除监听"><span class="nav-number">5.3.</span> <span class="nav-text">done 第31条：在dealloc方法中只释放引用并解除监听</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第32条：编写“异常安全代码”时留意内存管理问题"><span class="nav-number">5.4.</span> <span class="nav-text">done 第32条：编写“异常安全代码”时留意内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第33条：以弱引用避免保留环"><span class="nav-number">5.5.</span> <span class="nav-text">done 第33条：以弱引用避免保留环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第34条：以“自动释放池块”降低内存峰值"><span class="nav-number">5.6.</span> <span class="nav-text">done 第34条：以“自动释放池块”降低内存峰值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第35条：用“僵尸对象”调试内存管理问题"><span class="nav-number">5.7.</span> <span class="nav-text">done 第35条：用“僵尸对象”调试内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第36条：不要使用retainCount"><span class="nav-number">5.8.</span> <span class="nav-text">done 第36条：不要使用retainCount</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第6章-块与大中枢派发"><span class="nav-number">6.</span> <span class="nav-text">第6章 块与大中枢派发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第37条：理解“块”这一概念"><span class="nav-number">6.1.</span> <span class="nav-text">done 第37条：理解“块”这一概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第38条：为常用的块类型创建typedef"><span class="nav-number">6.2.</span> <span class="nav-text">done 第38条：为常用的块类型创建typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第39条：用handler块降低代码分散程度"><span class="nav-number">6.3.</span> <span class="nav-text">done 第39条：用handler块降低代码分散程度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第40条：用块引用其所属对象时不要出现保留环"><span class="nav-number">6.4.</span> <span class="nav-text">第40条：用块引用其所属对象时不要出现保留环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第41条：多用派发队列，少用同步锁"><span class="nav-number">6.5.</span> <span class="nav-text">第41条：多用派发队列，少用同步锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第42条：多用GCD，少用performSelector系列方法"><span class="nav-number">6.6.</span> <span class="nav-text">第42条：多用GCD，少用performSelector系列方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何延迟执行一个方法"><span class="nav-number">6.6.1.</span> <span class="nav-text">如何延迟执行一个方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何让一个方法在主线程执行"><span class="nav-number">6.6.2.</span> <span class="nav-text">如何让一个方法在主线程执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第43条：掌握GCD及操作队列的使用时机"><span class="nav-number">6.7.</span> <span class="nav-text">第43条：掌握GCD及操作队列的使用时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务"><span class="nav-number">6.8.</span> <span class="nav-text">第44条：通过Dispatch Group机制，根据系统资源状况来执行任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第45条：使用dispatch-once来执行只需运行一次的线程安全代码"><span class="nav-number">6.9.</span> <span class="nav-text">第45条：使用dispatch_once来执行只需运行一次的线程安全代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第46条：不要使用dispatch-get-current-queue"><span class="nav-number">6.10.</span> <span class="nav-text">第46条：不要使用dispatch_get_current_queue</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第7章-系统框架"><span class="nav-number">7.</span> <span class="nav-text">第7章 系统框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第47条：熟悉系统框架"><span class="nav-number">7.1.</span> <span class="nav-text">第47条：熟悉系统框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#done-第48条：多用块枚举，少用for循环"><span class="nav-number">7.2.</span> <span class="nav-text">done 第48条：多用块枚举，少用for循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第49条：对自定义其内存管理语义的collection使用无缝桥接"><span class="nav-number">7.3.</span> <span class="nav-text">第49条：对自定义其内存管理语义的collection使用无缝桥接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构"><span class="nav-number">7.3.1.</span> <span class="nav-text">使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桥式转换"><span class="nav-number">7.3.2.</span> <span class="nav-text">桥式转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用无缝桥接修改-Collection-的内存管理语义"><span class="nav-number">7.3.3.</span> <span class="nav-text">使用无缝桥接修改 Collection 的内存管理语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第50条：构建缓存时选用NSCache而非NSDictionary"><span class="nav-number">7.4.</span> <span class="nav-text">第50条：构建缓存时选用NSCache而非NSDictionary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第51条：精简initialize与load的实现代码"><span class="nav-number">7.5.</span> <span class="nav-text">第51条：精简initialize与load的实现代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）"><span class="nav-number">7.5.1.</span> <span class="nav-text">initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第52条：别忘了NSTimer会保留其目标对象"><span class="nav-number">7.6.</span> <span class="nav-text">第52条：别忘了NSTimer会保留其目标对象</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Norcy</span>
</div>

<div class="powered-by">
  感谢 <a class="theme-link" href="http://hexo.io">Hexo</a> 提供主题
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"norcy"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
