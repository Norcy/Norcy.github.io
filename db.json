{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/view.jpg","path":"images/view.jpg","modified":0,"renderable":0},{"_id":"themes/next-reloaded/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/girl.jpg","path":"images/girl.jpg","modified":0,"renderable":0},{"_id":"themes/next-reloaded/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/clicklove.js","path":"js/src/clicklove.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/fancybox/LICENSE","path":"lib/fancybox/LICENSE","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/fancybox/README.md","path":"lib/fancybox/README.md","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/images/girl2.jpg","path":"images/girl2.jpg","modified":0,"renderable":0},{"_id":"themes/next-reloaded/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.min.css","path":"lib/fancybox/source/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.min.js","path":"lib/fancybox/source/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"5c3ab2b145c0249069ef689af5c04c0010800ccf","modified":1541125350000},{"_id":"source/md","hash":"6871400ea896d16e81fc9ffc896c534751175127","modified":1541125351000},{"_id":"themes/next-reloaded/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1543497950919},{"_id":"themes/next-reloaded/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1543497950919},{"_id":"themes/next-reloaded/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1543497950919},{"_id":"themes/next-reloaded/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1543497950919},{"_id":"themes/next-reloaded/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1543497950919},{"_id":"themes/next-reloaded/.gitignore","hash":"d06d635af73e36fdd235a2e7fa6938f078664af8","modified":1543499648142},{"_id":"themes/next-reloaded/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1543497950921},{"_id":"themes/next-reloaded/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1543497950921},{"_id":"themes/next-reloaded/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1543497950921},{"_id":"themes/next-reloaded/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1543497950922},{"_id":"themes/next-reloaded/bower.json","hash":"087eb7b81c0aa77a2b07c2ecf411ceb5ee00386d","modified":1543497950922},{"_id":"themes/next-reloaded/_config.yml","hash":"093259bb6aaf52dd892ee3f06a221aa2479bae03","modified":1543501109590},{"_id":"themes/next-reloaded/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1543497950922},{"_id":"themes/next-reloaded/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1543497950928},{"_id":"themes/next-reloaded/package.json","hash":"cf079447c126a9ad760f1457441f31803ef0470b","modified":1543497950950},{"_id":"source/_posts/2016-01-27-Reading-List.md","hash":"b28872cfb7b37f058e0bf8543fdd8619c4ab3745","modified":1541125350000},{"_id":"source/_posts/ARC MRC 调用未声明方法.md","hash":"7ae840ea8381fa83e6ed534ffb52190d9427c87a","modified":1541125350000},{"_id":"source/_posts/NSTimer 会保留目标对象.md","hash":"0b2170b7fc447c9c78de0eca86d38596e365b04f","modified":1541125350000},{"_id":"source/_posts/Effective-Objective-C-读书笔记.md","hash":"11594bf29556d66ca6ef9c3ab582079ee8ae49a3","modified":1541125350000},{"_id":"source/_posts/NSUserdefaults与NSMutableArray的坑.md","hash":"8ddcf9cb687b0c82a56bf0b9f3fde802b790ad1f","modified":1541125350000},{"_id":"source/_posts/Objective-C中的消息转发机制.md","hash":"d974838dbe9a6c2ce6c51b35fa076833f70b6a9f","modified":1541125350000},{"_id":"source/_posts/UITableView 中，UICollectionView 相互复用之间 contentOffset.md","hash":"b8328c7e4c84ce33ca54b435f3524797086c48fa","modified":1541125350000},{"_id":"source/_posts/iOS技能树.md","hash":"8d62a3bb23f0e5a7af6b479aa7954985fe2b7f86","modified":1541125350000},{"_id":"source/_posts/iOS的单例模式与多线程安全.md","hash":"2053c92edbd96b7e91edc25a50a12f084ee2b5a9","modified":1541125350000},{"_id":"source/_posts/《活着》.md","hash":"b7898104e979dcdbc0cbae5e8636e8922630b41e","modified":1541125350000},{"_id":"source/_posts/关于Objective-C中的BOOL你所要知道的.md","hash":"e26d2bea2ecdea7827d2526863ca9002af2c4d91","modified":1541125351000},{"_id":"source/_posts/同步、异步、阻塞、非阻塞的简单理解.md","hash":"acdb3dc06334a7adc7214644714882cacb5a4730","modified":1541125351000},{"_id":"source/_posts/如何优雅地记录已阅书籍和电影.md","hash":"cc7b53d2325b7199243f3b160eee38ac7286bdf5","modified":1541125351000},{"_id":"source/_posts/如何用iPad在床上优雅的看大片.md","hash":"8e0ebcb218ed0d3bd8ac626d85d024f9e6e91f83","modified":1541125351000},{"_id":"source/_posts/神在细节之中.md","hash":"ea53392153fde66a1d64009111314e199f014460","modified":1541125351000},{"_id":"source/_posts/网易云音乐歌单共享.md","hash":"99444352ae2e99c96ba8403c1acf48e30d68198d","modified":1542079675871},{"_id":"source/_posts/那些年，我看过的.md","hash":"7bf99ba69e2e7be93f9c60b1363d8183b4c07502","modified":1543494626018},{"_id":"source/about/index.md","hash":"351c21ee98ceb27e26a0d3feb59c3be80a6348e4","modified":1541125351000},{"_id":"source/categories/index.md","hash":"e490c8ff8bdc5480c9315508a1e1b28234fd26cf","modified":1541125351000},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1543496241507},{"_id":"source/images/view.jpg","hash":"a7b69856e3d241eec549632515c6e7dc16e378c1","modified":1541125351000},{"_id":"source/tags/index.md","hash":"691cc939ea1b75415995c4beea4e431a71cd92be","modified":1541125351000},{"_id":"themes/next-reloaded/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1543497950920},{"_id":"themes/next-reloaded/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1543497950920},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1543497950920},{"_id":"themes/next-reloaded/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1543497950920},{"_id":"themes/next-reloaded/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1543497950921},{"_id":"themes/next-reloaded/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1543497950921},{"_id":"themes/next-reloaded/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1543497950923},{"_id":"themes/next-reloaded/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1543497950923},{"_id":"themes/next-reloaded/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1543497950923},{"_id":"themes/next-reloaded/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1543497950923},{"_id":"themes/next-reloaded/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1543497950923},{"_id":"themes/next-reloaded/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1543497950924},{"_id":"themes/next-reloaded/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1543497950924},{"_id":"themes/next-reloaded/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1543497950924},{"_id":"themes/next-reloaded/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1543497950925},{"_id":"themes/next-reloaded/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1543497950928},{"_id":"themes/next-reloaded/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1543497950929},{"_id":"themes/next-reloaded/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1543497950929},{"_id":"themes/next-reloaded/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1543497950929},{"_id":"themes/next-reloaded/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1543497950929},{"_id":"themes/next-reloaded/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1543497950930},{"_id":"themes/next-reloaded/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1543497950930},{"_id":"themes/next-reloaded/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1543497950930},{"_id":"themes/next-reloaded/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1543497950930},{"_id":"themes/next-reloaded/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1543497950930},{"_id":"themes/next-reloaded/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1543497950931},{"_id":"themes/next-reloaded/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1543497950931},{"_id":"themes/next-reloaded/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1543497950931},{"_id":"themes/next-reloaded/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1543497950931},{"_id":"themes/next-reloaded/languages/zh-CN.yml","hash":"9b2a71e17416450f38a62c4b51f6e9ab63068527","modified":1543498723508},{"_id":"themes/next-reloaded/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1543497950932},{"_id":"themes/next-reloaded/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1543497950932},{"_id":"themes/next-reloaded/layout/_layout.swig","hash":"91ae04d5dfcb72025ea7ef5a240d3720a186c334","modified":1543500647055},{"_id":"themes/next-reloaded/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1543497950948},{"_id":"themes/next-reloaded/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1543497950948},{"_id":"themes/next-reloaded/layout/index.swig","hash":"ea575c6b9cd31d1239820b02f36365bf94b834eb","modified":1543500147702},{"_id":"themes/next-reloaded/layout/index_backup.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1543497950949},{"_id":"themes/next-reloaded/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1543497950949},{"_id":"themes/next-reloaded/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1543497950949},{"_id":"themes/next-reloaded/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1543497950949},{"_id":"themes/next-reloaded/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1543497950950},{"_id":"themes/next-reloaded/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1543497950951},{"_id":"themes/next-reloaded/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1543497950951},{"_id":"themes/next-reloaded/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1543497950996},{"_id":"themes/next-reloaded/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1543497950996},{"_id":"themes/next-reloaded/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1543497950996},{"_id":"themes/next-reloaded/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543497950979},{"_id":"themes/next-reloaded/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1543497950925},{"_id":"themes/next-reloaded/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1543497950925},{"_id":"themes/next-reloaded/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1543497950925},{"_id":"themes/next-reloaded/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1543497950926},{"_id":"themes/next-reloaded/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1543497950926},{"_id":"themes/next-reloaded/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1543497950926},{"_id":"themes/next-reloaded/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1543497950927},{"_id":"themes/next-reloaded/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1543497950927},{"_id":"themes/next-reloaded/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1543497950927},{"_id":"themes/next-reloaded/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1543497950927},{"_id":"themes/next-reloaded/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1543497950927},{"_id":"themes/next-reloaded/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1543497950928},{"_id":"themes/next-reloaded/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1543497950928},{"_id":"themes/next-reloaded/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1543497950933},{"_id":"themes/next-reloaded/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543497950933},{"_id":"themes/next-reloaded/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543497950933},{"_id":"themes/next-reloaded/layout/_macro/post-collapse.swig","hash":"82f9e238bac68dfe592915631d1ff0cca7b9da95","modified":1543497950934},{"_id":"themes/next-reloaded/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1543497950934},{"_id":"themes/next-reloaded/layout/_macro/post.swig","hash":"225db2f98a9f08b713d24994cf989880618438eb","modified":1543497950935},{"_id":"themes/next-reloaded/layout/_macro/reward.swig","hash":"64d65d9ad0cc94734ac6ded279e2b5dc870a1cab","modified":1543497950935},{"_id":"themes/next-reloaded/layout/_macro/sidebar.swig","hash":"e495523780dbdf6228d933c25bb28bcf4c0952f5","modified":1543497950935},{"_id":"themes/next-reloaded/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1543497950935},{"_id":"themes/next-reloaded/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1543497950936},{"_id":"themes/next-reloaded/layout/_partials/comments.swig","hash":"dce2938bb54c3cef3319f09f2621b93bc41117a0","modified":1543497950936},{"_id":"themes/next-reloaded/layout/_partials/footer.swig","hash":"07f88421bda86d9d5ff32d130b1cb1196b99a326","modified":1543497950936},{"_id":"themes/next-reloaded/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1543497950937},{"_id":"themes/next-reloaded/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1543497950938},{"_id":"themes/next-reloaded/layout/_partials/post-copyright.swig","hash":"2f73cc9ffb63534f0b6d8f0e9ee853c1af1b1244","modified":1543497950938},{"_id":"themes/next-reloaded/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1543497950939},{"_id":"themes/next-reloaded/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1543497950940},{"_id":"themes/next-reloaded/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1543497950940},{"_id":"themes/next-reloaded/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1543497950941},{"_id":"themes/next-reloaded/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1543497950943},{"_id":"themes/next-reloaded/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1543497950945},{"_id":"themes/next-reloaded/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1543497950945},{"_id":"themes/next-reloaded/layout/_third-party/github-banner.swig","hash":"c0f6f02d7d7eb20eb216003c6cfb4ea52060f791","modified":1543497950945},{"_id":"themes/next-reloaded/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1543497950946},{"_id":"themes/next-reloaded/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1543497950946},{"_id":"themes/next-reloaded/layout/_third-party/pdf.swig","hash":"def2736c8c10170712ff36dea220243b0c1858af","modified":1543497950946},{"_id":"themes/next-reloaded/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1543497950946},{"_id":"themes/next-reloaded/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1543497950947},{"_id":"themes/next-reloaded/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1543497950947},{"_id":"themes/next-reloaded/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1543497950950},{"_id":"themes/next-reloaded/scripts/helpers/next-url.js","hash":"15582e823d228c0b2288543c1eb460c40afad29b","modified":1543497950951},{"_id":"themes/next-reloaded/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1543497950951},{"_id":"themes/next-reloaded/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1543497950952},{"_id":"themes/next-reloaded/scripts/tags/exturl.js","hash":"7ded3e7a78380b32de3e12f156e0978ef5c2890a","modified":1543497950952},{"_id":"themes/next-reloaded/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1543497950952},{"_id":"themes/next-reloaded/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1543497950952},{"_id":"themes/next-reloaded/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1543497950952},{"_id":"themes/next-reloaded/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1543497950953},{"_id":"themes/next-reloaded/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1543497950953},{"_id":"themes/next-reloaded/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1543497950953},{"_id":"themes/next-reloaded/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1543497950978},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543497950979},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543497950979},{"_id":"themes/next-reloaded/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543497950979},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543497950980},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543497950980},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543497950980},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543497950981},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543497950981},{"_id":"themes/next-reloaded/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543497950981},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543497950982},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543497950982},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543497950982},{"_id":"themes/next-reloaded/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543497950982},{"_id":"themes/next-reloaded/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543497950983},{"_id":"themes/next-reloaded/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543497950983},{"_id":"themes/next-reloaded/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543497950983},{"_id":"themes/next-reloaded/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543497950983},{"_id":"themes/next-reloaded/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543497950983},{"_id":"themes/next-reloaded/source/lib/.DS_Store","hash":"01b1bd995367fbf3a517a87e09b1c5d8865d49af","modified":1543499680884},{"_id":"source/images/girl.jpg","hash":"195786b13bb6264e22541aec1a437b90c739213f","modified":1541125351000},{"_id":"themes/next-reloaded/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543497950940},{"_id":"themes/next-reloaded/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543497950940},{"_id":"themes/next-reloaded/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543497950971},{"_id":"themes/next-reloaded/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543497950971},{"_id":"themes/next-reloaded/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543497950971},{"_id":"themes/next-reloaded/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543497950978},{"_id":"themes/next-reloaded/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543497950978},{"_id":"themes/next-reloaded/source/images/alipay.jpg","hash":"0b39eece308e3eb1db823be8ee388166c29b6b29","modified":1543495423940},{"_id":"themes/next-reloaded/source/images/wechatpay.jpg","hash":"0b39eece308e3eb1db823be8ee388166c29b6b29","modified":1543495423940},{"_id":"themes/next-reloaded/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1543497950934},{"_id":"themes/next-reloaded/layout/_macro/menu/menu-item.swig","hash":"495fb08875b2e1e04f9c4f3e9e593cdf5c32cc31","modified":1543497950934},{"_id":"themes/next-reloaded/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1543497950936},{"_id":"themes/next-reloaded/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1543497950936},{"_id":"themes/next-reloaded/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1543497950937},{"_id":"themes/next-reloaded/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1543497950937},{"_id":"themes/next-reloaded/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1543497950937},{"_id":"themes/next-reloaded/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1543497950937},{"_id":"themes/next-reloaded/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1543497950937},{"_id":"themes/next-reloaded/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1543497950938},{"_id":"themes/next-reloaded/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1543497950938},{"_id":"themes/next-reloaded/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1543497950938},{"_id":"themes/next-reloaded/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1543497950939},{"_id":"themes/next-reloaded/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1543497950939},{"_id":"themes/next-reloaded/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1543497950939},{"_id":"themes/next-reloaded/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1543497950939},{"_id":"themes/next-reloaded/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1543497950940},{"_id":"themes/next-reloaded/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1543497950940},{"_id":"themes/next-reloaded/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1543497950940},{"_id":"themes/next-reloaded/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1543497950941},{"_id":"themes/next-reloaded/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1543497950941},{"_id":"themes/next-reloaded/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1543497950941},{"_id":"themes/next-reloaded/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1543497950941},{"_id":"themes/next-reloaded/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1543497950941},{"_id":"themes/next-reloaded/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1543497950942},{"_id":"themes/next-reloaded/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1543497950942},{"_id":"themes/next-reloaded/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1543497950942},{"_id":"themes/next-reloaded/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1543497950942},{"_id":"themes/next-reloaded/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1543497950942},{"_id":"themes/next-reloaded/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1543497950942},{"_id":"themes/next-reloaded/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1543497950943},{"_id":"themes/next-reloaded/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1543497950943},{"_id":"themes/next-reloaded/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1543497950943},{"_id":"themes/next-reloaded/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1543497950943},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1543497950944},{"_id":"themes/next-reloaded/layout/_third-party/comments/gitalk.swig","hash":"c4adbde0ef775e475146fbeb2be03568e16a1c73","modified":1543497950944},{"_id":"themes/next-reloaded/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1543497950944},{"_id":"themes/next-reloaded/layout/_third-party/comments/index.swig","hash":"9809d63a4234c5f268ff0b489579149b849728fc","modified":1543497950944},{"_id":"themes/next-reloaded/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1543497950944},{"_id":"themes/next-reloaded/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1543497950945},{"_id":"themes/next-reloaded/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1543497950945},{"_id":"themes/next-reloaded/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1543497950945},{"_id":"themes/next-reloaded/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1543497950946},{"_id":"themes/next-reloaded/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1543497950947},{"_id":"themes/next-reloaded/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1543497950948},{"_id":"themes/next-reloaded/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1543497950948},{"_id":"themes/next-reloaded/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1543497950948},{"_id":"themes/next-reloaded/scripts/filters/after_post_render/exturl.js","hash":"9c9f61b7bfb3349b03b1e61355f20232044b5fd8","modified":1543497950950},{"_id":"themes/next-reloaded/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1543497950970},{"_id":"themes/next-reloaded/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1543497950970},{"_id":"themes/next-reloaded/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1543497950971},{"_id":"themes/next-reloaded/source/css/_mixins/base.styl","hash":"086f5979b3de091c3378512e6c5c2f8fcb4f6298","modified":1543497950971},{"_id":"themes/next-reloaded/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1543497950978},{"_id":"themes/next-reloaded/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1543497950978},{"_id":"themes/next-reloaded/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1543497950978},{"_id":"themes/next-reloaded/source/css/_variables/base.styl","hash":"c6960bf682a4471e82c2abc4537325aeb44fb9e9","modified":1543500463818},{"_id":"themes/next-reloaded/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1543497950984},{"_id":"themes/next-reloaded/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1543497950984},{"_id":"themes/next-reloaded/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1543497950984},{"_id":"themes/next-reloaded/source/js/src/clicklove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1543500674833},{"_id":"themes/next-reloaded/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1543497950985},{"_id":"themes/next-reloaded/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543497950985},{"_id":"themes/next-reloaded/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1543497950985},{"_id":"themes/next-reloaded/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1543497950986},{"_id":"themes/next-reloaded/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1543497950986},{"_id":"themes/next-reloaded/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1543497950986},{"_id":"themes/next-reloaded/source/js/src/utils.js","hash":"28a79d317b7f4012917a54cac770551596bf6241","modified":1543497950987},{"_id":"themes/next-reloaded/source/lib/fancybox/.bower.json","hash":"d8bf9cb15d9d91c7ad022ba2954b5b4d326f17f7","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/fancybox/README.md","hash":"a40db80eb6386b085ff810fd3e302f12e76b8df7","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1543497950987},{"_id":"themes/next-reloaded/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1543497950987},{"_id":"themes/next-reloaded/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1543497950987},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543497950988},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1543497950988},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543497950995},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543497950995},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543497950995},{"_id":"themes/next-reloaded/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543497950992},{"_id":"source/images/girl2.jpg","hash":"5a19566bf07cc23517be384b87f70c93a3a62e98","modified":1541125351000},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1543497950947},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1543497950947},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1543497950953},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1543497950953},{"_id":"themes/next-reloaded/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1543497950954},{"_id":"themes/next-reloaded/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1543497950954},{"_id":"themes/next-reloaded/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1543497950954},{"_id":"themes/next-reloaded/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1543497950958},{"_id":"themes/next-reloaded/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1543497950965},{"_id":"themes/next-reloaded/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1543497950969},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/base.styl","hash":"ec2a62400642bb69edd9259e74e8f1c8ed53c42b","modified":1543497950969},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1543497950969},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1543497950969},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1543497950970},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1543497950970},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1543497950970},{"_id":"themes/next-reloaded/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1543497950972},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1543497950972},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1543497950972},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1543497950972},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_menu.styl","hash":"fe2dc74726a515549956d233becda188da64f948","modified":1543497950973},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1543497950973},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543497950973},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1543497950973},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1543497950974},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1543497950975},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_menu.styl","hash":"936132428a0d35b3947ccedd4c379940abcf223a","modified":1543497950975},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543497950975},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1543497950975},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1543497950976},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1543497950976},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_menu.styl","hash":"74c7dccf0a3ee9fc2ca25ad8e998243191813a0e","modified":1543497950976},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1543497950976},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sidebar.styl","hash":"f26860978fc4e011758945db5d0f79105ac84fae","modified":1543497950977},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1543497950977},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1543497950977},{"_id":"themes/next-reloaded/source/js/src/schemes/pisces.js","hash":"72037e8c4202a73b0c6ff7d81b57cd349e836837","modified":1543497950986},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.min.css","hash":"84adea69673c392c1d34a5a316e8e5960aa348b5","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.min.js","hash":"b85b75426ff7569d54a1f69689895315e80ed85d","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543497950988},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543497950988},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543497950989},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543497950992},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543497950993},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543497950991},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543497950991},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543497950994},{"_id":"themes/next-reloaded/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1543497950954},{"_id":"themes/next-reloaded/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1543497950955},{"_id":"themes/next-reloaded/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1543497950955},{"_id":"themes/next-reloaded/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1543497950955},{"_id":"themes/next-reloaded/source/css/_common/components/header/menu.styl","hash":"05e68adae13f4d99a6ac6493daab39c92e39a6bd","modified":1543497950955},{"_id":"themes/next-reloaded/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1543497950956},{"_id":"themes/next-reloaded/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1543497950956},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1543497950956},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1543497950957},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1543497950957},{"_id":"themes/next-reloaded/source/css/_common/components/pages/archive.styl","hash":"a1eeceea4b88fba184408cb2507bbef1f5e7b0e0","modified":1543497950957},{"_id":"themes/next-reloaded/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1543497950957},{"_id":"themes/next-reloaded/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1543497950958},{"_id":"themes/next-reloaded/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1543497950958},{"_id":"themes/next-reloaded/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1543497950958},{"_id":"themes/next-reloaded/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1543497950958},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1543497950959},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-collapse.styl","hash":"3b5a37ba5e70f92c1ee707c8053524e38adbb710","modified":1543497950959},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1543497950959},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1543497950959},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1543497950959},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1543497950960},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1543497950960},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1543497950960},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1543497950960},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1543497950960},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1543497950961},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1543497950961},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1543497950961},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1543497950961},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1543497950962},{"_id":"themes/next-reloaded/source/css/_common/components/post/post.styl","hash":"3039df53b94b0847b0c451d2d227270b479cc184","modified":1543497950962},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1543497950962},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1543497950963},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"b34bb2ea4d16e47e6fdc06cd4feb32d93ccbd779","modified":1543497950963},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1543497950963},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1543497950963},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1543497950964},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1543497950964},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1543497950964},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1543497950964},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1543497950965},{"_id":"themes/next-reloaded/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1543497950965},{"_id":"themes/next-reloaded/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1543497950965},{"_id":"themes/next-reloaded/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1543497950965},{"_id":"themes/next-reloaded/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1543497950965},{"_id":"themes/next-reloaded/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1543497950966},{"_id":"themes/next-reloaded/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1543497950966},{"_id":"themes/next-reloaded/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1543497950966},{"_id":"themes/next-reloaded/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1543497950966},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1543497950967},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1543497950967},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1543497950967},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1543497950967},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1543497950967},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1543497950968},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1543497950968},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1543497950968},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/third-party.styl","hash":"fcb8d1f2cffaa418b7c471e0238e101ea0025d0e","modified":1543497950968},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1543497950974},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543497950974},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543497950976},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1515183388000},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543497950990},{"_id":"public/about/index.html","hash":"93791a3986d971ddc6d432fe33092c9331179ba8","modified":1543501116148},{"_id":"public/categories/index.html","hash":"a89f25619039a7983c59ac8b219f2e1d91db26da","modified":1543501116148},{"_id":"public/tags/index.html","hash":"dca7049d7f75762fdefb99a4da5f579320b51f84","modified":1543501116148},{"_id":"public/archives/2013/index.html","hash":"1aac866b1fe4796dd51b499af47ecc0308df397f","modified":1543501116149},{"_id":"public/archives/2013/03/index.html","hash":"3c6d4622b70b1ce2192d41dc70e73dae9b751667","modified":1543501116149},{"_id":"public/archives/2016/page/2/index.html","hash":"241831983b2900b809d15a93792ad01abc2e036f","modified":1543501116149},{"_id":"public/archives/2016/01/index.html","hash":"5a58e37c99161b5508cc219e47391b12ee9e7373","modified":1543501116149},{"_id":"public/archives/2016/02/index.html","hash":"48ac3e771e8c21f36c51f492ce44d6802a50b2b6","modified":1543501116149},{"_id":"public/archives/2016/03/index.html","hash":"6a7215431e789d262ddc863f6b588db32fc9131b","modified":1543501116149},{"_id":"public/archives/2016/06/index.html","hash":"43c2306948b2384c893c657b728677dd8d0f871f","modified":1543501116149},{"_id":"public/archives/2016/07/index.html","hash":"2d3d3c764c609ebc8a5e4d55be9fc1211792f357","modified":1543501116149},{"_id":"public/archives/2016/08/index.html","hash":"2cfd34a5570ffc59cf524ab0386b49e9077bdf53","modified":1543501116149},{"_id":"public/archives/2016/09/index.html","hash":"eb8e34d863ac3323c74be919528faac5e328bd2e","modified":1543501116149},{"_id":"public/archives/2017/index.html","hash":"ea3d307bc6455dcf774a2bcdab79bda949c5a3d5","modified":1543501116149},{"_id":"public/archives/2017/04/index.html","hash":"ff083542a56205915228f7d0f4e77516fecf77fb","modified":1543501116149},{"_id":"public/archives/2018/index.html","hash":"5e476aa48976900083cd8ca515bc23291c3e68ce","modified":1543501116149},{"_id":"public/archives/2018/05/index.html","hash":"3da606d3c26dd21f74880da353d9b15a006b1fd7","modified":1543501116149},{"_id":"public/archives/2018/06/index.html","hash":"4079127c408394be5a423f6cd4894f714ef300c7","modified":1543501116149},{"_id":"public/archives/2018/11/index.html","hash":"eac885a2d3d339ce36b88d6b3dd927998336f449","modified":1543501116149},{"_id":"public/categories/Others/index.html","hash":"fed2d9d4102e922dc19b94b348d2c0aea081aacc","modified":1543501116150},{"_id":"public/categories/iOS/index.html","hash":"d7dd723b4f80db6f97b4aae8595a3735acd8d841","modified":1543501116150},{"_id":"public/categories/读书笔记/index.html","hash":"6ea5e409096d60bd0113c1a32639adb41099ff68","modified":1543501116150},{"_id":"public/categories/精神角落/index.html","hash":"9a64acebf8f4223ceec9c9d72e4de293b9cc7446","modified":1543501116150},{"_id":"public/categories/技术改变生活/index.html","hash":"9c2c5f4b79157be5f9144bfeda752ebf816480e7","modified":1543501116150},{"_id":"public/categories/代码之外/index.html","hash":"21a9497381563ba38b550a2249a12abd73192c7b","modified":1543501116150},{"_id":"public/md.html","hash":"fa6b5a4902e6f4748046db7201292c480496403f","modified":1543501116150},{"_id":"public/2018/11/01/网易云音乐歌单共享/index.html","hash":"f28b8fad4ceb5eccdedea7f4f79922a3c5a918db","modified":1543501116150},{"_id":"public/2018/06/09/《活着》/index.html","hash":"6cf23f6c2d2d73cf02bf86ceb187d0bedb9ea06e","modified":1543501116150},{"_id":"public/2018/05/07/如何优雅地记录已阅书籍和电影/index.html","hash":"6d28ef5a0816eae6c9611404495f2227d39793cd","modified":1543501116150},{"_id":"public/2017/04/05/iOS的单例模式与多线程安全/index.html","hash":"cb8ae7aeaed5c1a08bf697ac5fb5a3f4b648ea72","modified":1543501116150},{"_id":"public/2016/09/25/Objective-C中的消息转发机制/index.html","hash":"1169d4b87ef86dd7a6acc1141cb4345b3661fb05","modified":1543501116150},{"_id":"public/2016/08/24/同步、异步、阻塞、非阻塞的简单理解/index.html","hash":"0d206f299269b068053d8da542c149e615e20dc5","modified":1543501116150},{"_id":"public/2016/08/04/如何用iPad在床上优雅的看大片/index.html","hash":"eb8539ad3882083949a793b39f4757605a966440","modified":1543501116150},{"_id":"public/2016/07/25/神在细节之中/index.html","hash":"00a803bc90692d583cf3d2232969b0678c248834","modified":1543501116150},{"_id":"public/2016/06/20/NSTimer 会保留目标对象/index.html","hash":"23aa8962a090abcc9ba21bd36591d0c95cece62f","modified":1543501116151},{"_id":"public/2016/06/15/ARC MRC 调用未声明方法/index.html","hash":"cb94eb0f07da1e29043c26edaf726b0018932470","modified":1543501116151},{"_id":"public/2016/06/12/NSUserdefaults与NSMutableArray的坑/index.html","hash":"9d2e4123d1709e74cdcfa7115e8398c0f72d8a90","modified":1543501116151},{"_id":"public/2016/06/01/关于Objective-C中的BOOL你所要知道的/index.html","hash":"f94ba0bafc8d3a442e615c528aae6873f57f9c8d","modified":1543501116151},{"_id":"public/2016/03/28/UITableView 中，UICollectionView 相互复用之间 contentOffset/index.html","hash":"96425d7d43e23ec5384a901e52ef7e6cfa07d824","modified":1543501116151},{"_id":"public/2016/03/19/Effective-Objective-C-读书笔记/index.html","hash":"b79c6ca55a8695f3dfbd3b9d76fd580a36b8fff9","modified":1543501116151},{"_id":"public/2016/02/18/iOS技能树/index.html","hash":"8b45157e2f34049bd82341396946758df5717994","modified":1543501116151},{"_id":"public/2016/01/27/2016-01-27-Reading-List/index.html","hash":"e21715e5d0c4d279187cc986b30590cae755820d","modified":1543501116151},{"_id":"public/2013/03/01/那些年，我看过的/index.html","hash":"a5a5e815998d1dc09e3af0260a154886ac71a4ef","modified":1543501116151},{"_id":"public/page/2/index.html","hash":"03da969ccc9c6592fdbaf11c1b6c5be1a53e1745","modified":1543501116151},{"_id":"public/index.html","hash":"f0af9c9f51a455cdbb88e75d3e0c8856bc5f3934","modified":1543501116151},{"_id":"public/archives/index.html","hash":"56038d9dfbbf6b6a4bdc4a7c689e8ce0097f5e3b","modified":1543501116151},{"_id":"public/archives/page/2/index.html","hash":"72bd70cc2a91273b5f80a1438addee6625726f25","modified":1543501116151},{"_id":"public/archives/2016/index.html","hash":"a3203f168cd1a9043502de71eee5a6c40c14c0ba","modified":1543501116151},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543501116156},{"_id":"public/images/view.jpg","hash":"a7b69856e3d241eec549632515c6e7dc16e378c1","modified":1543501116156},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543501116156},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543501116156},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543501116156},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543501116156},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543501116156},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543501116157},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543501116157},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543501116157},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543501116157},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543501116157},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543501116157},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543501116157},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543501116157},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543501116157},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543501116157},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543501116157},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543501116157},{"_id":"public/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1543501116157},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543501116157},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543501116157},{"_id":"public/images/alipay.jpg","hash":"0b39eece308e3eb1db823be8ee388166c29b6b29","modified":1543501116512},{"_id":"public/images/wechatpay.jpg","hash":"0b39eece308e3eb1db823be8ee388166c29b6b29","modified":1543501116518},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543501116521},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543501116521},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1543501116525},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1543501116525},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1543501116525},{"_id":"public/js/src/clicklove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1543501116525},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1543501116525},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1543501116525},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543501116525},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1543501116525},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1543501116525},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1543501116525},{"_id":"public/js/src/utils.js","hash":"28a79d317b7f4012917a54cac770551596bf6241","modified":1543501116525},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1543501116525},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543501116525},{"_id":"public/js/src/schemes/pisces.js","hash":"72037e8c4202a73b0c6ff7d81b57cd349e836837","modified":1543501116525},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.css","hash":"84adea69673c392c1d34a5a316e8e5960aa348b5","modified":1543501116525},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543501116525},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543501116525},{"_id":"public/lib/fancybox/README.html","hash":"acfa25ca9b6457a4a70a4b35cf72c9dafc33584e","modified":1543501116525},{"_id":"public/css/main.css","hash":"399bd2054ba476f0578471f8ed08f1d15fc748b1","modified":1543501116525},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543501116526},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543501116526},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543501116526},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1543501116526},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.js","hash":"b85b75426ff7569d54a1f69689895315e80ed85d","modified":1543501116526},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543501116526},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543501116526},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543501116526},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1543501116526},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1543501116526},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543501116526},{"_id":"public/images/girl.jpg","hash":"195786b13bb6264e22541aec1a437b90c739213f","modified":1543501116530},{"_id":"public/images/girl2.jpg","hash":"5a19566bf07cc23517be384b87f70c93a3a62e98","modified":1543501116533}],"Category":[{"name":"Others","_id":"cjp2opl360005u3qww4s8qdnc"},{"name":"iOS","_id":"cjp2opl390009u3qwkftjryt7"},{"name":"读书笔记","_id":"cjp2opl3f000hu3qwcdww9fgv"},{"name":"精神角落","_id":"cjp2opl3j000ru3qw29dgrpz3"},{"name":"技术改变生活","_id":"cjp2opl3k000wu3qw00l3lv2d"},{"name":"代码之外","_id":"cjp2opl3n0017u3qwcdp9pv6m"}],"Data":[],"Page":[{"title":"那些年，我看过的","date":"2013-02-28T16:00:00.000Z","description":"我的书籍/电影/电视剧/动漫列表","categories":["代码之外"],"photos":"images/girl.jpg","_content":"\n# 2018年\n## 01月\n+ 《神秘巨星》\n+ 《无问西东》\n+ 《奇门遁甲》\n\n## 02月\n+ 《唐人街探案2》\n+ 《活着本来单纯》（书）\n\n\n# 2017年\n## 01月\n+ 《鲨滩》\n+ 《三少爷的剑》\n+ 《西游伏妖篇》\n+ 《乘风破浪》\n\n## 02月\n+ 《你的名字》\n\n## 06月\n+ 《非暴力沟通》（书）\n\n## 07月\n+ 《假面饭店》\n+ 《悟空传》\n+ 《小黄人3》\n+ 《嫌疑人x的献身》\n\n## 08月\n+ 《战狼2》\n\n## 09月\n+ 《太空旅客》\n+ 《目击者之追凶》\n+ 《时光倒流的女孩》（书）\n+ 《猩球崛起3》\n\n## 10月\n+ 《看不见的客人》\n+ 《羞羞的铁拳》\n+ 《天才枪手》\n\n## 11月\n+ 《地球脉动2》\n+ 《缝纫机乐队》\n+ 《哈利波特与魔法石》\n\n## 12月\n+ 《少有人走的路》（书）\n+ 《解忧杂货店》\n\n\n# 2016年\n## 01月\n+ 《像素大战》\n+ 《亲爱的》\n+ 《心迷宫》\n+ 《越女剑》（书）\n+ 《枭雄》（连续剧）\n\n## 02月\n+ 《火星救援》\n+ 《扑克王》\n+ 《赌侠大战拉斯维加斯》\n+ 《我的少女时代》\n+ 《国产凌凌漆》\n+ 《美人鱼》\n+ 《时间的朋友2015》（书）\n+ 《荒蛮故事》\n\n## 03月\n+ 《伟大的隐藏者》\n\n## 05月\n+ 《火锅英雄》\n+ 《美国队长3》\n+ 《信号》（连续剧）\n+ 《乒乓侠》\n\n## 06月\n+ 《功夫熊猫3》\n+ 《家和万事兴之我爱我车》\n+ 《明日世界》\n+ 《独立日2》\n+ 《澳门风云3》\n\n## 07月\n+ 《大鱼海棠》\n+ 《六扇门》\n+ 《完美陌生人》\n+ 《代码整洁之道》（书）\n+ 《妮玛的唠嗑馆》（书）\n+ 《安妮和王小明第一季》（书）\n+ 《安妮和王小明第二季》（书）\n+ 《妮玛！这就是大学！》（书）\n\n## 08月\n+ 《一起同过窗》\n+ 《三毛流浪记（漫画）》（书）\n+ 《余罪 第一季》（连续剧）\n\n## 09月\n+ 《龙珠Z：复活的F》\n+ 《叶问3》\n+ 《人间失格》（书）\n+ 《余罪 第二季》（连续剧）\n+ 《招魂2》\n+ 《小白理财第一课》（书）\n+ 《五次方谋杀》（书）\n+ 《绝对小孩》（书）\n+ 《One of Us》（连续剧）\n\n## 10月\n+ 《湄公河行动》\n+ 《选老顶》\n+ 《绝对小孩2》（书）\n+ 《刑警兄弟》\n+ 《七堂极简物理课》（书）\n+ 《嫌疑人X的献身》（书）\n+ 《送你一颗子弹》（书）\n+ 《三观易碎》（书）\n+ 《把时间当做朋友》（书）\n\n## 11月\n+ 《不正常人类症候群》（书）\n+ 《荒岛余生》\n\n\n# 2015年\n## 01月\n+ 《十三度凶间》\n+ 《恐怖直播》\n+ 《鹿鼎记》\n+ 《鹿鼎记2神龙教》\n+ 《名侦探柯南剧场版6 贝克街的亡灵》\n+ 《最佳出价》\n+ 《宿敌》\n+ 《在我入睡前》\n+ 《源代码》\n+ 《牛奶可乐经济学》（书）\n+ 《智取威虎山》\n\n## 02月\n+ 《K-PAX》\n+ 《十万个冷笑话电影》\n+ 《爱情公寓4》（连续剧）\n+ 《天降之物》（连续剧）\n+ 《匆匆那年》\n+ 《无声言证》\n+ 《时空恋旅人》\n+ 《暴走恐怖故事第一季》（连续剧）\n+ 《Premature》\n+ 《地球回音》\n\n## 03月\n+ 《穹顶之下》\n+ 《等一个人咖啡》\n+ 《解忧杂货店》（书）\n+ 《我的互联网方法论》（书）\n+ 《超能陆战队》\n+ 《爆裂鼓手》\n+ 《黑洞频率》\n\n## 04月\n+ 《哆啦A梦：伴我同行》\n\n## 05月\n+ 《生人活祭》\n+ 《伊甸湖》\n\n## 06月\n+ 《侏罗纪世界》\n+ 《侏罗纪公园》\n+ 《名侦探狄仁杰》（连续剧）\n+ 《澳门风云2》\n+ 《左耳》\n+ 《两个月亮》\n+ 《附身》\n+ 《海洋之歌》\n\n## 07月\n+ 《名侦探柯南剧场版 异次元的狙击手》\n+ 《五十度灰》\n+ 《速度与激情7》\n+ 《小森林·夏秋篇》\n+ 《小森林·冬春篇》\n+ 《捉妖记》\n+ 《煎饼侠》\n\n## 08月\n+ 《道士下山》\n+ 《笑傲江湖》（书）\n+ 《笑傲江湖》\n\n## 09月\n+ 《港囧》\n\n## 10月\n+ 《我是路人甲》\n+ 《这个男人来自地球》\n+ 《决战紫禁之巅》\n+ 《Programming with Objective-C》（书）\n+ 《画江湖之不良人》（连续剧）\n\n## 11月\n+ 《夏洛特烦恼》\n+ 《暗时间》（书）\n+ 《荒庙》（书）\n\n## 12月\n+ 《尘曲》（书）\n+ 《移动迷宫》\n+ 《西游记之大圣归来》\n+ 《消失的凶手》\n+ 《真实魔鬼游戏》\n\n\n# 2014年\n## 03月\n+ 《死亡笔记》（连续剧）\n\n## 04月\n+ 《同桌的你》\n+ 《零下一度》\n+ 《逆光飞翔》\n+ 《古墓丽影》\n+ 《古墓丽影2》\n+ 《麦兜响当当》\n\n## 05月\n+ 《麦兜故事》\n+ 《C++程序设计》（书）\n+ 《潘金莲之前世今生》\n+ 《警察故事2013》\n+ 《你是下一个》\n+ 《X战警：逆转未来》\n+ 《百年孤独》（书）\n\n## 06月\n+ 《六福喜事》\n+ 《X战警：第一战》\n+ 《X战警Ⅰ》\n+ 《c++基础教程》（书）\n+ 《杂的文》（书）\n+ 《爆笑角斗士》\n+ 《天才在左，疯子在右》（书）\n+ 《X战警Ⅱ》\n+ 《X战警Ⅲ》\n+ 《金刚狼》\n+ 《金刚狼Ⅱ》\n+ 《生死停留》\n+ 《三重门》（书）\n+ 《警察故事2013》\n\n## 07月\n+ 《澳门风云》\n+ 《无人区》\n+ 《十二生肖》\n+ 《变形金刚4：绝迹重生》\n+ 《进击的巨人》（连续剧）\n+ 《狄仁杰之神都龙王》\n+ 《后会无期》\n+ 《秒速5厘米》\n\n## 08月\n+ 《志明与春娇》\n\n## 09月\n+ 《惊天魔盗团》\n+ 《猩球崛起2》\n+ 《安德的游戏》\n+ 《春娇与志明》\n+ 《分歧者——异类崛起》\n+ 《催眠大师》\n+ 《绣春刀》\n+ 《明日边缘》\n\n## 10月\n+ 《生活启示录》（连续剧）\n+ 《归来》\n+ 《被偷走的那五年》\n+ 《牯岭街少年杀人事件》\n+ 《触不可及》\n+ 《平凡的世界Ⅰ》（书）\n+ 《猎头游戏》\n+ 《黑暗面》\n+ 《控方证人》\n+ 《一级恐惧》\n+ 《飞狐外传》（书）\n+ 《四大名捕大结局》\n+ 《平凡的世界Ⅱ》（书）\n+ 《决战猩球》\n+ 《那夜凌晨 我坐上旺角开往大埔的红van》\n+ 《惊声尖叫》\n+ 《平凡的世界Ⅲ》（书）\n\n## 11月\n+ 《银河护卫队》\n+ 《失踪罪》\n+ 《早晨从中午开始》（书）\n+ 《连城诀》（书）\n+ 《透明人》\n+ 《透明人2》\n+ 《魔女嘉莉》\n+ 《鬼子来了》\n+ 《太阳照常升起》\n+ 《1988——我想和这个世界谈谈》（书）\n+ 《十七岁的单车》\n+ 《一个人的好天气》（书）\n+ 《心花路放》\n+ 《侧耳倾听》\n+ 《林中小屋》\n+ 《彗星来的那一夜》\n+ 《In Your Eyes》\n+ 《The One I Love》\n+ 《哆啦A梦：新·大雄的大魔境》\n+ 《沙僧吐槽日记》（书）\n+ 《大地飞鹰》（书）\n+ 《极速前进》\n+ 《寒战》\n\n## 12月\n+ 《极速前进》\n+ 《关于时间旅行的热门问题》\n+ 《超体》\n+ 《楚留香传奇之血海飘香》（书）\n+ 《麦兜菠萝油王子》\n+ 《星际穿越》\n+ 《月亮》\n+ 《不惧风暴》\n+ 《理科的人Ⅰ》（书）\n+ 《The Giver》\n+ 《楚留香传奇之大沙漠》\n+ 《一步之遥》\n+ 《黄飞鸿之英雄有梦》\n+ 《新大头儿子和小头爸爸之秘密计划》\n+ 《马达加斯加的企鹅》\n+ 《刺杀金正恩》\n+ 《名侦探柯南剧场版1 引爆摩天楼》\n+ 《一个人的武林》\n+ 《弹窗惊魂》\n+ 《楚留香传奇之画眉鸟》（书）\n\n\n","source":"md","raw":"---\ntitle: 那些年，我看过的\ndate: 2013-3-1\ndescription: 我的书籍/电影/电视剧/动漫列表\ncategories:\n- 代码之外 \nphotos: images/girl.jpg\n---\n\n# 2018年\n## 01月\n+ 《神秘巨星》\n+ 《无问西东》\n+ 《奇门遁甲》\n\n## 02月\n+ 《唐人街探案2》\n+ 《活着本来单纯》（书）\n\n\n# 2017年\n## 01月\n+ 《鲨滩》\n+ 《三少爷的剑》\n+ 《西游伏妖篇》\n+ 《乘风破浪》\n\n## 02月\n+ 《你的名字》\n\n## 06月\n+ 《非暴力沟通》（书）\n\n## 07月\n+ 《假面饭店》\n+ 《悟空传》\n+ 《小黄人3》\n+ 《嫌疑人x的献身》\n\n## 08月\n+ 《战狼2》\n\n## 09月\n+ 《太空旅客》\n+ 《目击者之追凶》\n+ 《时光倒流的女孩》（书）\n+ 《猩球崛起3》\n\n## 10月\n+ 《看不见的客人》\n+ 《羞羞的铁拳》\n+ 《天才枪手》\n\n## 11月\n+ 《地球脉动2》\n+ 《缝纫机乐队》\n+ 《哈利波特与魔法石》\n\n## 12月\n+ 《少有人走的路》（书）\n+ 《解忧杂货店》\n\n\n# 2016年\n## 01月\n+ 《像素大战》\n+ 《亲爱的》\n+ 《心迷宫》\n+ 《越女剑》（书）\n+ 《枭雄》（连续剧）\n\n## 02月\n+ 《火星救援》\n+ 《扑克王》\n+ 《赌侠大战拉斯维加斯》\n+ 《我的少女时代》\n+ 《国产凌凌漆》\n+ 《美人鱼》\n+ 《时间的朋友2015》（书）\n+ 《荒蛮故事》\n\n## 03月\n+ 《伟大的隐藏者》\n\n## 05月\n+ 《火锅英雄》\n+ 《美国队长3》\n+ 《信号》（连续剧）\n+ 《乒乓侠》\n\n## 06月\n+ 《功夫熊猫3》\n+ 《家和万事兴之我爱我车》\n+ 《明日世界》\n+ 《独立日2》\n+ 《澳门风云3》\n\n## 07月\n+ 《大鱼海棠》\n+ 《六扇门》\n+ 《完美陌生人》\n+ 《代码整洁之道》（书）\n+ 《妮玛的唠嗑馆》（书）\n+ 《安妮和王小明第一季》（书）\n+ 《安妮和王小明第二季》（书）\n+ 《妮玛！这就是大学！》（书）\n\n## 08月\n+ 《一起同过窗》\n+ 《三毛流浪记（漫画）》（书）\n+ 《余罪 第一季》（连续剧）\n\n## 09月\n+ 《龙珠Z：复活的F》\n+ 《叶问3》\n+ 《人间失格》（书）\n+ 《余罪 第二季》（连续剧）\n+ 《招魂2》\n+ 《小白理财第一课》（书）\n+ 《五次方谋杀》（书）\n+ 《绝对小孩》（书）\n+ 《One of Us》（连续剧）\n\n## 10月\n+ 《湄公河行动》\n+ 《选老顶》\n+ 《绝对小孩2》（书）\n+ 《刑警兄弟》\n+ 《七堂极简物理课》（书）\n+ 《嫌疑人X的献身》（书）\n+ 《送你一颗子弹》（书）\n+ 《三观易碎》（书）\n+ 《把时间当做朋友》（书）\n\n## 11月\n+ 《不正常人类症候群》（书）\n+ 《荒岛余生》\n\n\n# 2015年\n## 01月\n+ 《十三度凶间》\n+ 《恐怖直播》\n+ 《鹿鼎记》\n+ 《鹿鼎记2神龙教》\n+ 《名侦探柯南剧场版6 贝克街的亡灵》\n+ 《最佳出价》\n+ 《宿敌》\n+ 《在我入睡前》\n+ 《源代码》\n+ 《牛奶可乐经济学》（书）\n+ 《智取威虎山》\n\n## 02月\n+ 《K-PAX》\n+ 《十万个冷笑话电影》\n+ 《爱情公寓4》（连续剧）\n+ 《天降之物》（连续剧）\n+ 《匆匆那年》\n+ 《无声言证》\n+ 《时空恋旅人》\n+ 《暴走恐怖故事第一季》（连续剧）\n+ 《Premature》\n+ 《地球回音》\n\n## 03月\n+ 《穹顶之下》\n+ 《等一个人咖啡》\n+ 《解忧杂货店》（书）\n+ 《我的互联网方法论》（书）\n+ 《超能陆战队》\n+ 《爆裂鼓手》\n+ 《黑洞频率》\n\n## 04月\n+ 《哆啦A梦：伴我同行》\n\n## 05月\n+ 《生人活祭》\n+ 《伊甸湖》\n\n## 06月\n+ 《侏罗纪世界》\n+ 《侏罗纪公园》\n+ 《名侦探狄仁杰》（连续剧）\n+ 《澳门风云2》\n+ 《左耳》\n+ 《两个月亮》\n+ 《附身》\n+ 《海洋之歌》\n\n## 07月\n+ 《名侦探柯南剧场版 异次元的狙击手》\n+ 《五十度灰》\n+ 《速度与激情7》\n+ 《小森林·夏秋篇》\n+ 《小森林·冬春篇》\n+ 《捉妖记》\n+ 《煎饼侠》\n\n## 08月\n+ 《道士下山》\n+ 《笑傲江湖》（书）\n+ 《笑傲江湖》\n\n## 09月\n+ 《港囧》\n\n## 10月\n+ 《我是路人甲》\n+ 《这个男人来自地球》\n+ 《决战紫禁之巅》\n+ 《Programming with Objective-C》（书）\n+ 《画江湖之不良人》（连续剧）\n\n## 11月\n+ 《夏洛特烦恼》\n+ 《暗时间》（书）\n+ 《荒庙》（书）\n\n## 12月\n+ 《尘曲》（书）\n+ 《移动迷宫》\n+ 《西游记之大圣归来》\n+ 《消失的凶手》\n+ 《真实魔鬼游戏》\n\n\n# 2014年\n## 03月\n+ 《死亡笔记》（连续剧）\n\n## 04月\n+ 《同桌的你》\n+ 《零下一度》\n+ 《逆光飞翔》\n+ 《古墓丽影》\n+ 《古墓丽影2》\n+ 《麦兜响当当》\n\n## 05月\n+ 《麦兜故事》\n+ 《C++程序设计》（书）\n+ 《潘金莲之前世今生》\n+ 《警察故事2013》\n+ 《你是下一个》\n+ 《X战警：逆转未来》\n+ 《百年孤独》（书）\n\n## 06月\n+ 《六福喜事》\n+ 《X战警：第一战》\n+ 《X战警Ⅰ》\n+ 《c++基础教程》（书）\n+ 《杂的文》（书）\n+ 《爆笑角斗士》\n+ 《天才在左，疯子在右》（书）\n+ 《X战警Ⅱ》\n+ 《X战警Ⅲ》\n+ 《金刚狼》\n+ 《金刚狼Ⅱ》\n+ 《生死停留》\n+ 《三重门》（书）\n+ 《警察故事2013》\n\n## 07月\n+ 《澳门风云》\n+ 《无人区》\n+ 《十二生肖》\n+ 《变形金刚4：绝迹重生》\n+ 《进击的巨人》（连续剧）\n+ 《狄仁杰之神都龙王》\n+ 《后会无期》\n+ 《秒速5厘米》\n\n## 08月\n+ 《志明与春娇》\n\n## 09月\n+ 《惊天魔盗团》\n+ 《猩球崛起2》\n+ 《安德的游戏》\n+ 《春娇与志明》\n+ 《分歧者——异类崛起》\n+ 《催眠大师》\n+ 《绣春刀》\n+ 《明日边缘》\n\n## 10月\n+ 《生活启示录》（连续剧）\n+ 《归来》\n+ 《被偷走的那五年》\n+ 《牯岭街少年杀人事件》\n+ 《触不可及》\n+ 《平凡的世界Ⅰ》（书）\n+ 《猎头游戏》\n+ 《黑暗面》\n+ 《控方证人》\n+ 《一级恐惧》\n+ 《飞狐外传》（书）\n+ 《四大名捕大结局》\n+ 《平凡的世界Ⅱ》（书）\n+ 《决战猩球》\n+ 《那夜凌晨 我坐上旺角开往大埔的红van》\n+ 《惊声尖叫》\n+ 《平凡的世界Ⅲ》（书）\n\n## 11月\n+ 《银河护卫队》\n+ 《失踪罪》\n+ 《早晨从中午开始》（书）\n+ 《连城诀》（书）\n+ 《透明人》\n+ 《透明人2》\n+ 《魔女嘉莉》\n+ 《鬼子来了》\n+ 《太阳照常升起》\n+ 《1988——我想和这个世界谈谈》（书）\n+ 《十七岁的单车》\n+ 《一个人的好天气》（书）\n+ 《心花路放》\n+ 《侧耳倾听》\n+ 《林中小屋》\n+ 《彗星来的那一夜》\n+ 《In Your Eyes》\n+ 《The One I Love》\n+ 《哆啦A梦：新·大雄的大魔境》\n+ 《沙僧吐槽日记》（书）\n+ 《大地飞鹰》（书）\n+ 《极速前进》\n+ 《寒战》\n\n## 12月\n+ 《极速前进》\n+ 《关于时间旅行的热门问题》\n+ 《超体》\n+ 《楚留香传奇之血海飘香》（书）\n+ 《麦兜菠萝油王子》\n+ 《星际穿越》\n+ 《月亮》\n+ 《不惧风暴》\n+ 《理科的人Ⅰ》（书）\n+ 《The Giver》\n+ 《楚留香传奇之大沙漠》\n+ 《一步之遥》\n+ 《黄飞鸿之英雄有梦》\n+ 《新大头儿子和小头爸爸之秘密计划》\n+ 《马达加斯加的企鹅》\n+ 《刺杀金正恩》\n+ 《名侦探柯南剧场版1 引爆摩天楼》\n+ 《一个人的武林》\n+ 《弹窗惊魂》\n+ 《楚留香传奇之画眉鸟》（书）\n\n\n","updated":"2018-11-02T02:22:31.000Z","path":"md.html","comments":1,"layout":"page","_id":"cjp2opl2b0000u3qwduy0c43o","content":"\n# 2018年\n## 01月\n+ 《神秘巨星》\n+ 《无问西东》\n+ 《奇门遁甲》\n\n## 02月\n+ 《唐人街探案2》\n+ 《活着本来单纯》（书）\n\n\n# 2017年\n## 01月\n+ 《鲨滩》\n+ 《三少爷的剑》\n+ 《西游伏妖篇》\n+ 《乘风破浪》\n\n## 02月\n+ 《你的名字》\n\n## 06月\n+ 《非暴力沟通》（书）\n\n## 07月\n+ 《假面饭店》\n+ 《悟空传》\n+ 《小黄人3》\n+ 《嫌疑人x的献身》\n\n## 08月\n+ 《战狼2》\n\n## 09月\n+ 《太空旅客》\n+ 《目击者之追凶》\n+ 《时光倒流的女孩》（书）\n+ 《猩球崛起3》\n\n## 10月\n+ 《看不见的客人》\n+ 《羞羞的铁拳》\n+ 《天才枪手》\n\n## 11月\n+ 《地球脉动2》\n+ 《缝纫机乐队》\n+ 《哈利波特与魔法石》\n\n## 12月\n+ 《少有人走的路》（书）\n+ 《解忧杂货店》\n\n\n# 2016年\n## 01月\n+ 《像素大战》\n+ 《亲爱的》\n+ 《心迷宫》\n+ 《越女剑》（书）\n+ 《枭雄》（连续剧）\n\n## 02月\n+ 《火星救援》\n+ 《扑克王》\n+ 《赌侠大战拉斯维加斯》\n+ 《我的少女时代》\n+ 《国产凌凌漆》\n+ 《美人鱼》\n+ 《时间的朋友2015》（书）\n+ 《荒蛮故事》\n\n## 03月\n+ 《伟大的隐藏者》\n\n## 05月\n+ 《火锅英雄》\n+ 《美国队长3》\n+ 《信号》（连续剧）\n+ 《乒乓侠》\n\n## 06月\n+ 《功夫熊猫3》\n+ 《家和万事兴之我爱我车》\n+ 《明日世界》\n+ 《独立日2》\n+ 《澳门风云3》\n\n## 07月\n+ 《大鱼海棠》\n+ 《六扇门》\n+ 《完美陌生人》\n+ 《代码整洁之道》（书）\n+ 《妮玛的唠嗑馆》（书）\n+ 《安妮和王小明第一季》（书）\n+ 《安妮和王小明第二季》（书）\n+ 《妮玛！这就是大学！》（书）\n\n## 08月\n+ 《一起同过窗》\n+ 《三毛流浪记（漫画）》（书）\n+ 《余罪 第一季》（连续剧）\n\n## 09月\n+ 《龙珠Z：复活的F》\n+ 《叶问3》\n+ 《人间失格》（书）\n+ 《余罪 第二季》（连续剧）\n+ 《招魂2》\n+ 《小白理财第一课》（书）\n+ 《五次方谋杀》（书）\n+ 《绝对小孩》（书）\n+ 《One of Us》（连续剧）\n\n## 10月\n+ 《湄公河行动》\n+ 《选老顶》\n+ 《绝对小孩2》（书）\n+ 《刑警兄弟》\n+ 《七堂极简物理课》（书）\n+ 《嫌疑人X的献身》（书）\n+ 《送你一颗子弹》（书）\n+ 《三观易碎》（书）\n+ 《把时间当做朋友》（书）\n\n## 11月\n+ 《不正常人类症候群》（书）\n+ 《荒岛余生》\n\n\n# 2015年\n## 01月\n+ 《十三度凶间》\n+ 《恐怖直播》\n+ 《鹿鼎记》\n+ 《鹿鼎记2神龙教》\n+ 《名侦探柯南剧场版6 贝克街的亡灵》\n+ 《最佳出价》\n+ 《宿敌》\n+ 《在我入睡前》\n+ 《源代码》\n+ 《牛奶可乐经济学》（书）\n+ 《智取威虎山》\n\n## 02月\n+ 《K-PAX》\n+ 《十万个冷笑话电影》\n+ 《爱情公寓4》（连续剧）\n+ 《天降之物》（连续剧）\n+ 《匆匆那年》\n+ 《无声言证》\n+ 《时空恋旅人》\n+ 《暴走恐怖故事第一季》（连续剧）\n+ 《Premature》\n+ 《地球回音》\n\n## 03月\n+ 《穹顶之下》\n+ 《等一个人咖啡》\n+ 《解忧杂货店》（书）\n+ 《我的互联网方法论》（书）\n+ 《超能陆战队》\n+ 《爆裂鼓手》\n+ 《黑洞频率》\n\n## 04月\n+ 《哆啦A梦：伴我同行》\n\n## 05月\n+ 《生人活祭》\n+ 《伊甸湖》\n\n## 06月\n+ 《侏罗纪世界》\n+ 《侏罗纪公园》\n+ 《名侦探狄仁杰》（连续剧）\n+ 《澳门风云2》\n+ 《左耳》\n+ 《两个月亮》\n+ 《附身》\n+ 《海洋之歌》\n\n## 07月\n+ 《名侦探柯南剧场版 异次元的狙击手》\n+ 《五十度灰》\n+ 《速度与激情7》\n+ 《小森林·夏秋篇》\n+ 《小森林·冬春篇》\n+ 《捉妖记》\n+ 《煎饼侠》\n\n## 08月\n+ 《道士下山》\n+ 《笑傲江湖》（书）\n+ 《笑傲江湖》\n\n## 09月\n+ 《港囧》\n\n## 10月\n+ 《我是路人甲》\n+ 《这个男人来自地球》\n+ 《决战紫禁之巅》\n+ 《Programming with Objective-C》（书）\n+ 《画江湖之不良人》（连续剧）\n\n## 11月\n+ 《夏洛特烦恼》\n+ 《暗时间》（书）\n+ 《荒庙》（书）\n\n## 12月\n+ 《尘曲》（书）\n+ 《移动迷宫》\n+ 《西游记之大圣归来》\n+ 《消失的凶手》\n+ 《真实魔鬼游戏》\n\n\n# 2014年\n## 03月\n+ 《死亡笔记》（连续剧）\n\n## 04月\n+ 《同桌的你》\n+ 《零下一度》\n+ 《逆光飞翔》\n+ 《古墓丽影》\n+ 《古墓丽影2》\n+ 《麦兜响当当》\n\n## 05月\n+ 《麦兜故事》\n+ 《C++程序设计》（书）\n+ 《潘金莲之前世今生》\n+ 《警察故事2013》\n+ 《你是下一个》\n+ 《X战警：逆转未来》\n+ 《百年孤独》（书）\n\n## 06月\n+ 《六福喜事》\n+ 《X战警：第一战》\n+ 《X战警Ⅰ》\n+ 《c++基础教程》（书）\n+ 《杂的文》（书）\n+ 《爆笑角斗士》\n+ 《天才在左，疯子在右》（书）\n+ 《X战警Ⅱ》\n+ 《X战警Ⅲ》\n+ 《金刚狼》\n+ 《金刚狼Ⅱ》\n+ 《生死停留》\n+ 《三重门》（书）\n+ 《警察故事2013》\n\n## 07月\n+ 《澳门风云》\n+ 《无人区》\n+ 《十二生肖》\n+ 《变形金刚4：绝迹重生》\n+ 《进击的巨人》（连续剧）\n+ 《狄仁杰之神都龙王》\n+ 《后会无期》\n+ 《秒速5厘米》\n\n## 08月\n+ 《志明与春娇》\n\n## 09月\n+ 《惊天魔盗团》\n+ 《猩球崛起2》\n+ 《安德的游戏》\n+ 《春娇与志明》\n+ 《分歧者——异类崛起》\n+ 《催眠大师》\n+ 《绣春刀》\n+ 《明日边缘》\n\n## 10月\n+ 《生活启示录》（连续剧）\n+ 《归来》\n+ 《被偷走的那五年》\n+ 《牯岭街少年杀人事件》\n+ 《触不可及》\n+ 《平凡的世界Ⅰ》（书）\n+ 《猎头游戏》\n+ 《黑暗面》\n+ 《控方证人》\n+ 《一级恐惧》\n+ 《飞狐外传》（书）\n+ 《四大名捕大结局》\n+ 《平凡的世界Ⅱ》（书）\n+ 《决战猩球》\n+ 《那夜凌晨 我坐上旺角开往大埔的红van》\n+ 《惊声尖叫》\n+ 《平凡的世界Ⅲ》（书）\n\n## 11月\n+ 《银河护卫队》\n+ 《失踪罪》\n+ 《早晨从中午开始》（书）\n+ 《连城诀》（书）\n+ 《透明人》\n+ 《透明人2》\n+ 《魔女嘉莉》\n+ 《鬼子来了》\n+ 《太阳照常升起》\n+ 《1988——我想和这个世界谈谈》（书）\n+ 《十七岁的单车》\n+ 《一个人的好天气》（书）\n+ 《心花路放》\n+ 《侧耳倾听》\n+ 《林中小屋》\n+ 《彗星来的那一夜》\n+ 《In Your Eyes》\n+ 《The One I Love》\n+ 《哆啦A梦：新·大雄的大魔境》\n+ 《沙僧吐槽日记》（书）\n+ 《大地飞鹰》（书）\n+ 《极速前进》\n+ 《寒战》\n\n## 12月\n+ 《极速前进》\n+ 《关于时间旅行的热门问题》\n+ 《超体》\n+ 《楚留香传奇之血海飘香》（书）\n+ 《麦兜菠萝油王子》\n+ 《星际穿越》\n+ 《月亮》\n+ 《不惧风暴》\n+ 《理科的人Ⅰ》（书）\n+ 《The Giver》\n+ 《楚留香传奇之大沙漠》\n+ 《一步之遥》\n+ 《黄飞鸿之英雄有梦》\n+ 《新大头儿子和小头爸爸之秘密计划》\n+ 《马达加斯加的企鹅》\n+ 《刺杀金正恩》\n+ 《名侦探柯南剧场版1 引爆摩天楼》\n+ 《一个人的武林》\n+ 《弹窗惊魂》\n+ 《楚留香传奇之画眉鸟》（书）\n\n\n","site":{"data":{}},"excerpt":"","more":"\n# 2018年\n## 01月\n+ 《神秘巨星》\n+ 《无问西东》\n+ 《奇门遁甲》\n\n## 02月\n+ 《唐人街探案2》\n+ 《活着本来单纯》（书）\n\n\n# 2017年\n## 01月\n+ 《鲨滩》\n+ 《三少爷的剑》\n+ 《西游伏妖篇》\n+ 《乘风破浪》\n\n## 02月\n+ 《你的名字》\n\n## 06月\n+ 《非暴力沟通》（书）\n\n## 07月\n+ 《假面饭店》\n+ 《悟空传》\n+ 《小黄人3》\n+ 《嫌疑人x的献身》\n\n## 08月\n+ 《战狼2》\n\n## 09月\n+ 《太空旅客》\n+ 《目击者之追凶》\n+ 《时光倒流的女孩》（书）\n+ 《猩球崛起3》\n\n## 10月\n+ 《看不见的客人》\n+ 《羞羞的铁拳》\n+ 《天才枪手》\n\n## 11月\n+ 《地球脉动2》\n+ 《缝纫机乐队》\n+ 《哈利波特与魔法石》\n\n## 12月\n+ 《少有人走的路》（书）\n+ 《解忧杂货店》\n\n\n# 2016年\n## 01月\n+ 《像素大战》\n+ 《亲爱的》\n+ 《心迷宫》\n+ 《越女剑》（书）\n+ 《枭雄》（连续剧）\n\n## 02月\n+ 《火星救援》\n+ 《扑克王》\n+ 《赌侠大战拉斯维加斯》\n+ 《我的少女时代》\n+ 《国产凌凌漆》\n+ 《美人鱼》\n+ 《时间的朋友2015》（书）\n+ 《荒蛮故事》\n\n## 03月\n+ 《伟大的隐藏者》\n\n## 05月\n+ 《火锅英雄》\n+ 《美国队长3》\n+ 《信号》（连续剧）\n+ 《乒乓侠》\n\n## 06月\n+ 《功夫熊猫3》\n+ 《家和万事兴之我爱我车》\n+ 《明日世界》\n+ 《独立日2》\n+ 《澳门风云3》\n\n## 07月\n+ 《大鱼海棠》\n+ 《六扇门》\n+ 《完美陌生人》\n+ 《代码整洁之道》（书）\n+ 《妮玛的唠嗑馆》（书）\n+ 《安妮和王小明第一季》（书）\n+ 《安妮和王小明第二季》（书）\n+ 《妮玛！这就是大学！》（书）\n\n## 08月\n+ 《一起同过窗》\n+ 《三毛流浪记（漫画）》（书）\n+ 《余罪 第一季》（连续剧）\n\n## 09月\n+ 《龙珠Z：复活的F》\n+ 《叶问3》\n+ 《人间失格》（书）\n+ 《余罪 第二季》（连续剧）\n+ 《招魂2》\n+ 《小白理财第一课》（书）\n+ 《五次方谋杀》（书）\n+ 《绝对小孩》（书）\n+ 《One of Us》（连续剧）\n\n## 10月\n+ 《湄公河行动》\n+ 《选老顶》\n+ 《绝对小孩2》（书）\n+ 《刑警兄弟》\n+ 《七堂极简物理课》（书）\n+ 《嫌疑人X的献身》（书）\n+ 《送你一颗子弹》（书）\n+ 《三观易碎》（书）\n+ 《把时间当做朋友》（书）\n\n## 11月\n+ 《不正常人类症候群》（书）\n+ 《荒岛余生》\n\n\n# 2015年\n## 01月\n+ 《十三度凶间》\n+ 《恐怖直播》\n+ 《鹿鼎记》\n+ 《鹿鼎记2神龙教》\n+ 《名侦探柯南剧场版6 贝克街的亡灵》\n+ 《最佳出价》\n+ 《宿敌》\n+ 《在我入睡前》\n+ 《源代码》\n+ 《牛奶可乐经济学》（书）\n+ 《智取威虎山》\n\n## 02月\n+ 《K-PAX》\n+ 《十万个冷笑话电影》\n+ 《爱情公寓4》（连续剧）\n+ 《天降之物》（连续剧）\n+ 《匆匆那年》\n+ 《无声言证》\n+ 《时空恋旅人》\n+ 《暴走恐怖故事第一季》（连续剧）\n+ 《Premature》\n+ 《地球回音》\n\n## 03月\n+ 《穹顶之下》\n+ 《等一个人咖啡》\n+ 《解忧杂货店》（书）\n+ 《我的互联网方法论》（书）\n+ 《超能陆战队》\n+ 《爆裂鼓手》\n+ 《黑洞频率》\n\n## 04月\n+ 《哆啦A梦：伴我同行》\n\n## 05月\n+ 《生人活祭》\n+ 《伊甸湖》\n\n## 06月\n+ 《侏罗纪世界》\n+ 《侏罗纪公园》\n+ 《名侦探狄仁杰》（连续剧）\n+ 《澳门风云2》\n+ 《左耳》\n+ 《两个月亮》\n+ 《附身》\n+ 《海洋之歌》\n\n## 07月\n+ 《名侦探柯南剧场版 异次元的狙击手》\n+ 《五十度灰》\n+ 《速度与激情7》\n+ 《小森林·夏秋篇》\n+ 《小森林·冬春篇》\n+ 《捉妖记》\n+ 《煎饼侠》\n\n## 08月\n+ 《道士下山》\n+ 《笑傲江湖》（书）\n+ 《笑傲江湖》\n\n## 09月\n+ 《港囧》\n\n## 10月\n+ 《我是路人甲》\n+ 《这个男人来自地球》\n+ 《决战紫禁之巅》\n+ 《Programming with Objective-C》（书）\n+ 《画江湖之不良人》（连续剧）\n\n## 11月\n+ 《夏洛特烦恼》\n+ 《暗时间》（书）\n+ 《荒庙》（书）\n\n## 12月\n+ 《尘曲》（书）\n+ 《移动迷宫》\n+ 《西游记之大圣归来》\n+ 《消失的凶手》\n+ 《真实魔鬼游戏》\n\n\n# 2014年\n## 03月\n+ 《死亡笔记》（连续剧）\n\n## 04月\n+ 《同桌的你》\n+ 《零下一度》\n+ 《逆光飞翔》\n+ 《古墓丽影》\n+ 《古墓丽影2》\n+ 《麦兜响当当》\n\n## 05月\n+ 《麦兜故事》\n+ 《C++程序设计》（书）\n+ 《潘金莲之前世今生》\n+ 《警察故事2013》\n+ 《你是下一个》\n+ 《X战警：逆转未来》\n+ 《百年孤独》（书）\n\n## 06月\n+ 《六福喜事》\n+ 《X战警：第一战》\n+ 《X战警Ⅰ》\n+ 《c++基础教程》（书）\n+ 《杂的文》（书）\n+ 《爆笑角斗士》\n+ 《天才在左，疯子在右》（书）\n+ 《X战警Ⅱ》\n+ 《X战警Ⅲ》\n+ 《金刚狼》\n+ 《金刚狼Ⅱ》\n+ 《生死停留》\n+ 《三重门》（书）\n+ 《警察故事2013》\n\n## 07月\n+ 《澳门风云》\n+ 《无人区》\n+ 《十二生肖》\n+ 《变形金刚4：绝迹重生》\n+ 《进击的巨人》（连续剧）\n+ 《狄仁杰之神都龙王》\n+ 《后会无期》\n+ 《秒速5厘米》\n\n## 08月\n+ 《志明与春娇》\n\n## 09月\n+ 《惊天魔盗团》\n+ 《猩球崛起2》\n+ 《安德的游戏》\n+ 《春娇与志明》\n+ 《分歧者——异类崛起》\n+ 《催眠大师》\n+ 《绣春刀》\n+ 《明日边缘》\n\n## 10月\n+ 《生活启示录》（连续剧）\n+ 《归来》\n+ 《被偷走的那五年》\n+ 《牯岭街少年杀人事件》\n+ 《触不可及》\n+ 《平凡的世界Ⅰ》（书）\n+ 《猎头游戏》\n+ 《黑暗面》\n+ 《控方证人》\n+ 《一级恐惧》\n+ 《飞狐外传》（书）\n+ 《四大名捕大结局》\n+ 《平凡的世界Ⅱ》（书）\n+ 《决战猩球》\n+ 《那夜凌晨 我坐上旺角开往大埔的红van》\n+ 《惊声尖叫》\n+ 《平凡的世界Ⅲ》（书）\n\n## 11月\n+ 《银河护卫队》\n+ 《失踪罪》\n+ 《早晨从中午开始》（书）\n+ 《连城诀》（书）\n+ 《透明人》\n+ 《透明人2》\n+ 《魔女嘉莉》\n+ 《鬼子来了》\n+ 《太阳照常升起》\n+ 《1988——我想和这个世界谈谈》（书）\n+ 《十七岁的单车》\n+ 《一个人的好天气》（书）\n+ 《心花路放》\n+ 《侧耳倾听》\n+ 《林中小屋》\n+ 《彗星来的那一夜》\n+ 《In Your Eyes》\n+ 《The One I Love》\n+ 《哆啦A梦：新·大雄的大魔境》\n+ 《沙僧吐槽日记》（书）\n+ 《大地飞鹰》（书）\n+ 《极速前进》\n+ 《寒战》\n\n## 12月\n+ 《极速前进》\n+ 《关于时间旅行的热门问题》\n+ 《超体》\n+ 《楚留香传奇之血海飘香》（书）\n+ 《麦兜菠萝油王子》\n+ 《星际穿越》\n+ 《月亮》\n+ 《不惧风暴》\n+ 《理科的人Ⅰ》（书）\n+ 《The Giver》\n+ 《楚留香传奇之大沙漠》\n+ 《一步之遥》\n+ 《黄飞鸿之英雄有梦》\n+ 《新大头儿子和小头爸爸之秘密计划》\n+ 《马达加斯加的企鹅》\n+ 《刺杀金正恩》\n+ 《名侦探柯南剧场版1 引爆摩天楼》\n+ 《一个人的武林》\n+ 《弹窗惊魂》\n+ 《楚留香传奇之画眉鸟》（书）\n\n\n"},{"title":"about","date":"2016-02-18T13:54:09.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-02-18 21:54:09\ntype: about\n---\n","updated":"2018-11-02T02:22:31.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjp2opl330002u3qweg7oy9h6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-02-18T13:21:40.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-02-18 21:21:40\ntype: categories\n---\n","updated":"2018-11-02T02:22:31.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjp2opl350004u3qw1h6v7qa0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-02-18T13:20:07.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-02-18 21:20:07\ntype: tags\n---\n","updated":"2018-11-02T02:22:31.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjp2opl87001bu3qws3pde4pw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"iOS Reading List","description":"未整理的知识列表","date":"2016-01-26T16:00:00.000Z","photos":[],"keywords":null,"_content":"\n# 2016-01\n+ ## [iOS 开发博客列表](https://github.com/tangqiaoboy/iOSBlogCN)\n\n# 2016-02\n+ ## frame 和 bounds 区别\n\n\t1. [设置父 View 的 bounds 的原点，本质是将父 View 的左上角顶点改为 bounds 的原点值](http://blog.csdn.net/mad1989/article/details/8711697)\n\t2. 快速输出 frame 和 bounds：NSStringFromCGRect(view.frame)\n\t3. [bounds 比其 frame 大或小的影响](http://www.cocoachina.com/ios/20140925/9755.html)\n\t4. [横屏之后，播放器 Controller 的 view 的 frame 的 size 为(320,480)，而 bounds 的 size 为(480,320)](http://stackoverflow.com/questions/17036225/why-self-view-frame-and-self-view-bounds-are-different-w`hen-the-devices-rotate)，这是因为横屏对播放器 Controller 的 view 应用了 transform，应用了 transform 之后 frame 不变，但是 bounds 会改变\n\t\n\t\tIn addition the frame property’s values are undefined if the view has any transform other than the identity transform. Rotating a view into landscape mode applies a transform to the view so it is not safe to rely on frame values for an app in landscape mode.\n\t\n\t\t摘自 [UIView Frames and Bounds](http://blog.carbonfive.com/2010/05/27/uiview-frames-and-bounds/)\n\n+ ## [如何成为一名入门级 iOS 开发者](http://www.jianshu.com/p/958c1c52db6c)\n\n+ ## 调试过程使用\"thread return\"or \"thread return YES\"来 return 函数\n\n+ ## [SVN 合并分支](https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-dug-merge.html)\n\n# 2016-03\n+ ## 调试技巧之条件断点(BOOL)[str isEqualToString:@\"ABC\"]","source":"_posts/2016-01-27-Reading-List.md","raw":"---\ntitle: iOS Reading List\ndescription: 未整理的知识列表\ndate: 2016-1-27\ncategories:\n- Others\nphotos: \nkeywords:\n---\n\n# 2016-01\n+ ## [iOS 开发博客列表](https://github.com/tangqiaoboy/iOSBlogCN)\n\n# 2016-02\n+ ## frame 和 bounds 区别\n\n\t1. [设置父 View 的 bounds 的原点，本质是将父 View 的左上角顶点改为 bounds 的原点值](http://blog.csdn.net/mad1989/article/details/8711697)\n\t2. 快速输出 frame 和 bounds：NSStringFromCGRect(view.frame)\n\t3. [bounds 比其 frame 大或小的影响](http://www.cocoachina.com/ios/20140925/9755.html)\n\t4. [横屏之后，播放器 Controller 的 view 的 frame 的 size 为(320,480)，而 bounds 的 size 为(480,320)](http://stackoverflow.com/questions/17036225/why-self-view-frame-and-self-view-bounds-are-different-w`hen-the-devices-rotate)，这是因为横屏对播放器 Controller 的 view 应用了 transform，应用了 transform 之后 frame 不变，但是 bounds 会改变\n\t\n\t\tIn addition the frame property’s values are undefined if the view has any transform other than the identity transform. Rotating a view into landscape mode applies a transform to the view so it is not safe to rely on frame values for an app in landscape mode.\n\t\n\t\t摘自 [UIView Frames and Bounds](http://blog.carbonfive.com/2010/05/27/uiview-frames-and-bounds/)\n\n+ ## [如何成为一名入门级 iOS 开发者](http://www.jianshu.com/p/958c1c52db6c)\n\n+ ## 调试过程使用\"thread return\"or \"thread return YES\"来 return 函数\n\n+ ## [SVN 合并分支](https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-dug-merge.html)\n\n# 2016-03\n+ ## 调试技巧之条件断点(BOOL)[str isEqualToString:@\"ABC\"]","slug":"2016-01-27-Reading-List","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","link":"","_id":"cjp2opl310001u3qw8u3lr9dl","content":"<h1 id=\"2016-01\"><a href=\"#2016-01\" class=\"headerlink\" title=\"2016-01\"></a>2016-01</h1><ul>\n<li><h2 id=\"iOS-开发博客列表\"><a href=\"#iOS-开发博客列表\" class=\"headerlink\" title=\"iOS 开发博客列表\"></a><a href=\"https://github.com/tangqiaoboy/iOSBlogCN\" target=\"_blank\" rel=\"noopener\">iOS 开发博客列表</a></h2></li>\n</ul>\n<h1 id=\"2016-02\"><a href=\"#2016-02\" class=\"headerlink\" title=\"2016-02\"></a>2016-02</h1><ul>\n<li><h2 id=\"frame-和-bounds-区别\"><a href=\"#frame-和-bounds-区别\" class=\"headerlink\" title=\"frame 和 bounds 区别\"></a>frame 和 bounds 区别</h2><ol>\n<li><a href=\"http://blog.csdn.net/mad1989/article/details/8711697\" target=\"_blank\" rel=\"noopener\">设置父 View 的 bounds 的原点，本质是将父 View 的左上角顶点改为 bounds 的原点值</a></li>\n<li>快速输出 frame 和 bounds：NSStringFromCGRect(view.frame)</li>\n<li><a href=\"http://www.cocoachina.com/ios/20140925/9755.html\" target=\"_blank\" rel=\"noopener\">bounds 比其 frame 大或小的影响</a></li>\n<li><p><a href=\"http://stackoverflow.com/questions/17036225/why-self-view-frame-and-self-view-bounds-are-different-w`hen-the-devices-rotate\" target=\"_blank\" rel=\"noopener\">横屏之后，播放器 Controller 的 view 的 frame 的 size 为(320,480)，而 bounds 的 size 为(480,320)</a>，这是因为横屏对播放器 Controller 的 view 应用了 transform，应用了 transform 之后 frame 不变，但是 bounds 会改变</p>\n<p> In addition the frame property’s values are undefined if the view has any transform other than the identity transform. Rotating a view into landscape mode applies a transform to the view so it is not safe to rely on frame values for an app in landscape mode.</p>\n<p> 摘自 <a href=\"http://blog.carbonfive.com/2010/05/27/uiview-frames-and-bounds/\" target=\"_blank\" rel=\"noopener\">UIView Frames and Bounds</a></p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"如何成为一名入门级-iOS-开发者\"><a href=\"#如何成为一名入门级-iOS-开发者\" class=\"headerlink\" title=\"如何成为一名入门级 iOS 开发者\"></a><a href=\"http://www.jianshu.com/p/958c1c52db6c\" target=\"_blank\" rel=\"noopener\">如何成为一名入门级 iOS 开发者</a></h2></li>\n<li><h2 id=\"调试过程使用”thread-return”or-“thread-return-YES”来-return-函数\"><a href=\"#调试过程使用”thread-return”or-“thread-return-YES”来-return-函数\" class=\"headerlink\" title=\"调试过程使用”thread return”or “thread return YES”来 return 函数\"></a>调试过程使用”thread return”or “thread return YES”来 return 函数</h2></li>\n<li><h2 id=\"SVN-合并分支\"><a href=\"#SVN-合并分支\" class=\"headerlink\" title=\"SVN 合并分支\"></a><a href=\"https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-dug-merge.html\" target=\"_blank\" rel=\"noopener\">SVN 合并分支</a></h2></li>\n</ul>\n<h1 id=\"2016-03\"><a href=\"#2016-03\" class=\"headerlink\" title=\"2016-03\"></a>2016-03</h1><ul>\n<li><h2 id=\"调试技巧之条件断点-BOOL-str-isEqualToString-”ABC”\"><a href=\"#调试技巧之条件断点-BOOL-str-isEqualToString-”ABC”\" class=\"headerlink\" title=\"调试技巧之条件断点(BOOL)[str isEqualToString:@”ABC”]\"></a>调试技巧之条件断点(BOOL)[str isEqualToString:@”ABC”]</h2></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2016-01\"><a href=\"#2016-01\" class=\"headerlink\" title=\"2016-01\"></a>2016-01</h1><ul>\n<li><h2 id=\"iOS-开发博客列表\"><a href=\"#iOS-开发博客列表\" class=\"headerlink\" title=\"iOS 开发博客列表\"></a><a href=\"https://github.com/tangqiaoboy/iOSBlogCN\" target=\"_blank\" rel=\"noopener\">iOS 开发博客列表</a></h2></li>\n</ul>\n<h1 id=\"2016-02\"><a href=\"#2016-02\" class=\"headerlink\" title=\"2016-02\"></a>2016-02</h1><ul>\n<li><h2 id=\"frame-和-bounds-区别\"><a href=\"#frame-和-bounds-区别\" class=\"headerlink\" title=\"frame 和 bounds 区别\"></a>frame 和 bounds 区别</h2><ol>\n<li><a href=\"http://blog.csdn.net/mad1989/article/details/8711697\" target=\"_blank\" rel=\"noopener\">设置父 View 的 bounds 的原点，本质是将父 View 的左上角顶点改为 bounds 的原点值</a></li>\n<li>快速输出 frame 和 bounds：NSStringFromCGRect(view.frame)</li>\n<li><a href=\"http://www.cocoachina.com/ios/20140925/9755.html\" target=\"_blank\" rel=\"noopener\">bounds 比其 frame 大或小的影响</a></li>\n<li><p><a href=\"http://stackoverflow.com/questions/17036225/why-self-view-frame-and-self-view-bounds-are-different-w`hen-the-devices-rotate\" target=\"_blank\" rel=\"noopener\">横屏之后，播放器 Controller 的 view 的 frame 的 size 为(320,480)，而 bounds 的 size 为(480,320)</a>，这是因为横屏对播放器 Controller 的 view 应用了 transform，应用了 transform 之后 frame 不变，但是 bounds 会改变</p>\n<p> In addition the frame property’s values are undefined if the view has any transform other than the identity transform. Rotating a view into landscape mode applies a transform to the view so it is not safe to rely on frame values for an app in landscape mode.</p>\n<p> 摘自 <a href=\"http://blog.carbonfive.com/2010/05/27/uiview-frames-and-bounds/\" target=\"_blank\" rel=\"noopener\">UIView Frames and Bounds</a></p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"如何成为一名入门级-iOS-开发者\"><a href=\"#如何成为一名入门级-iOS-开发者\" class=\"headerlink\" title=\"如何成为一名入门级 iOS 开发者\"></a><a href=\"http://www.jianshu.com/p/958c1c52db6c\" target=\"_blank\" rel=\"noopener\">如何成为一名入门级 iOS 开发者</a></h2></li>\n<li><h2 id=\"调试过程使用”thread-return”or-“thread-return-YES”来-return-函数\"><a href=\"#调试过程使用”thread-return”or-“thread-return-YES”来-return-函数\" class=\"headerlink\" title=\"调试过程使用”thread return”or “thread return YES”来 return 函数\"></a>调试过程使用”thread return”or “thread return YES”来 return 函数</h2></li>\n<li><h2 id=\"SVN-合并分支\"><a href=\"#SVN-合并分支\" class=\"headerlink\" title=\"SVN 合并分支\"></a><a href=\"https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-dug-merge.html\" target=\"_blank\" rel=\"noopener\">SVN 合并分支</a></h2></li>\n</ul>\n<h1 id=\"2016-03\"><a href=\"#2016-03\" class=\"headerlink\" title=\"2016-03\"></a>2016-03</h1><ul>\n<li><h2 id=\"调试技巧之条件断点-BOOL-str-isEqualToString-”ABC”\"><a href=\"#调试技巧之条件断点-BOOL-str-isEqualToString-”ABC”\" class=\"headerlink\" title=\"调试技巧之条件断点(BOOL)[str isEqualToString:@”ABC”]\"></a>调试技巧之条件断点(BOOL)[str isEqualToString:@”ABC”]</h2></li>\n</ul>\n"},{"title":"别忘了NSTimer会保留其目标对象","date":"2016-06-19T16:00:00.000Z","keywords":"NSTimer;循环引用;self","_content":"\n# 别忘了NSTimer会保留其目标对象\n```objc\nself.timer = [NSTimer scheduledTimerWithTimeInterval:3\n                                              target:self\n                                            selector:@selector(f)\n                                            userInfo:nil\n                                             repeats:YES];\n\n- (void)dealloc\n{\n    [self.timer invalidate];\n}\n```\n由于 NSTimer 会引用住 self，而 self 又持有 NSTimer 对象，所以形成循环引用，dealloc 永远不会被执行，timer 也永远不会被释放，定时任务会一直执行下去\n# 在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器\n这种方法将 NSTimer 的停止时机提前到 viewWillDisappear，所以不会出现循环引用的问题，只是维护起来比较麻烦\n\n# 为什么不直接使用 weakself\n我的第一直觉是像解决 Block 的循环引用一样，所以尝试 weakself 方案\n\n```objc\n__weak typeof(self) weakSelf = self;\nself.timer = [NSTimer scheduledTimerWithTimeInterval:3\n                                              target:weakSelf\n                                            selector:@selector(f)\n                                            userInfo:nil\n                                             repeats:YES];\n```\n实验发现这种方案是无法解决循环引用的问题，这个问题其实很经典，新手很容易混淆，以为用 weakSelf 就可以解决所有循环引用问题\n\n回顾下，Block 中只是对变量 weakSelf 拷贝了一份，是拷贝变量而不是拷贝对象。即 Block 中也新定义了一个 weakSelf 对象，内部实现代码类似这样`__weak blockWeakSelf = weakSelf;`，对象的 retainCount 没有变化。如果拷贝的是 self，那么 Block 内部实现代码类似这样`__strong blockStrongSelf = self;`，strong 类型的拷贝操作是会使对象的 retainCount 加1的\n\n回到 NSTimer\n>   The timer maintains a strong reference to this object until it (the timer) is invalidated\n\nNSTimer 内部拿到 target 之后，就对其进行强引用，此时即使传入的是 weakSelf，但是 self 仍然会被引用住！因为是对对象本身进行引用，weakSelf 指向的跟 self 指向的都是同个对象，所以这里传 self 和 weakSelf 是没区别的。这也是为什么 block 里面用 strongSelf 强引用住 weakSelf，就可以让 self 不释放的原因\n\n# 使用 Block 来解决循环引用\n```objc\n//.h\n@interface NSTimer (NCYTimer)\n+ (NSTimer *)ncy_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;\n@end\n\n//.m\n@implementation NSTimer (NCYTimer)\n+ (NSTimer *)ncy_scheduledTimerWithTimeInterval:(NSTimeInterval)interval\n                                          block:(void(^)())block\n                                        repeats:(BOOL)repeats\n{\n    return [self scheduledTimerWithTimeInterval:interval\n                                         target:self\n                                       selector:@selector(ncy_blockHandle:)\n                                       userInfo:[block copy]    //记得使用 copy\n                                        repeats:repeats];\n}\n\n+ (void)ncy_blockHandle:(NSTimer *)timer\n{\n    void (^block)() = timer.userInfo;\n    if (block)\n    {\n        block();\n    }\n}\n@end\n```\n\n调用过程注意循环引用\n\n```objc\n__weak typeof(self) weakSelf = self;    //避免 block 强引用 self\nself.timer = [NSTimer ncy_scheduledTimerWithTimeInterval:3\n                                                   block:^{\n                                                       typeof(weakSelf) strongSelf = weakSelf;\n                                                       [strongSelf f];\n                                                   }\n                                                 repeats:YES];\n\n```\n+ 这套方案将计时器应执行的任务封装成 block，然后再放到 userInfo 传给计时器，block 作为参数传递时要 copy 到堆上，否则等到真正执行的时候很可能会被释放\n+ 这套方法依然存在循环引用的问题，但因为现在 NSTimer 引用的 target 是类对象，__类对象本身是个单例__，无需回收，而不是调用者，所以循环引用了也没关系\n+ 调用的时候记得 block 里面要用 weakSelf，然后使用的时候再将 weakSelf 转为 strongSelf，防止 block 执行过程中，self 被释放\n+ 疑问点：为什么类方法可以使用 self？\n    1. 类方法可以调用类方法\n    2. 类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法\n    3. 类方法不可以使用实例变量，类方法可以使用self，因为self不是实例变量\n    \t1. 实例方法里面的self，是对象的首地址\n    \t2. 类方法里面的self，是Class\n+ 疑问点：全部定时器执行的代码放到一个单例去做，不会冲突吗？定时器每执行一个任务就是新建一个线程吗\n\n    定时器每执行一个任务并没有新建一个线程，都是在当前线程，所以冲突是有可能的，假如某个任务很耗时，是会影响其他任务的执行的，更多线程问题可以参考[NSTimer和实现弱引用的timer的方式][1]\n\n# 使用 NSProxy 来解决循环引用\n引入一个对象 NSProxy，NSProxy 弱引用 self，然后 NSProxy 传入 NSTimer。即，self 强引用 NSTimer，NSTimer 强引用 NSProxy，NSProxy 弱引用 self，此时不会形成环。\n\n这个 NSProxy 可参考 [YYWeakProxy](https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m) 的实现\n\n# 参考资料\n+ 《Effective-Objective-C-读书笔记》之《第52条：别忘了NSTimer会保留其目标对象》\n+ [NSTimer和实现弱引用的timer的方式][1]\n[1]:http://www.jianshu.com/p/8121e4aadb4f","source":"_posts/NSTimer 会保留目标对象.md","raw":"---\ntitle: 别忘了NSTimer会保留其目标对象\ndate: 2016-06-20\ncategories:\n- iOS\nkeywords: NSTimer;循环引用;self\n---\n\n# 别忘了NSTimer会保留其目标对象\n```objc\nself.timer = [NSTimer scheduledTimerWithTimeInterval:3\n                                              target:self\n                                            selector:@selector(f)\n                                            userInfo:nil\n                                             repeats:YES];\n\n- (void)dealloc\n{\n    [self.timer invalidate];\n}\n```\n由于 NSTimer 会引用住 self，而 self 又持有 NSTimer 对象，所以形成循环引用，dealloc 永远不会被执行，timer 也永远不会被释放，定时任务会一直执行下去\n# 在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器\n这种方法将 NSTimer 的停止时机提前到 viewWillDisappear，所以不会出现循环引用的问题，只是维护起来比较麻烦\n\n# 为什么不直接使用 weakself\n我的第一直觉是像解决 Block 的循环引用一样，所以尝试 weakself 方案\n\n```objc\n__weak typeof(self) weakSelf = self;\nself.timer = [NSTimer scheduledTimerWithTimeInterval:3\n                                              target:weakSelf\n                                            selector:@selector(f)\n                                            userInfo:nil\n                                             repeats:YES];\n```\n实验发现这种方案是无法解决循环引用的问题，这个问题其实很经典，新手很容易混淆，以为用 weakSelf 就可以解决所有循环引用问题\n\n回顾下，Block 中只是对变量 weakSelf 拷贝了一份，是拷贝变量而不是拷贝对象。即 Block 中也新定义了一个 weakSelf 对象，内部实现代码类似这样`__weak blockWeakSelf = weakSelf;`，对象的 retainCount 没有变化。如果拷贝的是 self，那么 Block 内部实现代码类似这样`__strong blockStrongSelf = self;`，strong 类型的拷贝操作是会使对象的 retainCount 加1的\n\n回到 NSTimer\n>   The timer maintains a strong reference to this object until it (the timer) is invalidated\n\nNSTimer 内部拿到 target 之后，就对其进行强引用，此时即使传入的是 weakSelf，但是 self 仍然会被引用住！因为是对对象本身进行引用，weakSelf 指向的跟 self 指向的都是同个对象，所以这里传 self 和 weakSelf 是没区别的。这也是为什么 block 里面用 strongSelf 强引用住 weakSelf，就可以让 self 不释放的原因\n\n# 使用 Block 来解决循环引用\n```objc\n//.h\n@interface NSTimer (NCYTimer)\n+ (NSTimer *)ncy_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;\n@end\n\n//.m\n@implementation NSTimer (NCYTimer)\n+ (NSTimer *)ncy_scheduledTimerWithTimeInterval:(NSTimeInterval)interval\n                                          block:(void(^)())block\n                                        repeats:(BOOL)repeats\n{\n    return [self scheduledTimerWithTimeInterval:interval\n                                         target:self\n                                       selector:@selector(ncy_blockHandle:)\n                                       userInfo:[block copy]    //记得使用 copy\n                                        repeats:repeats];\n}\n\n+ (void)ncy_blockHandle:(NSTimer *)timer\n{\n    void (^block)() = timer.userInfo;\n    if (block)\n    {\n        block();\n    }\n}\n@end\n```\n\n调用过程注意循环引用\n\n```objc\n__weak typeof(self) weakSelf = self;    //避免 block 强引用 self\nself.timer = [NSTimer ncy_scheduledTimerWithTimeInterval:3\n                                                   block:^{\n                                                       typeof(weakSelf) strongSelf = weakSelf;\n                                                       [strongSelf f];\n                                                   }\n                                                 repeats:YES];\n\n```\n+ 这套方案将计时器应执行的任务封装成 block，然后再放到 userInfo 传给计时器，block 作为参数传递时要 copy 到堆上，否则等到真正执行的时候很可能会被释放\n+ 这套方法依然存在循环引用的问题，但因为现在 NSTimer 引用的 target 是类对象，__类对象本身是个单例__，无需回收，而不是调用者，所以循环引用了也没关系\n+ 调用的时候记得 block 里面要用 weakSelf，然后使用的时候再将 weakSelf 转为 strongSelf，防止 block 执行过程中，self 被释放\n+ 疑问点：为什么类方法可以使用 self？\n    1. 类方法可以调用类方法\n    2. 类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法\n    3. 类方法不可以使用实例变量，类方法可以使用self，因为self不是实例变量\n    \t1. 实例方法里面的self，是对象的首地址\n    \t2. 类方法里面的self，是Class\n+ 疑问点：全部定时器执行的代码放到一个单例去做，不会冲突吗？定时器每执行一个任务就是新建一个线程吗\n\n    定时器每执行一个任务并没有新建一个线程，都是在当前线程，所以冲突是有可能的，假如某个任务很耗时，是会影响其他任务的执行的，更多线程问题可以参考[NSTimer和实现弱引用的timer的方式][1]\n\n# 使用 NSProxy 来解决循环引用\n引入一个对象 NSProxy，NSProxy 弱引用 self，然后 NSProxy 传入 NSTimer。即，self 强引用 NSTimer，NSTimer 强引用 NSProxy，NSProxy 弱引用 self，此时不会形成环。\n\n这个 NSProxy 可参考 [YYWeakProxy](https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m) 的实现\n\n# 参考资料\n+ 《Effective-Objective-C-读书笔记》之《第52条：别忘了NSTimer会保留其目标对象》\n+ [NSTimer和实现弱引用的timer的方式][1]\n[1]:http://www.jianshu.com/p/8121e4aadb4f","slug":"NSTimer 会保留目标对象","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp2opl340003u3qw67l5ultn","content":"<h1 id=\"别忘了NSTimer会保留其目标对象\"><a href=\"#别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"别忘了NSTimer会保留其目标对象\"></a>别忘了NSTimer会保留其目标对象</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                              target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                            selector:<span class=\"keyword\">@selector</span>(f)</span><br><span class=\"line\">                                            userInfo:<span class=\"literal\">nil</span></span><br><span class=\"line\">                                             repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.timer invalidate];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 NSTimer 会引用住 self，而 self 又持有 NSTimer 对象，所以形成循环引用，dealloc 永远不会被执行，timer 也永远不会被释放，定时任务会一直执行下去</p>\n<h1 id=\"在-viewWillAppear-启动定时器，在-viewWillDisappear-停止定时器\"><a href=\"#在-viewWillAppear-启动定时器，在-viewWillDisappear-停止定时器\" class=\"headerlink\" title=\"在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器\"></a>在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器</h1><p>这种方法将 NSTimer 的停止时机提前到 viewWillDisappear，所以不会出现循环引用的问题，只是维护起来比较麻烦</p>\n<h1 id=\"为什么不直接使用-weakself\"><a href=\"#为什么不直接使用-weakself\" class=\"headerlink\" title=\"为什么不直接使用 weakself\"></a>为什么不直接使用 weakself</h1><p>我的第一直觉是像解决 Block 的循环引用一样，所以尝试 weakself 方案</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                              target:weakSelf</span><br><span class=\"line\">                                            selector:<span class=\"keyword\">@selector</span>(f)</span><br><span class=\"line\">                                            userInfo:<span class=\"literal\">nil</span></span><br><span class=\"line\">                                             repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>实验发现这种方案是无法解决循环引用的问题，这个问题其实很经典，新手很容易混淆，以为用 weakSelf 就可以解决所有循环引用问题</p>\n<p>回顾下，Block 中只是对变量 weakSelf 拷贝了一份，是拷贝变量而不是拷贝对象。即 Block 中也新定义了一个 weakSelf 对象，内部实现代码类似这样<code>__weak blockWeakSelf = weakSelf;</code>，对象的 retainCount 没有变化。如果拷贝的是 self，那么 Block 内部实现代码类似这样<code>__strong blockStrongSelf = self;</code>，strong 类型的拷贝操作是会使对象的 retainCount 加1的</p>\n<p>回到 NSTimer</p>\n<blockquote>\n<p>  The timer maintains a strong reference to this object until it (the timer) is invalidated</p>\n</blockquote>\n<p>NSTimer 内部拿到 target 之后，就对其进行强引用，此时即使传入的是 weakSelf，但是 self 仍然会被引用住！因为是对对象本身进行引用，weakSelf 指向的跟 self 指向的都是同个对象，所以这里传 self 和 weakSelf 是没区别的。这也是为什么 block 里面用 strongSelf 强引用住 weakSelf，就可以让 self 不释放的原因</p>\n<h1 id=\"使用-Block-来解决循环引用\"><a href=\"#使用-Block-来解决循环引用\" class=\"headerlink\" title=\"使用 Block 来解决循环引用\"></a>使用 Block 来解决循环引用</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">NCYTimer</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ncy_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval block:(<span class=\"keyword\">void</span>(^)())block repeats:(<span class=\"built_in\">BOOL</span>)repeats;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">NCYTimer</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ncy_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval</span><br><span class=\"line\">                                          block:(<span class=\"keyword\">void</span>(^)())block</span><br><span class=\"line\">                                        repeats:(<span class=\"built_in\">BOOL</span>)repeats</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> scheduledTimerWithTimeInterval:interval</span><br><span class=\"line\">                                         target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                       selector:<span class=\"keyword\">@selector</span>(ncy_blockHandle:)</span><br><span class=\"line\">                                       userInfo:[block <span class=\"keyword\">copy</span>]    <span class=\"comment\">//记得使用 copy</span></span><br><span class=\"line\">                                        repeats:repeats];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)ncy_blockHandle:(<span class=\"built_in\">NSTimer</span> *)timer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = timer.userInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>调用过程注意循环引用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;    <span class=\"comment\">//避免 block 强引用 self</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> ncy_scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                                   block:^&#123;</span><br><span class=\"line\">                                                       <span class=\"keyword\">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">                                                       [strongSelf f];</span><br><span class=\"line\">                                                   &#125;</span><br><span class=\"line\">                                                 repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这套方案将计时器应执行的任务封装成 block，然后再放到 userInfo 传给计时器，block 作为参数传递时要 copy 到堆上，否则等到真正执行的时候很可能会被释放</li>\n<li>这套方法依然存在循环引用的问题，但因为现在 NSTimer 引用的 target 是类对象，<strong>类对象本身是个单例</strong>，无需回收，而不是调用者，所以循环引用了也没关系</li>\n<li>调用的时候记得 block 里面要用 weakSelf，然后使用的时候再将 weakSelf 转为 strongSelf，防止 block 执行过程中，self 被释放</li>\n<li>疑问点：为什么类方法可以使用 self？<ol>\n<li>类方法可以调用类方法</li>\n<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法</li>\n<li>类方法不可以使用实例变量，类方法可以使用self，因为self不是实例变量<ol>\n<li>实例方法里面的self，是对象的首地址</li>\n<li>类方法里面的self，是Class</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>疑问点：全部定时器执行的代码放到一个单例去做，不会冲突吗？定时器每执行一个任务就是新建一个线程吗</p>\n<p>  定时器每执行一个任务并没有新建一个线程，都是在当前线程，所以冲突是有可能的，假如某个任务很耗时，是会影响其他任务的执行的，更多线程问题可以参考<a href=\"http://www.jianshu.com/p/8121e4aadb4f\" target=\"_blank\" rel=\"noopener\">NSTimer和实现弱引用的timer的方式</a></p>\n</li>\n</ul>\n<h1 id=\"使用-NSProxy-来解决循环引用\"><a href=\"#使用-NSProxy-来解决循环引用\" class=\"headerlink\" title=\"使用 NSProxy 来解决循环引用\"></a>使用 NSProxy 来解决循环引用</h1><p>引入一个对象 NSProxy，NSProxy 弱引用 self，然后 NSProxy 传入 NSTimer。即，self 强引用 NSTimer，NSTimer 强引用 NSProxy，NSProxy 弱引用 self，此时不会形成环。</p>\n<p>这个 NSProxy 可参考 <a href=\"https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m\" target=\"_blank\" rel=\"noopener\">YYWeakProxy</a> 的实现</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>《Effective-Objective-C-读书笔记》之《第52条：别忘了NSTimer会保留其目标对象》</li>\n<li><a href=\"http://www.jianshu.com/p/8121e4aadb4f\" target=\"_blank\" rel=\"noopener\">NSTimer和实现弱引用的timer的方式</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"别忘了NSTimer会保留其目标对象\"><a href=\"#别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"别忘了NSTimer会保留其目标对象\"></a>别忘了NSTimer会保留其目标对象</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                              target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                            selector:<span class=\"keyword\">@selector</span>(f)</span><br><span class=\"line\">                                            userInfo:<span class=\"literal\">nil</span></span><br><span class=\"line\">                                             repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.timer invalidate];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 NSTimer 会引用住 self，而 self 又持有 NSTimer 对象，所以形成循环引用，dealloc 永远不会被执行，timer 也永远不会被释放，定时任务会一直执行下去</p>\n<h1 id=\"在-viewWillAppear-启动定时器，在-viewWillDisappear-停止定时器\"><a href=\"#在-viewWillAppear-启动定时器，在-viewWillDisappear-停止定时器\" class=\"headerlink\" title=\"在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器\"></a>在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器</h1><p>这种方法将 NSTimer 的停止时机提前到 viewWillDisappear，所以不会出现循环引用的问题，只是维护起来比较麻烦</p>\n<h1 id=\"为什么不直接使用-weakself\"><a href=\"#为什么不直接使用-weakself\" class=\"headerlink\" title=\"为什么不直接使用 weakself\"></a>为什么不直接使用 weakself</h1><p>我的第一直觉是像解决 Block 的循环引用一样，所以尝试 weakself 方案</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                              target:weakSelf</span><br><span class=\"line\">                                            selector:<span class=\"keyword\">@selector</span>(f)</span><br><span class=\"line\">                                            userInfo:<span class=\"literal\">nil</span></span><br><span class=\"line\">                                             repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>实验发现这种方案是无法解决循环引用的问题，这个问题其实很经典，新手很容易混淆，以为用 weakSelf 就可以解决所有循环引用问题</p>\n<p>回顾下，Block 中只是对变量 weakSelf 拷贝了一份，是拷贝变量而不是拷贝对象。即 Block 中也新定义了一个 weakSelf 对象，内部实现代码类似这样<code>__weak blockWeakSelf = weakSelf;</code>，对象的 retainCount 没有变化。如果拷贝的是 self，那么 Block 内部实现代码类似这样<code>__strong blockStrongSelf = self;</code>，strong 类型的拷贝操作是会使对象的 retainCount 加1的</p>\n<p>回到 NSTimer</p>\n<blockquote>\n<p>  The timer maintains a strong reference to this object until it (the timer) is invalidated</p>\n</blockquote>\n<p>NSTimer 内部拿到 target 之后，就对其进行强引用，此时即使传入的是 weakSelf，但是 self 仍然会被引用住！因为是对对象本身进行引用，weakSelf 指向的跟 self 指向的都是同个对象，所以这里传 self 和 weakSelf 是没区别的。这也是为什么 block 里面用 strongSelf 强引用住 weakSelf，就可以让 self 不释放的原因</p>\n<h1 id=\"使用-Block-来解决循环引用\"><a href=\"#使用-Block-来解决循环引用\" class=\"headerlink\" title=\"使用 Block 来解决循环引用\"></a>使用 Block 来解决循环引用</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">NCYTimer</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ncy_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval block:(<span class=\"keyword\">void</span>(^)())block repeats:(<span class=\"built_in\">BOOL</span>)repeats;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">NCYTimer</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ncy_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval</span><br><span class=\"line\">                                          block:(<span class=\"keyword\">void</span>(^)())block</span><br><span class=\"line\">                                        repeats:(<span class=\"built_in\">BOOL</span>)repeats</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> scheduledTimerWithTimeInterval:interval</span><br><span class=\"line\">                                         target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                       selector:<span class=\"keyword\">@selector</span>(ncy_blockHandle:)</span><br><span class=\"line\">                                       userInfo:[block <span class=\"keyword\">copy</span>]    <span class=\"comment\">//记得使用 copy</span></span><br><span class=\"line\">                                        repeats:repeats];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)ncy_blockHandle:(<span class=\"built_in\">NSTimer</span> *)timer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = timer.userInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>调用过程注意循环引用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;    <span class=\"comment\">//避免 block 强引用 self</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> ncy_scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                                   block:^&#123;</span><br><span class=\"line\">                                                       <span class=\"keyword\">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">                                                       [strongSelf f];</span><br><span class=\"line\">                                                   &#125;</span><br><span class=\"line\">                                                 repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这套方案将计时器应执行的任务封装成 block，然后再放到 userInfo 传给计时器，block 作为参数传递时要 copy 到堆上，否则等到真正执行的时候很可能会被释放</li>\n<li>这套方法依然存在循环引用的问题，但因为现在 NSTimer 引用的 target 是类对象，<strong>类对象本身是个单例</strong>，无需回收，而不是调用者，所以循环引用了也没关系</li>\n<li>调用的时候记得 block 里面要用 weakSelf，然后使用的时候再将 weakSelf 转为 strongSelf，防止 block 执行过程中，self 被释放</li>\n<li>疑问点：为什么类方法可以使用 self？<ol>\n<li>类方法可以调用类方法</li>\n<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法</li>\n<li>类方法不可以使用实例变量，类方法可以使用self，因为self不是实例变量<ol>\n<li>实例方法里面的self，是对象的首地址</li>\n<li>类方法里面的self，是Class</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>疑问点：全部定时器执行的代码放到一个单例去做，不会冲突吗？定时器每执行一个任务就是新建一个线程吗</p>\n<p>  定时器每执行一个任务并没有新建一个线程，都是在当前线程，所以冲突是有可能的，假如某个任务很耗时，是会影响其他任务的执行的，更多线程问题可以参考<a href=\"http://www.jianshu.com/p/8121e4aadb4f\" target=\"_blank\" rel=\"noopener\">NSTimer和实现弱引用的timer的方式</a></p>\n</li>\n</ul>\n<h1 id=\"使用-NSProxy-来解决循环引用\"><a href=\"#使用-NSProxy-来解决循环引用\" class=\"headerlink\" title=\"使用 NSProxy 来解决循环引用\"></a>使用 NSProxy 来解决循环引用</h1><p>引入一个对象 NSProxy，NSProxy 弱引用 self，然后 NSProxy 传入 NSTimer。即，self 强引用 NSTimer，NSTimer 强引用 NSProxy，NSProxy 弱引用 self，此时不会形成环。</p>\n<p>这个 NSProxy 可参考 <a href=\"https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m\" target=\"_blank\" rel=\"noopener\">YYWeakProxy</a> 的实现</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>《Effective-Objective-C-读书笔记》之《第52条：别忘了NSTimer会保留其目标对象》</li>\n<li><a href=\"http://www.jianshu.com/p/8121e4aadb4f\" target=\"_blank\" rel=\"noopener\">NSTimer和实现弱引用的timer的方式</a></li>\n</ul>\n"},{"title":"ARC/MRC 调用未声明方法","date":"2016-06-14T16:00:00.000Z","keywords":"ARC,MRC,未声明方法,performSelector,undeclared methods","_content":"\n# 背景\n有一次，发现调用一个未声明的方法的时候，Xcode 居然没有像往常一样给出错误提示，而只是给了 Warning，研究后发现原来该文件不是 ARC，所以出现这种问题，那么 ARC 和 MRC 之间，对于调用未声明的方法，有什么区别呢？\n# 实验\n`[self noSuchMethod];`\n\nMRC 下，调用一个未声明的方法，编译器会给出 Warning:\n> \"Instance method 'noSuchMethod' not found (return type defaults to 'id')\"\n\nARC 下，调用一个未声明的方法，编译器却给出 Error:\n> \"No visible @interface for 'xxx' declares the selector 'noSuchMethod'\"\n\n\n原因：\n\nARC 下，编译器需要知道方法返回值的所有者，才能正确在合适的地方添加 retain/release 等，所以显式调用一个未声明的方法在 ARC 下默认是不允许的\n\n下面是具体的代码提示，跟Xcode的版本有关系，我的Xcode是`Version 7.3.1 (7D1014)`\n\nMRC:\n\n```objectivec\nid classA;\n\n// Warning:Instance method '-xyz' not found (return type defaults to 'id')\n[classA xyz];\n\n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz)];\n\n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\")];\n\n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil];\n    \n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil afterDelay:0];\n\n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil afterDelay:0];\n```\n\nARC:\n\n```objectivec\nid classA;\n    \n// Error:No known instance method for selector 'xyz' 或者\n// Error:No visible @interface for 'xxx' declares the selector 'xyz'\n[classA xyz];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz)];\n    \n// Warning:\"PerformSelector may cause a leak because its selector is unknown\"\n[classA performSelector:NSSelectorFromString(@\"xyz\")];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil];\n    \n// Warning:\"PerformSelector may cause a leak because its selector is unknown\"\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil afterDelay:0];\n    \n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil afterDelay:0];\n```\n\n问题：\n\n1. @selector 和 NSSelectorFromString 区别\n\n    可以看到使用 @selector()，编译器可以知道相应方法没有被声明；而使用 NSSelectorFromString，编译器并不知情，因为该方法是动态的，在 Runtime 的时候才能确定相应的方法实现，所以编译器选择了忽略\n    \n    所以 MRC 下很简单，@selector 就给警告， NSSelectorFromString 就不管\n    \n    ARC 下，就复杂点，@selectot 依然给警告，但是 NSSelectorFromString 的处理就复杂点，继续往下看\n    \n2. 那为什么 ARC 下， `performSelector:NSSelectorFromString()` 会有 Leak Warning\n    \n    事实上，无论 xyz 方法存在不存在，只要是 ARC 下，使用`performSelector:NSSelectorFromString()`就会有该 Warning 产生，因为编译器并不知道你调用了什么方法(是含有`alloc`/`new`/`copy`/`mutableCopy`关键字的方法还是普通方法)，那它也不知道该不该添加 retain/release 等，所以给出可能产生内存泄露的警告\n    \n    如果确定了这样调用没有内存问题，那么可以通过以下方法消除 Warning：\n    \n    + 针对部分代码\n    \n    ```objectivec\n    #pragma clang diagnostic push\n    #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n    [classA performSelector:NSSelectorFromString(@\"xyz\")];\n    #pragma clang diagnostic pop\n    ```\n\n    更骚一点的做法是\n    \n    ```objectivec\n    #define SILENCE_PERFORMSELECTOR(expr)                               \\\n    do {                                                                \\\n    _Pragma(\"clang diagnostic push\")                                    \\\n    _Pragma(\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\") \\\n    expr;                                                               \\\n    _Pragma(\"clang diagnostic pop\")                                     \\\n    } while(0)\n    \n    SILENCE_PERFORMSELECTOR([classA performSelector:NSSelectorFromString(@\"xyz\")]);\n    ```\n\n    + 针对单个文件，与设置某个文件为非 ARC 类似（见小Tips），添加`-Wno-arc-performSelector-leaks`\n    + 针对整个工程，Build Settings，搜索 Other Warning Flags，添加`-Wno-arc-performSelector-leaks`\n    \n3. 最后的问题，为什么 ARC 下， `performSelector:NSSelectorFromString() withObject:afterDelay:` 就没有 Leak Warning 呢\n    \n    看看这几个函数的原型\n    \n    ```objectivec\n    - (id)performSelector:(SEL)aSelector;\n    - (id)performSelector:(SEL)aSelector withObject:(id)object;\n    - (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;    \n    ```\n    可以看到，`performSelector:withObject:afterDelay:`返回值是 void。所以可以推测，Xcode 认为，你既然写了 afterDelay（即使是延迟0秒），那么它的返回值是 void，无论 selector 有没有返回值，都不需要为之添加 retain/release，所以这种情况下没有内存问题\n\n# 小Tips\n1. ARC 与 MRC 互转：工程 -> Targets -> Build Phases -> Compile Sources -> 对应的.m文件的Compiler Flags添加`-fno-objc-arc`(MRC)/`-fobjc-arc`(ARC)\n2. 判断 ARC 与 MRC 的快速方法，在 `dealloc` 里面调用 `[super dealloc];`，如果报错则是 ARC，否则是 MRC\n\n# 参考链接\n+ [stackoverflow1](http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/7954697#7954697)\n+ [stackoverflow2](http://stackoverflow.com/questions/20582642/why-arc-forbids-calls-to-undeclared-methods/20582863#20582863)","source":"_posts/ARC MRC 调用未声明方法.md","raw":"---\ntitle: ARC/MRC 调用未声明方法\ndate: 2016-06-15\ncategories:\n- iOS\nkeywords: ARC,MRC,未声明方法,performSelector,undeclared methods\n---\n\n# 背景\n有一次，发现调用一个未声明的方法的时候，Xcode 居然没有像往常一样给出错误提示，而只是给了 Warning，研究后发现原来该文件不是 ARC，所以出现这种问题，那么 ARC 和 MRC 之间，对于调用未声明的方法，有什么区别呢？\n# 实验\n`[self noSuchMethod];`\n\nMRC 下，调用一个未声明的方法，编译器会给出 Warning:\n> \"Instance method 'noSuchMethod' not found (return type defaults to 'id')\"\n\nARC 下，调用一个未声明的方法，编译器却给出 Error:\n> \"No visible @interface for 'xxx' declares the selector 'noSuchMethod'\"\n\n\n原因：\n\nARC 下，编译器需要知道方法返回值的所有者，才能正确在合适的地方添加 retain/release 等，所以显式调用一个未声明的方法在 ARC 下默认是不允许的\n\n下面是具体的代码提示，跟Xcode的版本有关系，我的Xcode是`Version 7.3.1 (7D1014)`\n\nMRC:\n\n```objectivec\nid classA;\n\n// Warning:Instance method '-xyz' not found (return type defaults to 'id')\n[classA xyz];\n\n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz)];\n\n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\")];\n\n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil];\n    \n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil afterDelay:0];\n\n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil afterDelay:0];\n```\n\nARC:\n\n```objectivec\nid classA;\n    \n// Error:No known instance method for selector 'xyz' 或者\n// Error:No visible @interface for 'xxx' declares the selector 'xyz'\n[classA xyz];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz)];\n    \n// Warning:\"PerformSelector may cause a leak because its selector is unknown\"\n[classA performSelector:NSSelectorFromString(@\"xyz\")];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil];\n    \n// Warning:\"PerformSelector may cause a leak because its selector is unknown\"\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil afterDelay:0];\n    \n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil afterDelay:0];\n```\n\n问题：\n\n1. @selector 和 NSSelectorFromString 区别\n\n    可以看到使用 @selector()，编译器可以知道相应方法没有被声明；而使用 NSSelectorFromString，编译器并不知情，因为该方法是动态的，在 Runtime 的时候才能确定相应的方法实现，所以编译器选择了忽略\n    \n    所以 MRC 下很简单，@selector 就给警告， NSSelectorFromString 就不管\n    \n    ARC 下，就复杂点，@selectot 依然给警告，但是 NSSelectorFromString 的处理就复杂点，继续往下看\n    \n2. 那为什么 ARC 下， `performSelector:NSSelectorFromString()` 会有 Leak Warning\n    \n    事实上，无论 xyz 方法存在不存在，只要是 ARC 下，使用`performSelector:NSSelectorFromString()`就会有该 Warning 产生，因为编译器并不知道你调用了什么方法(是含有`alloc`/`new`/`copy`/`mutableCopy`关键字的方法还是普通方法)，那它也不知道该不该添加 retain/release 等，所以给出可能产生内存泄露的警告\n    \n    如果确定了这样调用没有内存问题，那么可以通过以下方法消除 Warning：\n    \n    + 针对部分代码\n    \n    ```objectivec\n    #pragma clang diagnostic push\n    #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n    [classA performSelector:NSSelectorFromString(@\"xyz\")];\n    #pragma clang diagnostic pop\n    ```\n\n    更骚一点的做法是\n    \n    ```objectivec\n    #define SILENCE_PERFORMSELECTOR(expr)                               \\\n    do {                                                                \\\n    _Pragma(\"clang diagnostic push\")                                    \\\n    _Pragma(\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\") \\\n    expr;                                                               \\\n    _Pragma(\"clang diagnostic pop\")                                     \\\n    } while(0)\n    \n    SILENCE_PERFORMSELECTOR([classA performSelector:NSSelectorFromString(@\"xyz\")]);\n    ```\n\n    + 针对单个文件，与设置某个文件为非 ARC 类似（见小Tips），添加`-Wno-arc-performSelector-leaks`\n    + 针对整个工程，Build Settings，搜索 Other Warning Flags，添加`-Wno-arc-performSelector-leaks`\n    \n3. 最后的问题，为什么 ARC 下， `performSelector:NSSelectorFromString() withObject:afterDelay:` 就没有 Leak Warning 呢\n    \n    看看这几个函数的原型\n    \n    ```objectivec\n    - (id)performSelector:(SEL)aSelector;\n    - (id)performSelector:(SEL)aSelector withObject:(id)object;\n    - (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;    \n    ```\n    可以看到，`performSelector:withObject:afterDelay:`返回值是 void。所以可以推测，Xcode 认为，你既然写了 afterDelay（即使是延迟0秒），那么它的返回值是 void，无论 selector 有没有返回值，都不需要为之添加 retain/release，所以这种情况下没有内存问题\n\n# 小Tips\n1. ARC 与 MRC 互转：工程 -> Targets -> Build Phases -> Compile Sources -> 对应的.m文件的Compiler Flags添加`-fno-objc-arc`(MRC)/`-fobjc-arc`(ARC)\n2. 判断 ARC 与 MRC 的快速方法，在 `dealloc` 里面调用 `[super dealloc];`，如果报错则是 ARC，否则是 MRC\n\n# 参考链接\n+ [stackoverflow1](http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/7954697#7954697)\n+ [stackoverflow2](http://stackoverflow.com/questions/20582642/why-arc-forbids-calls-to-undeclared-methods/20582863#20582863)","slug":"ARC MRC 调用未声明方法","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp2opl370006u3qws05vhiw6","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>有一次，发现调用一个未声明的方法的时候，Xcode 居然没有像往常一样给出错误提示，而只是给了 Warning，研究后发现原来该文件不是 ARC，所以出现这种问题，那么 ARC 和 MRC 之间，对于调用未声明的方法，有什么区别呢？</p>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><p><code>[self noSuchMethod];</code></p>\n<p>MRC 下，调用一个未声明的方法，编译器会给出 Warning:</p>\n<blockquote>\n<p>“Instance method ‘noSuchMethod’ not found (return type defaults to ‘id’)”</p>\n</blockquote>\n<p>ARC 下，调用一个未声明的方法，编译器却给出 Error:</p>\n<blockquote>\n<p>“No visible @interface for ‘xxx’ declares the selector ‘noSuchMethod’”</p>\n</blockquote>\n<p>原因：</p>\n<p>ARC 下，编译器需要知道方法返回值的所有者，才能正确在合适的地方添加 retain/release 等，所以显式调用一个未声明的方法在 ARC 下默认是不允许的</p>\n<p>下面是具体的代码提示，跟Xcode的版本有关系，我的Xcode是<code>Version 7.3.1 (7D1014)</code></p>\n<p>MRC:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> classA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Instance method '-xyz' not found (return type defaults to 'id')</span></span><br><span class=\"line\">[classA xyz];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>ARC:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> classA;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Error:No known instance method for selector 'xyz' 或者</span></span><br><span class=\"line\"><span class=\"comment\">// Error:No visible @interface for 'xxx' declares the selector 'xyz'</span></span><br><span class=\"line\">[classA xyz];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz)];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:\"PerformSelector may cause a leak because its selector is unknown\"</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:\"PerformSelector may cause a leak because its selector is unknown\"</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>问题：</p>\n<ol>\n<li><p>@selector 和 NSSelectorFromString 区别</p>\n<p> 可以看到使用 @selector()，编译器可以知道相应方法没有被声明；而使用 NSSelectorFromString，编译器并不知情，因为该方法是动态的，在 Runtime 的时候才能确定相应的方法实现，所以编译器选择了忽略</p>\n<p> 所以 MRC 下很简单，@selector 就给警告， NSSelectorFromString 就不管</p>\n<p> ARC 下，就复杂点，@selectot 依然给警告，但是 NSSelectorFromString 的处理就复杂点，继续往下看</p>\n</li>\n<li><p>那为什么 ARC 下， <code>performSelector:NSSelectorFromString()</code> 会有 Leak Warning</p>\n<p> 事实上，无论 xyz 方法存在不存在，只要是 ARC 下，使用<code>performSelector:NSSelectorFromString()</code>就会有该 Warning 产生，因为编译器并不知道你调用了什么方法(是含有<code>alloc</code>/<code>new</code>/<code>copy</code>/<code>mutableCopy</code>关键字的方法还是普通方法)，那它也不知道该不该添加 retain/release 等，所以给出可能产生内存泄露的警告</p>\n<p> 如果确定了这样调用没有内存问题，那么可以通过以下方法消除 Warning：</p>\n<ul>\n<li><p>针对部分代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic push</span></span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic ignored <span class=\"meta-string\">\"-Warc-performSelector-leaks\"</span></span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic pop</span></span><br></pre></td></tr></table></figure>\n<p>更骚一点的做法是</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define SILENCE_PERFORMSELECTOR(expr)                               \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;                                                                \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic push\"</span>)                                    \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\"</span>) \\</span><br><span class=\"line\">expr;                                                               \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic pop\"</span>)                                     \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">SILENCE_PERFORMSELECTOR([classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>针对单个文件，与设置某个文件为非 ARC 类似（见小Tips），添加<code>-Wno-arc-performSelector-leaks</code></p>\n</li>\n<li>针对整个工程，Build Settings，搜索 Other Warning Flags，添加<code>-Wno-arc-performSelector-leaks</code></li>\n</ul>\n</li>\n<li><p>最后的问题，为什么 ARC 下， <code>performSelector:NSSelectorFromString() withObject:afterDelay:</code> 就没有 Leak Warning 呢</p>\n<p> 看看这几个函数的原型</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)performSelector:(SEL)aSelector;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)performSelector:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)object;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector withObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)anArgument afterDelay:(<span class=\"built_in\">NSTimeInterval</span>)delay;</span><br></pre></td></tr></table></figure>\n<p> 可以看到，<code>performSelector:withObject:afterDelay:</code>返回值是 void。所以可以推测，Xcode 认为，你既然写了 afterDelay（即使是延迟0秒），那么它的返回值是 void，无论 selector 有没有返回值，都不需要为之添加 retain/release，所以这种情况下没有内存问题</p>\n</li>\n</ol>\n<h1 id=\"小Tips\"><a href=\"#小Tips\" class=\"headerlink\" title=\"小Tips\"></a>小Tips</h1><ol>\n<li>ARC 与 MRC 互转：工程 -&gt; Targets -&gt; Build Phases -&gt; Compile Sources -&gt; 对应的.m文件的Compiler Flags添加<code>-fno-objc-arc</code>(MRC)/<code>-fobjc-arc</code>(ARC)</li>\n<li>判断 ARC 与 MRC 的快速方法，在 <code>dealloc</code> 里面调用 <code>[super dealloc];</code>，如果报错则是 ARC，否则是 MRC</li>\n</ol>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/7954697#7954697\" target=\"_blank\" rel=\"noopener\">stackoverflow1</a></li>\n<li><a href=\"http://stackoverflow.com/questions/20582642/why-arc-forbids-calls-to-undeclared-methods/20582863#20582863\" target=\"_blank\" rel=\"noopener\">stackoverflow2</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>有一次，发现调用一个未声明的方法的时候，Xcode 居然没有像往常一样给出错误提示，而只是给了 Warning，研究后发现原来该文件不是 ARC，所以出现这种问题，那么 ARC 和 MRC 之间，对于调用未声明的方法，有什么区别呢？</p>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><p><code>[self noSuchMethod];</code></p>\n<p>MRC 下，调用一个未声明的方法，编译器会给出 Warning:</p>\n<blockquote>\n<p>“Instance method ‘noSuchMethod’ not found (return type defaults to ‘id’)”</p>\n</blockquote>\n<p>ARC 下，调用一个未声明的方法，编译器却给出 Error:</p>\n<blockquote>\n<p>“No visible @interface for ‘xxx’ declares the selector ‘noSuchMethod’”</p>\n</blockquote>\n<p>原因：</p>\n<p>ARC 下，编译器需要知道方法返回值的所有者，才能正确在合适的地方添加 retain/release 等，所以显式调用一个未声明的方法在 ARC 下默认是不允许的</p>\n<p>下面是具体的代码提示，跟Xcode的版本有关系，我的Xcode是<code>Version 7.3.1 (7D1014)</code></p>\n<p>MRC:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> classA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Instance method '-xyz' not found (return type defaults to 'id')</span></span><br><span class=\"line\">[classA xyz];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>ARC:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> classA;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Error:No known instance method for selector 'xyz' 或者</span></span><br><span class=\"line\"><span class=\"comment\">// Error:No visible @interface for 'xxx' declares the selector 'xyz'</span></span><br><span class=\"line\">[classA xyz];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz)];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:\"PerformSelector may cause a leak because its selector is unknown\"</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:\"PerformSelector may cause a leak because its selector is unknown\"</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>问题：</p>\n<ol>\n<li><p>@selector 和 NSSelectorFromString 区别</p>\n<p> 可以看到使用 @selector()，编译器可以知道相应方法没有被声明；而使用 NSSelectorFromString，编译器并不知情，因为该方法是动态的，在 Runtime 的时候才能确定相应的方法实现，所以编译器选择了忽略</p>\n<p> 所以 MRC 下很简单，@selector 就给警告， NSSelectorFromString 就不管</p>\n<p> ARC 下，就复杂点，@selectot 依然给警告，但是 NSSelectorFromString 的处理就复杂点，继续往下看</p>\n</li>\n<li><p>那为什么 ARC 下， <code>performSelector:NSSelectorFromString()</code> 会有 Leak Warning</p>\n<p> 事实上，无论 xyz 方法存在不存在，只要是 ARC 下，使用<code>performSelector:NSSelectorFromString()</code>就会有该 Warning 产生，因为编译器并不知道你调用了什么方法(是含有<code>alloc</code>/<code>new</code>/<code>copy</code>/<code>mutableCopy</code>关键字的方法还是普通方法)，那它也不知道该不该添加 retain/release 等，所以给出可能产生内存泄露的警告</p>\n<p> 如果确定了这样调用没有内存问题，那么可以通过以下方法消除 Warning：</p>\n<ul>\n<li><p>针对部分代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic push</span></span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic ignored <span class=\"meta-string\">\"-Warc-performSelector-leaks\"</span></span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic pop</span></span><br></pre></td></tr></table></figure>\n<p>更骚一点的做法是</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define SILENCE_PERFORMSELECTOR(expr)                               \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;                                                                \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic push\"</span>)                                    \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\"</span>) \\</span><br><span class=\"line\">expr;                                                               \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic pop\"</span>)                                     \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">SILENCE_PERFORMSELECTOR([classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>针对单个文件，与设置某个文件为非 ARC 类似（见小Tips），添加<code>-Wno-arc-performSelector-leaks</code></p>\n</li>\n<li>针对整个工程，Build Settings，搜索 Other Warning Flags，添加<code>-Wno-arc-performSelector-leaks</code></li>\n</ul>\n</li>\n<li><p>最后的问题，为什么 ARC 下， <code>performSelector:NSSelectorFromString() withObject:afterDelay:</code> 就没有 Leak Warning 呢</p>\n<p> 看看这几个函数的原型</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)performSelector:(SEL)aSelector;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)performSelector:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)object;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector withObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)anArgument afterDelay:(<span class=\"built_in\">NSTimeInterval</span>)delay;</span><br></pre></td></tr></table></figure>\n<p> 可以看到，<code>performSelector:withObject:afterDelay:</code>返回值是 void。所以可以推测，Xcode 认为，你既然写了 afterDelay（即使是延迟0秒），那么它的返回值是 void，无论 selector 有没有返回值，都不需要为之添加 retain/release，所以这种情况下没有内存问题</p>\n</li>\n</ol>\n<h1 id=\"小Tips\"><a href=\"#小Tips\" class=\"headerlink\" title=\"小Tips\"></a>小Tips</h1><ol>\n<li>ARC 与 MRC 互转：工程 -&gt; Targets -&gt; Build Phases -&gt; Compile Sources -&gt; 对应的.m文件的Compiler Flags添加<code>-fno-objc-arc</code>(MRC)/<code>-fobjc-arc</code>(ARC)</li>\n<li>判断 ARC 与 MRC 的快速方法，在 <code>dealloc</code> 里面调用 <code>[super dealloc];</code>，如果报错则是 ARC，否则是 MRC</li>\n</ol>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/7954697#7954697\" target=\"_blank\" rel=\"noopener\">stackoverflow1</a></li>\n<li><a href=\"http://stackoverflow.com/questions/20582642/why-arc-forbids-calls-to-undeclared-methods/20582863#20582863\" target=\"_blank\" rel=\"noopener\">stackoverflow2</a></li>\n</ul>\n"},{"title":"Effective-Objective-C-读书笔记","description":"《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》","date":"2016-03-18T16:00:00.000Z","photos":[],"_content":"\n# 第1章 熟悉Objective—C \n## 第1条：了解Objective—C语言的起源\n```objectivec\nNSString *s1 = @\"Hello\";\nNSString *s2 = s1;\n```\n+ s1 和s2 的内存分配在栈上\n+ @\"Hello\"的内存分配在堆上\n+ s1 和 s2 指向同一块内存\n\n\n## 第2条：在类的头文件中尽量少引入其他头文件\n\n## 第3条：多用字面量语法，少用与之等价的方法\n### 使用字面量语法，它是一种语法糖：\n```objectivec\nNSString *str = @\"Hello\";\nNSNumber *intNum = @1;\nNSNumber *doubleNum = @2.5;\nNSNumber *charNum = @'a';\nNSNumber *boolNum = @YES;\nNSArray *array = @[@\"hello\", @1, @2.5, @'a'];\nNSString *str2 = array[0];\nNSDictionary *dic = @{@\"1\":@1, @\"2\":@2};\n```\n### 这个语法糖更容易暴露隐藏的问题\n```objectivec\nNSArray *array1 = [NSArray arrayWithObjects: obj1, obj2, obj3, nil];\nNSArray *array2 = @[obj1, obj2, obj3];\n```\n如果 obj1 和 obj3 非空，而 obj2 是 nil\n\n那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常\n\n### 使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\n```objectivec\nNSMuatableArray *mArray = [@[@1, @2] mutableCopy];\n```\n## 第4条：多用类型常量，少用#define预处理指令 \n详见[NSNotification Name 最佳写法](http://www.cnblogs.com/chenyg32/p/5080301.html)\n\n## 第5条：用枚举表示状态、选项、状态码\n### 使用 `NS_ENUM` 和 `NS_OPTIONS` 来表示`状态机`，\n```objectivec\n//NS_ENUM，定义状态等普通枚举\ntypedef NS_ENUM(NSUInteger, TTGState) {\n    TTGStateOK = 0,\n    TTGStateError,\n    TTGStateUnknow\n};\n\n//NS_OPTIONS，定义选项\ntypedef NS_OPTIONS(NSUInteger, TTGDirection) {\n    TTGDirectionNone = 0,\n    TTGDirectionTop = 1 << 0,\n    TTGDirectionLeft = 1 << 1,\n    TTGDirectionRight = 1 << 2,\n    TTGDirectionBottom = 1 << 3\n};\n```\n### 如果一个`枚举变量`可以同时表示一个或多个选项的集合，那么应当使用 `NS_OPTIONS`，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用`或操作`将其组合起来进行表示\n\n### 相比较 C 语言中的枚举，使用 `NS_ENUM` 和 `NS_OPTIONS` 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\n```objectivec\ntypedef enum _TTGState {\n    TTGStateOK  = 0,\n    TTGStateError,\n    TTGStateUnknow\n} TTGState;\n```\n### 处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举\n\n### 参考链接：[Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5](http://tutuge.me/2015/03/21/effective-objective-c-5-enum/)\n\n# 第2章 对象、消息、运行期 \n## 第6条：理解“属性”这一概念 \n### 理解好`属性`和`实例变量`的区别\n\n属性 = 实例变量 + setter + getter\n\n如果声明属性\n\n    @property (nonatomic, copy) NSString *str;\n\n则编译器会默认实现\n\n```objectivec\n//.h\n- (NSString *)str;\n- (void)setStr:(NSString *)str;\n\n//.m\n- (NSString *)str\n{\n\treturn _str;\n}\n\n- (void)setStr:(NSString *)str\n{\n\t_str = [str copy];\n}\n```\n其中 `_str` 就是`实例变量`\n \n### 使用`点语法`访问属性 = 调用 setter/getter 方法\n\n### Property 的4种 attribute\n\t\n+ 原子性(atomic, nonatomic)\n+ 读写权限(readonly, readwrite)\n+ 内存管理(strong, weak, unsafe_unretained, retain, assign, copy)\n+ 存取方法(getter, setter)\n\n### 非 ARC 下，没有 weak\n\n### ARC下，修饰指针的内存修饰符\n+ `__weak`:不retain，如果对象被回收，该指针会被置nil\n+ `__strong`:默认，如果对象被回收，需要手动将指针置为nil？\n+ `__unsafe__unretained`:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）\n+ `__autoreleasing`:实现把对象\"按引用传递\"给方法，变量在方法返回时自动释放\n\n编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量\n\n### 常见数据类型的内存修饰符（待补充）\n| 数据类型 | 内存修饰符 |\n| :--:|:--:|\n| 基本数据类型(int, NSInteger) | assign |\n| block | copy |\n| NSString | copy |\n| NSMutableString | strong |\n| NSArray | copy |\n| NSMutableArray | strong |\n\n### NSArray 用 strong 还是 copy 修饰\n```objc\n//.h\n@property (nonatomic, strong) NSArray *strongArray;\n@property (nonatomic, copy)   NSArray *copyedArray;\n//.m\nself.strongArray = [NSArray array];\nself.copyedArray = [NSArray array];\n    \nNSMutableArray *mutableArray = [@[@\"1\"] mutableCopy];\nself.strongArray = mutableArray;\nself.copyedArray = mutableArray;\n    \n[mutableArray addObject:@\"2\"];\n    \nNSLog(@\"%@\\n%@\\n%@\", mutableArray, self.strongArray, self.copyedArray); //输出 (1,2) (1,2) (1)\n```\n可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。\n\n\n## 第7条：在对象内部尽量直接访问实例变量\n### 类内使用 self.xxx 和 _xxx 的区别\n\n+ 访问 _xxx 不经过 setter/getter 方法，速度更快\n+ 访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作\n+ 访问 _xxx 不经过 setter/getter 方法，无法触发 KVO\n+ 访问 _xxx 不经过 setter/getter 方法，无法断点\n\n### 什么时候使用 _xxx\n\n+ 折中方案，读的时候使用 _xxx，写的时候使用 self.xxx\n+ 父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错\n+ 如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性\n+ 使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败\n```objectivec\n- (NSString *)str\n{\n\tif (!_str)\n\t\t_str = [[NSString alloc] init];\n\treturn _str;\n}\n```\n## 第8条：理解“对象等同性”这一概念 \n\n\n## 第9条：以“类族模式”隐藏实现细节 \n## 第10条：在既有类中使用关联对象存放自定义数据 \n“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性\n\n### 语法\n```objc\nvoid objc_setAssociatedObject (id object, void *key, id value, objc_AssociationPolicy policy);\n\nid objc_getAssociatedObject(id object, void *key);\n\nvoid objc_removeAssociatedObject(id object);    // 移除object上的所有关联对象\n```\n其中 objc_AssociationPolicy 是关联对象的属性，如下\n\n```objc\nOBJC_ASSOCIATION_ASSIGN             --- assign\nOBJC_ASSOCIATION_RETAIN_NONATOMIC   --- nonatomic, retain\nOBJC_ASSOCIATION_COPY_NONATOMIC     --- nonatomic, copy\nOBJC_ASSOCIATION_RETAIN             --- retain\nOBJC_ASSOCIATION_COPY               --- copy\n```\n\n### 与 NSDictionary 的区别\n设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。\n\n所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @\"xxx\"\n\n### 例子1\n假如一个页面有2个弹窗，那么代码可能是这样写\n\n```objc\n- (void)askUserAQuestion\n{\n    UIAlertView *alert = [[UIAlertView alloc]\n            initWithTitle:@\"Question\"\n                  message:@\"What do you want to do?\"\n                 delegate:self\n        cancelButtonTitle:@\"Cancel\"\n        otherButtonTitles:@\"Continue\", nil];\n    [alert show];\n}\n\n// UIAlertViewDelegate protocol method\n- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n    if (buttonIndex == 0)\n    {\n        [self doCancel];\n    }\n    else\n    {\n        [self doContinue];\n    }\n}\n```\n\n缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性\n\n```objc\n#import <objc/runtime.h>\n\nstatic void *EOCMyAlertViewKey = \"EOCMyAlertViewKey\";\n\n- (void)askUserAQuestion\n{\n\tUIAlertView *alert = [[UIAlertView alloc]\n\t        initWithTitle:@\"Question\"\n\t              message:@\"What do you want to do?\"\n\t             delegate:self\n\t    cancelButtonTitle:@\"Cancel\"\n\t    otherButtonTitles:@\"Continue\", nil];\n\n\tvoid (^block)(NSInteger) = ^(NSInteger buttonIndex) {\n\t    if (buttonIndex == 0)\n\t    {\n\t\t    [self doCancel];\n\t    }\n\t    else\n\t    {\n\t\t    [self doContinue];\n\t    }\n\t};\n\n\tobjc_setAssociatedObject(alert,\n                             EOCMyAlertViewKey,\n                             block,\n                             OBJC_ASSOCIATION_COPY);\n\n\t[alert show];\n}\n\n// UIAlertViewDelegate protocol method\n- (void)alertView:(UIAlertView *)alertView\n    clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n\tvoid (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);\n\tblock(buttonIndex);\n}\n```\n\n优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView\n\n### 例子2 为协议文件添加属性\n.h\n\n```objc\n#import \"QLJCEONAVRSSFeed.h\"\n\n@interface QLJCEONAVRSSFeed (contentOffset)\n\n@property (nonatomic, assign)CGPoint savedOffset;\n\n@end\n```\n.m\n\n```objc\n#import \"QLJCEONAVRSSFeed+contentOffset.h\"\n\n#define feed_saved_Off_set_x_key @\"feed_saved_Off_set_x_key\"\n#define feed_saved_Off_set_y_key @\"feed_saved_Off_set_y_key\"\n\n@implementation QLJCEONAVRSSFeed (contentOffset)\n\n@dynamic savedOffset;\n\n- (CGPoint)savedOffset\n{\n    NSNumber *xObj = objc_getAssociatedObject(self, feed_saved_Off_set_x_key);\n    NSNumber *yObj = objc_getAssociatedObject(self, feed_saved_Off_set_y_key);\n    \n    CGPoint point = CGPointMake([xObj floatValue], [yObj floatValue]);\n    \n    return point;\n}\n\n- (void)setSavedOffset:(CGPoint)savedOffset\n{\n    objc_setAssociatedObject(self, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    objc_setAssociatedObject(self, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n```\n\n\n## 第11条：理解objc_msgSend的作用\n见 [Objective-C中的消息转发机制](http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/)\n## 第12条：理解消息转发机制\n见 [Objective-C中的消息转发机制](http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/)\n\n \n## 第13条：用“方法调配技术”调试“黑盒方法”\n创建自己的方法\n\n```objc\n#import \"NSString+MyAdditions.h\"\n\n@implementation NSString (MyAdditions)\n- (NSString *)myLowercaseString\n{\n    NSString *lowercase = [self myLowercaseString];\n    NSLog(@\"This is my own method: %@\", lowercase);\n    return lowercase;\n}\n@end\n```\n替换\n\n```objc\nMethod originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));\nMethod swappedMethod = class_getInstanceMethod([NSString class], @selector(myLowercaseString));\nmethod_exchangeImplementations(originalMethod, swappedMethod);\n```\n\n \n## 第14条：理解“类对象”的用意 \n### 我们所说的 Objective-C 对象究竟是什么\n\n```objc\ntypedef struct objc_object{\n  Class isa;  //=> 指向对象所属的类\n} *id;\n```\n结论：Objective-C 对象 = id = objc_object\n\n### 那么 Class 是什么\n```objc\ntypedef struct objc_class *Class;  \n```\n### 那么 objc_class 又是什么\n```objc\nstruct objc_class {  \n    Class isa;\n    Class super_class;  \n    const char *name;  \n    long version;  \n    long info;  \n    long instance_size;  \n    struct objc_ivar_list *ivars;  \n    struct objc_method_list **methodLists;  \n    struct objc_cache *cache;  \n    struct objc_protocol_list *protocols;  \n}; \n```\n\n### 类的继承体系\n![](http://7xsd8c.com1.z0.glb.clouddn.com/isa.png)\n\n```objc\nNSString *str = @\"Hello\";\n```\nstr 是一个对象，is a NSString\n\nNSString 是类，is a NSString metaclass\n\nNSString metaclass 是元类，类方法就定义在这里\n\n\n# 第3章 接口与API设计 \n## done 第15条：用前缀避免命名空间冲突 \n## done 第16条：提供“全能初始化方法”\n详见[Designated Initializer](http://www.cnblogs.com/chenyg32/p/4870303.html)\n## done 第17条：实现description方法\n## done 第18条：尽量使用不可变对象\n+ 如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite\n+ 不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法\n\n## done 第19条：使用清晰而协调的命名方式:\n### 如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了\n\n### 对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX\n    @property (nonatomic, assign, getter = isOn) on;\n\n## done 第20条：为私有方法名加前缀 \n## done 第21条：理解Objective—C错误模型 \n## done 第22条：理解NSCopying协议 \n详见[浅析Objective-C的copy](http://www.cnblogs.com/chenyg32/p/5167194.html)\n \n# 第4章 协议与分类 \n## 第23条：通过委托与数据源协议进行对象间通信 \n```objc\nif([_delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)])\n{ \n    [_delegate networkFetcher:self didReceiveData:data];  \n}\n```\n\n如果上面的代码写了很多次，则可以考虑以下优化：\n\n```objc\n// 在扩展中定义结构体\n@interface EOCNetworkFetcher(\n{ \n    struct { \n    unsigned int didReceiveData : 1; \n    unsigned int didFailWithError : 1; \n    } _delegateFlags; \n} \n@end  \n\n@implementation \nEOCNetworkFetcher \n- (void)setDelegate:(id)delegate\n{ \n    _delegate = delegate; // 缓存委托对象相应方法能力 \n    _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]; \n    _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)]; \n} \n@end\n\n这样每次调用delegate相关方法之前就只需要直接查询标志：\nif(_delegateFlags.didReceiveData)\n{ \n    [_delegate networkFetcher:self didReceiveData:data]; \n}\n```\n\n## done 第24条：将类的实现代码分散到便于管理的数个分类之中 \n## 第25条：总是为第三方类的分类名称加前缀\n1. 为第三方类添加分类时，总应给其名称加上你专用的前缀\n2. 为第三方类添加分类时，总应给方法名加上你专用的前缀\n\n```objc\n@interface NSString (ABC_HTTP)\n-(NSString *)abc_urlEncodedString;\n-(NSString *)abc_urlDecodedString;\n@end\n```\n\n## 第26条：勿在分类中声明属性 \n属性应该在主类中声明\n\n如果分类中声明属性需要自己重写 setter 和 getter\n\n方法如下：\n```objc\n#import <objc/runtime.h>\n\nstatic const char *kFriendsPropertyKey = \"kFriendsPropertyKey\";\n\n@implementation Person(Friendship)\n@dynamic friends;\n\n-(NSArray*)friends \n{\n　　return objc_getAssociatedObject(self, kFriendsPropertyKey);\n}\n\n-(void)setFriends:(NSArray*)friends \n{\n　　objc_setAssociaedObject(self, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);\n}\n@end\n```\n\n缺点如下\n1. 相似的代码要写很多遍\n2. 极易忽略属性定义的内存管理语义，且不好维护\n\n## 第27条：使用“class—continuation分类”隐藏实现细节\n声明私有实例变量的3种方法\n\n+ 方法1：对外暴露，声明为 private（暴露了细节，不建议）\n\n    .h\n\n    ```objectivec\n    @interface ABC:NSObject\n    {\n    @private\n        XYZ *_xyz;\n    }\n    @end\n    ```\n    1. 把私有变量放在头文件，暴露了细节，不好\n    2. 假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题\n    3. 所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？\n    \n    \n+ 方法2：不对外暴露\n\n    .m\n    \n    ```objectivec\n    @interface ABC()\n    {\n        XYZ *_xyz;\n    }\n    @property (nonatomic, strong) XYZ *xyz2;\n    @end\n    ```\n+ 方法3：对外只读，对内读写\n\n    .h\n    \n    ```objectivec\n    @property (nonatomic, readonly) XYZ *xyz;\n    ```\n    .m\n    \n    ```objectivec\n    @interface ABC()\n    @property (nonatomic, readwrite) XYZ *xyz;\n    @end\n    ```\n\n## done 第28条：通过协议提供匿名对象 \n\n# 第5章 内存管理 \n## 第29条：理解引用计数 \n### 悬浮指针\n\n```objectivec\nNSNumber *number = [[NSNumber alloc] initWithInt:1];\n[array addObject:number];\n[number release];\nnumber = nil;   //如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知\n```\n\n### autorelease\n\n```objectivec\n- (NSString *)stringValue\n{\n    NSString *str = [[NSString alloc] initWithFormat:@\"Hello\"];\n    return str;\n}\n```\n这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放\n\n但是，这是十分不合理的，因为从方法名上看（不含`alloc/new/copy/mutableCopy`），调用者并不知道它需要负责释放该对象\n\n所以此时，autorelease 就应运而生了\n\n```objectivec\n- (NSString *)stringValue\n{\n    NSString *str = [[NSString alloc] initWithFormat:@\"Hello\"];\n    return [str autorelease];\n}\n```\n\nstr 对象会在其所在的释放池释放的时候被释放\n\n如果外部需要 retain 该返回值，则需要这样做\n\n```objectivec\nNSString *str = [[self stringValue] retain];\n// ...\n[str release];\n```\n\n> autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间\n\n## 第30条：以ARC简化引用计数\n### ARC 的本质是自动添加 release/retian/autorelease 等\n```objectivec\n+ (XYZ *)newXYZ\n{\n    XYZ *xyz = [[XYZ alloc] init];\n    return xyz;\n}\n\n+ (XYZ *)createXYZ\n{\n    XYZ *xyz = [[XYZ alloc] init];\n    /*ARC自动添加\n    xyz = [xyz autorelease];\n     */\n    return xyz;\n}\n\n- (void)f\n{\n    XYZ *xyz1 = [XYZ newXYZ];\n    XYZ *xyz2 = [XYZ createXYZ];\n    /*ARC自动添加\n    [xyz1 release];\n     */\n}\n```\n\n### 扩展阅读：[iOS开发ARC内存管理技术要点](http://www.cnblogs.com/flyFreeZn/p/4264220.html)\n\n## done 第31条：在dealloc方法中只释放引用并解除监听 \n## done 第32条：编写“异常安全代码”时留意内存管理问题 \n```objc\n@try {\n EOCSomeClass *object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];\n [object release];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏\n\n解决方法：\n\n```objc\nEOCSomeClass *object;\n@try {\n object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n@finally {\n [object release];\n}\n```\n\n同理，ARC 下也会发生这个问题\n\n```objc\n@try {\n EOCSomeClass *object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题\n\n总结：\n\n1. 当捕获到异常,应该注意确保@try中创建的对象被清理完成.\n2. ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.\n\n\n## done 第33条：以弱引用避免保留环 \n## done 第34条：以“自动释放池块”降低内存峰值 \n\nARC下，可以使用 @autoreleasepool 来降低内存峰值\n\n```objc\nfor (int i = 0; i < 9999; ++i)\n{\n    @autoreleasepool{\n        A *a = [[A alloc] init];\n        [self handle:a];\n    }\n}\n```\n\na 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值\n\n使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有\n```objc\n[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n    // 这里被一个局部@autoreleasepool包围着\n}];\n```\n\n另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用\n\n另外，关于降低内存峰值的之前也有学习过，见[Objective-C 内存管理](http://www.cnblogs.com/chenyg32/p/3859110.html)\n## done 第35条：用“僵尸对象”调试内存管理问题 \n僵尸对象是调试内存管理问题的最佳方式\n\n被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。\n\n打开僵尸对象的方法：\n\nXcode -> Run -> Diagnostics -> Enable Zombie Objects\n![](http://img.blog.csdn.net/20150803102818758)\n\n\n僵尸对象的原理：\n\n替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存\n\n原理代码：\n\n```objc\n// Obtain the class of the object being deallocated\nClass cls = object_getClass(self);\n\n// Get the class's name\nconst char *clsName = class_getName(cls);\n\n// Prepend _NSZombie_ to the class name\nconst char *zombieClsName = @\"_NSZombie_\" + clsName;\n\n// See if the specific zombie class exists\nClass zombieCls = objc_lookUpClass(zombieClsName);\n\n// If the specific zombie class doesn't exists,\n// then it needs to be created\n\nif(!zombieCls){\n// Obtain the template  zombie class, where the new class's \n// name is the prepended string from above\n   zombieCls = objc_duplicateClass(baseZombieCls,   \n   zombieClsName,0);\n}\n\n// Perform normal destruction of the object being deallocated\nobjc_destructInstance(self);\n\n// Set the class of the object being deallocated\n// to the zombie class\nobjc_setClass(self, zombieCls) \n\n// The class of \"self\" is now _NSZombie_OriginalClass\n```\n\n## done 第36条：不要使用retainCount \n \n# 第6章 块与大中枢派发 \n## done 第37条：理解“块”这一概念 \n\n\t在Objective-C语言中，一共有3种类型的block：\n\t_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。\n\t_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。\n\t_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。\n\n+ 全局 Block：_NSConcreteGlobalBlock\n\n    + 定义在函数外面的 block 是全局静态的，没有访问任何外部变量\n    + 定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的\n\n\t问题：那么定义在函数外部的，捕获变量的，是 global 吗？\n\n\t```objc\n\tvoid f()\n\t{\n\t    ^{ printf(\"Hello, World!\\n\"); } ();\n\t}\n\t```\n\n+ 栈 Block：_NSConcreteStackBlock\n\n\t```objc\n\tvoid f()\n\t{\n\t    char a = 'A';\n\t    ^{ printf(\"%c\\n\",a); } ();\n\t}\n\t```\n\n+ 堆 Block：_NSConcreteMallocBlock\n\n\tNSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中\n\n\t```objc\n\tvoid f()\n\t{\n\t    char a = 'A';\n\t    void (^block)() = [^{ printf(\"%c\\n\",a); } copy];\n\t}\n\t```\n\n\t\t对全局 Block 进行 copy 后，什么事也不会发生\n\t\t对栈 Block 进行 copy 后，会得到一个堆 Block\n\t\t对堆 Block 进行 copy 后，其引用计数会加1\n\n+ 例子\n\n\t```objc\n\tvoid (^blcok)();\n\tif (1)\n\t{\n\t    block = ^{\n\t        NSLog(@\"Hello\");\n\t    }\n\t}\n\tblock();\n```\n\n\tblock执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放\n\n\t正确做法是\n\n\t```objc\n\tvoid (^blcok)();\n\tif (1)\n\t{\n\t    block = [^{\n\t        NSLog(@\"Hello\");\n\t    } copy];\n\t}\n\tblock();\n\t```\n\n+ 更多细节见[《谈Objective-C block的实现》](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/)\n\n## done 第38条：为常用的块类型创建typedef \n## done 第39条：用handler块降低代码分散程度 \n## 第40条：用块引用其所属对象时不要出现保留环 \n例子1\n\n```objc\n// EOCNetworkFetcher.h\n\n#import <Foundation/Foundation.h>\n\ntypedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);\n\n@interface EOCNetworkFetcher : NSObject\n\n@property (nonatomic, strong, readonly) NSURL *url;\n\n- (id)initWithURL:(NSURL*)url;\n\n- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;\n\n@end\n```\n\n```objc\n// EOCNetworkFetcher.m\n#import \"EOCNetworkFetcher.h\"\n\n@interface EOCNetworkFetcher ()\n@property (nonatomic, strong, readwrite) NSURL *url;\n@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;\n@property (nonatomic, strong) NSData *downloadedData;\n@end\n\n\n@implementation EOCNetworkFetcher\n\n- (id)initWithURL:(NSURL*)url\n{\n\t\tif ((self = [super init])) {\n\t\t\t\t_url = url;\n\t\t}\n\t\treturn self;\n}\n\n- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion\n{\n\t\tself.completionHandler = completion;\n\t\t// Start the request\n\t\t// Request sets downloadedData property\n\t\t// When request is finished, p_requestCompleted is called\n}\n\n- (void)p_requestCompleted {\n\t\tif (_completionHandler) {\n\t\t\t\t_completionHandler(_downloadedData);\n\t\t}\n}\n\n@end\n```\n\n```objc\n@implementation EOCClass\n{\n    EOCNetworkFetcher* _networkFetcher;\n    NSData* _fetchedData;\n}\n\n- (void)downloadData\n{\n    NSURL* url = [[NSURL alloc] initWithString:@\"http://www.example.com/something.dat\"];\n\t\t\n    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];\n\n\t\t[_networkFetcher startWithCompletionHandler:^(NSData *data){\n\n\t\t\t\tNSLog(@\"Request URL %@ finished\", _networkFetcher.url);\n\t\t\t\t_fetchedData = data;\n\n\t\t}];\n}\n@end\n```\n\nEoCClass -> networkFetcher -> block -> self(通过_fetchedData)\n\n例子2\n\n将 networkFetcher 变为局部变量，修改如下：\n\n```objc\n- (void)downloadData {\n NSURL *url = [[NSURL alloc] initWithString:\n @\"http://www.example.com/something.dat\"];\n EOCNetworkFetcher *networkFetcher =\n [[EOCNetworkFetcher alloc] initWithURL:url];\n [networkFetcher startWithCompletionHandler:^(NSData *data){\n NSLog(@\"Request URL %@ finished\", networkFetcher.url);\n _fetchedData = data;\n }];\n}\n```\n\nnetworkFetcher -> block -> networkFetcher(通过url)\n\n## 第41条：多用派发队列，少用同步锁\n \n## 第42条：多用GCD，少用performSelector系列方法\n### 如何延迟执行一个方法\n```objc\n// 方法1：使用 performSelector\n[self performSelector:@selector(foo) withObject:nil afterDelay:5.0];\n\n// 方法2：使用 dispatch_after\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    [self foo];\n});\n```\n使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题\n\n当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消\n\n\n### 如何让一个方法在主线程执行\n```objc\n// 方法1：使用 performSelector\n[self performSelectorOnMainThread:@selector(foo) withObject:nil waitUntilDone:NO];\n\n// 方法2：使用 dispatch_after\ndispatch_async(dispatch_get_main_queue(), ^{\n    [self foo];\n});\n```\n使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题\n \n## 第43条：掌握GCD及操作队列的使用时机\n要知道有个东西叫做 NSOperationQueue 就行了\n## 第44条：通过Dispatch Group机制，根据系统资源状况来执行任务 \n## 第45条：使用dispatch_once来执行只需运行一次的线程安全代码\n以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once\n\n比如单例的书写方式\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n```\n\n \n## 第46条：不要使用`dispatch_get_current_queue`\n尽量别用，该接口已废弃\n \n# 第7章 系统框架 \n## 第47条：熟悉系统框架\n+ CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）\n+ CoreAudio:音频处理 API（C语言）\n+ AVFoundation:视频处理接口（Objective-C）\n+ CoreData:数据库接口（Objective-C）\n+ CoreText:文字渲染排版接口（C语言）\n \n## done 第48条：多用块枚举，少用for循环\n\n## 第49条：对自定义其内存管理语义的collection使用无缝桥接 \n### 使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge CFArrayRef)array;\nNSLog(@\"%@ count: %li\", cfArray, CFArrayGetCount(cfArray));\n```\n+ NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray\n+ CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数\n\n### 桥式转换\n+ `__bridge`：只做类型转换，不修改对象（内存）管理权；\n+ `__bridge_retained`：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；\n+ `__bridge_transfer`：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC\n\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge_retained CFArrayRef)array;\nCFRelease(cfArray);  // 因为是 __bridge_retained，所以需要调用 CFRelease\n```\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge_retained CFArrayRef)array;\nNSArray *array2 = (__bridge_transfer NSArray *)cfArray;\n//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理\n```\n\n### 使用无缝桥接修改 Collection 的内存管理语义\nNSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error\n\n关于拷贝协议可以查看：[浅析Objective-C的copy](http://www.cnblogs.com/chenyg32/p/5167194.html)\n\n无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典\n\n创建函数\n\n```objc\nCFMutableDictionaryRef CFDictionaryCreateMutable(\n    CFAllocatorRef allocator,  // 一般传NULL，采用系统默认的内存分配器\n    CFIndex capacity,          // 初始大小，并非最大容量\n    const CFDictionaryKeyCallBacks *keyCallBacks,    // 回调\n    const CFDictionaryValueCallBacks *valueCallBacks // 回调\n);\n```\n\n键值回调\n\n```objc\ntypedef struct {\n    CFIndex\t\t\t\tversion;    //一般为0\n    CFDictionaryRetainCallBack\t\tretain; //遇到retain的回调\n    CFDictionaryReleaseCallBack\t\trelease;//遇到release的回调\n    CFDictionaryCopyDescriptionCallBack\tcopyDescription;//一般传NULL，采用系统默认\n    CFDictionaryEqualCallBack\t\tequal;  //一般传CFEqual\n    CFDictionaryHashCallBack\t\thash;   //一般传CFHash\n} CFDictionaryKeyCallBacks;\n\ntypedef struct {\n    CFIndex\t\t\t\tversion;    //一般为0\n    CFDictionaryRetainCallBack\t\tretain; //遇到retain的回调\n    CFDictionaryReleaseCallBack\t\trelease;//遇到release的回调\n    CFDictionaryCopyDescriptionCallBack\tcopyDescription;    //一般传NULL，采用系统默认\n    CFDictionaryEqualCallBack\t\tequal;  //一般传CFEqual\n} CFDictionaryValueCallBacks;\n```\n\n创建“保留”键，“保留”值的 NSDictionary\n\n```objc\nconst void* EOCRetainCallback (CFAllocatorRef allocator , const void *value)\n{\n    return CFRetain(value);\n}\n\nvoid EOCReleaseCallback(CFAllocatorRef allocator , const void *value)\n{\n    CFRelease(value);\n}\n\nCFDictionaryKeyCallBacks keyCallbacks = \n{\n    0,\n    EOCRetainCallback,\n    EOCReleaseCallback,\n    NULL,\n    CFEqual,\n    CFHash\n};\n\nCFDictionaryValueCallBacks valueCallbacks = \n{\n    0,\n    EOCRetainCallback,\n    EOCReleaseCallback,\n    NULL,\n    CFEqual,\n};\n    \nCFMutableDictionaryRef aCFDictionary = CFDictionaryCreateMutable(NULL, 0, &keyCallbacks, &valueCallbacks);\nNSMutableDictionary *anNSdictionary = (__bridge_transfer NSMutableDictionary *)aCFDictionary;\n```\n\n## 第50条：构建缓存时选用NSCache而非NSDictionary \n+ 实现缓存时应选用 NSCache 而非 NSDictionary\n+ 可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据\n+ NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）\n+ NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）\n+ 使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除\n\n扩展阅读：[利用NSCache提升效率](https://www.ganlvji.com/nscache/)\n\n## 第51条：精简initialize与load的实现代码\n|           | load  | initialize |\n| :--: |:--:| :-:|\n| 执行次数   | 1次 | 1次 |\n| 执行时机   | app启动时所有运行时需要用到的类 | 惰性调用，需要使用到具体类的时候才调用 |\n| 作用      | 调试 现基本不用 |初始化全局oc对象（普通对象可以在声明的时候初始化）|\n| 执行时环境 | 系统不稳定，许多东西尚未初始化 | 系统处于正常状态 |\n| 调用顺序   | 1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类 | 跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名 |\n| 相同点    | 1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁| 同左 |\n\n### initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\n假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：\n```objc\n@interface A : NSObject\n@end\n@implementation A\n+ (void)initialize\n{\n    NSLog(@\"%@\", self);\n}\n@end\n\n@interface B : A\n@end\n@implementation B\n@end\n```\n此时创建一个B对象，输出是\n> A  \n> B\n\n初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B\n\n所以 A 的 initialize 方法应该这样写\n\n```objc\n+ (void)initialize\n{\n    if (self == [A class])\n    {\n        NSLog(@\"%@\", self);\n    }\n}\n```\n此时创建一个B对象，输出是\n> B\n\n## 第52条：别忘了NSTimer会保留其目标对象\n参见：[NSTimer 会保留目标对象](http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/)","source":"_posts/Effective-Objective-C-读书笔记.md","raw":"---\ntitle: Effective-Objective-C-读书笔记\ndescription: 《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》\ndate: 2016-03-19\ncategories:\n- 读书笔记\nphotos: \n---\n\n# 第1章 熟悉Objective—C \n## 第1条：了解Objective—C语言的起源\n```objectivec\nNSString *s1 = @\"Hello\";\nNSString *s2 = s1;\n```\n+ s1 和s2 的内存分配在栈上\n+ @\"Hello\"的内存分配在堆上\n+ s1 和 s2 指向同一块内存\n\n\n## 第2条：在类的头文件中尽量少引入其他头文件\n\n## 第3条：多用字面量语法，少用与之等价的方法\n### 使用字面量语法，它是一种语法糖：\n```objectivec\nNSString *str = @\"Hello\";\nNSNumber *intNum = @1;\nNSNumber *doubleNum = @2.5;\nNSNumber *charNum = @'a';\nNSNumber *boolNum = @YES;\nNSArray *array = @[@\"hello\", @1, @2.5, @'a'];\nNSString *str2 = array[0];\nNSDictionary *dic = @{@\"1\":@1, @\"2\":@2};\n```\n### 这个语法糖更容易暴露隐藏的问题\n```objectivec\nNSArray *array1 = [NSArray arrayWithObjects: obj1, obj2, obj3, nil];\nNSArray *array2 = @[obj1, obj2, obj3];\n```\n如果 obj1 和 obj3 非空，而 obj2 是 nil\n\n那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常\n\n### 使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\n```objectivec\nNSMuatableArray *mArray = [@[@1, @2] mutableCopy];\n```\n## 第4条：多用类型常量，少用#define预处理指令 \n详见[NSNotification Name 最佳写法](http://www.cnblogs.com/chenyg32/p/5080301.html)\n\n## 第5条：用枚举表示状态、选项、状态码\n### 使用 `NS_ENUM` 和 `NS_OPTIONS` 来表示`状态机`，\n```objectivec\n//NS_ENUM，定义状态等普通枚举\ntypedef NS_ENUM(NSUInteger, TTGState) {\n    TTGStateOK = 0,\n    TTGStateError,\n    TTGStateUnknow\n};\n\n//NS_OPTIONS，定义选项\ntypedef NS_OPTIONS(NSUInteger, TTGDirection) {\n    TTGDirectionNone = 0,\n    TTGDirectionTop = 1 << 0,\n    TTGDirectionLeft = 1 << 1,\n    TTGDirectionRight = 1 << 2,\n    TTGDirectionBottom = 1 << 3\n};\n```\n### 如果一个`枚举变量`可以同时表示一个或多个选项的集合，那么应当使用 `NS_OPTIONS`，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用`或操作`将其组合起来进行表示\n\n### 相比较 C 语言中的枚举，使用 `NS_ENUM` 和 `NS_OPTIONS` 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\n```objectivec\ntypedef enum _TTGState {\n    TTGStateOK  = 0,\n    TTGStateError,\n    TTGStateUnknow\n} TTGState;\n```\n### 处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举\n\n### 参考链接：[Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5](http://tutuge.me/2015/03/21/effective-objective-c-5-enum/)\n\n# 第2章 对象、消息、运行期 \n## 第6条：理解“属性”这一概念 \n### 理解好`属性`和`实例变量`的区别\n\n属性 = 实例变量 + setter + getter\n\n如果声明属性\n\n    @property (nonatomic, copy) NSString *str;\n\n则编译器会默认实现\n\n```objectivec\n//.h\n- (NSString *)str;\n- (void)setStr:(NSString *)str;\n\n//.m\n- (NSString *)str\n{\n\treturn _str;\n}\n\n- (void)setStr:(NSString *)str\n{\n\t_str = [str copy];\n}\n```\n其中 `_str` 就是`实例变量`\n \n### 使用`点语法`访问属性 = 调用 setter/getter 方法\n\n### Property 的4种 attribute\n\t\n+ 原子性(atomic, nonatomic)\n+ 读写权限(readonly, readwrite)\n+ 内存管理(strong, weak, unsafe_unretained, retain, assign, copy)\n+ 存取方法(getter, setter)\n\n### 非 ARC 下，没有 weak\n\n### ARC下，修饰指针的内存修饰符\n+ `__weak`:不retain，如果对象被回收，该指针会被置nil\n+ `__strong`:默认，如果对象被回收，需要手动将指针置为nil？\n+ `__unsafe__unretained`:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）\n+ `__autoreleasing`:实现把对象\"按引用传递\"给方法，变量在方法返回时自动释放\n\n编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量\n\n### 常见数据类型的内存修饰符（待补充）\n| 数据类型 | 内存修饰符 |\n| :--:|:--:|\n| 基本数据类型(int, NSInteger) | assign |\n| block | copy |\n| NSString | copy |\n| NSMutableString | strong |\n| NSArray | copy |\n| NSMutableArray | strong |\n\n### NSArray 用 strong 还是 copy 修饰\n```objc\n//.h\n@property (nonatomic, strong) NSArray *strongArray;\n@property (nonatomic, copy)   NSArray *copyedArray;\n//.m\nself.strongArray = [NSArray array];\nself.copyedArray = [NSArray array];\n    \nNSMutableArray *mutableArray = [@[@\"1\"] mutableCopy];\nself.strongArray = mutableArray;\nself.copyedArray = mutableArray;\n    \n[mutableArray addObject:@\"2\"];\n    \nNSLog(@\"%@\\n%@\\n%@\", mutableArray, self.strongArray, self.copyedArray); //输出 (1,2) (1,2) (1)\n```\n可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。\n\n\n## 第7条：在对象内部尽量直接访问实例变量\n### 类内使用 self.xxx 和 _xxx 的区别\n\n+ 访问 _xxx 不经过 setter/getter 方法，速度更快\n+ 访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作\n+ 访问 _xxx 不经过 setter/getter 方法，无法触发 KVO\n+ 访问 _xxx 不经过 setter/getter 方法，无法断点\n\n### 什么时候使用 _xxx\n\n+ 折中方案，读的时候使用 _xxx，写的时候使用 self.xxx\n+ 父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错\n+ 如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性\n+ 使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败\n```objectivec\n- (NSString *)str\n{\n\tif (!_str)\n\t\t_str = [[NSString alloc] init];\n\treturn _str;\n}\n```\n## 第8条：理解“对象等同性”这一概念 \n\n\n## 第9条：以“类族模式”隐藏实现细节 \n## 第10条：在既有类中使用关联对象存放自定义数据 \n“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性\n\n### 语法\n```objc\nvoid objc_setAssociatedObject (id object, void *key, id value, objc_AssociationPolicy policy);\n\nid objc_getAssociatedObject(id object, void *key);\n\nvoid objc_removeAssociatedObject(id object);    // 移除object上的所有关联对象\n```\n其中 objc_AssociationPolicy 是关联对象的属性，如下\n\n```objc\nOBJC_ASSOCIATION_ASSIGN             --- assign\nOBJC_ASSOCIATION_RETAIN_NONATOMIC   --- nonatomic, retain\nOBJC_ASSOCIATION_COPY_NONATOMIC     --- nonatomic, copy\nOBJC_ASSOCIATION_RETAIN             --- retain\nOBJC_ASSOCIATION_COPY               --- copy\n```\n\n### 与 NSDictionary 的区别\n设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。\n\n所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @\"xxx\"\n\n### 例子1\n假如一个页面有2个弹窗，那么代码可能是这样写\n\n```objc\n- (void)askUserAQuestion\n{\n    UIAlertView *alert = [[UIAlertView alloc]\n            initWithTitle:@\"Question\"\n                  message:@\"What do you want to do?\"\n                 delegate:self\n        cancelButtonTitle:@\"Cancel\"\n        otherButtonTitles:@\"Continue\", nil];\n    [alert show];\n}\n\n// UIAlertViewDelegate protocol method\n- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n    if (buttonIndex == 0)\n    {\n        [self doCancel];\n    }\n    else\n    {\n        [self doContinue];\n    }\n}\n```\n\n缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性\n\n```objc\n#import <objc/runtime.h>\n\nstatic void *EOCMyAlertViewKey = \"EOCMyAlertViewKey\";\n\n- (void)askUserAQuestion\n{\n\tUIAlertView *alert = [[UIAlertView alloc]\n\t        initWithTitle:@\"Question\"\n\t              message:@\"What do you want to do?\"\n\t             delegate:self\n\t    cancelButtonTitle:@\"Cancel\"\n\t    otherButtonTitles:@\"Continue\", nil];\n\n\tvoid (^block)(NSInteger) = ^(NSInteger buttonIndex) {\n\t    if (buttonIndex == 0)\n\t    {\n\t\t    [self doCancel];\n\t    }\n\t    else\n\t    {\n\t\t    [self doContinue];\n\t    }\n\t};\n\n\tobjc_setAssociatedObject(alert,\n                             EOCMyAlertViewKey,\n                             block,\n                             OBJC_ASSOCIATION_COPY);\n\n\t[alert show];\n}\n\n// UIAlertViewDelegate protocol method\n- (void)alertView:(UIAlertView *)alertView\n    clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n\tvoid (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);\n\tblock(buttonIndex);\n}\n```\n\n优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView\n\n### 例子2 为协议文件添加属性\n.h\n\n```objc\n#import \"QLJCEONAVRSSFeed.h\"\n\n@interface QLJCEONAVRSSFeed (contentOffset)\n\n@property (nonatomic, assign)CGPoint savedOffset;\n\n@end\n```\n.m\n\n```objc\n#import \"QLJCEONAVRSSFeed+contentOffset.h\"\n\n#define feed_saved_Off_set_x_key @\"feed_saved_Off_set_x_key\"\n#define feed_saved_Off_set_y_key @\"feed_saved_Off_set_y_key\"\n\n@implementation QLJCEONAVRSSFeed (contentOffset)\n\n@dynamic savedOffset;\n\n- (CGPoint)savedOffset\n{\n    NSNumber *xObj = objc_getAssociatedObject(self, feed_saved_Off_set_x_key);\n    NSNumber *yObj = objc_getAssociatedObject(self, feed_saved_Off_set_y_key);\n    \n    CGPoint point = CGPointMake([xObj floatValue], [yObj floatValue]);\n    \n    return point;\n}\n\n- (void)setSavedOffset:(CGPoint)savedOffset\n{\n    objc_setAssociatedObject(self, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    objc_setAssociatedObject(self, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n```\n\n\n## 第11条：理解objc_msgSend的作用\n见 [Objective-C中的消息转发机制](http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/)\n## 第12条：理解消息转发机制\n见 [Objective-C中的消息转发机制](http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/)\n\n \n## 第13条：用“方法调配技术”调试“黑盒方法”\n创建自己的方法\n\n```objc\n#import \"NSString+MyAdditions.h\"\n\n@implementation NSString (MyAdditions)\n- (NSString *)myLowercaseString\n{\n    NSString *lowercase = [self myLowercaseString];\n    NSLog(@\"This is my own method: %@\", lowercase);\n    return lowercase;\n}\n@end\n```\n替换\n\n```objc\nMethod originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));\nMethod swappedMethod = class_getInstanceMethod([NSString class], @selector(myLowercaseString));\nmethod_exchangeImplementations(originalMethod, swappedMethod);\n```\n\n \n## 第14条：理解“类对象”的用意 \n### 我们所说的 Objective-C 对象究竟是什么\n\n```objc\ntypedef struct objc_object{\n  Class isa;  //=> 指向对象所属的类\n} *id;\n```\n结论：Objective-C 对象 = id = objc_object\n\n### 那么 Class 是什么\n```objc\ntypedef struct objc_class *Class;  \n```\n### 那么 objc_class 又是什么\n```objc\nstruct objc_class {  \n    Class isa;\n    Class super_class;  \n    const char *name;  \n    long version;  \n    long info;  \n    long instance_size;  \n    struct objc_ivar_list *ivars;  \n    struct objc_method_list **methodLists;  \n    struct objc_cache *cache;  \n    struct objc_protocol_list *protocols;  \n}; \n```\n\n### 类的继承体系\n![](http://7xsd8c.com1.z0.glb.clouddn.com/isa.png)\n\n```objc\nNSString *str = @\"Hello\";\n```\nstr 是一个对象，is a NSString\n\nNSString 是类，is a NSString metaclass\n\nNSString metaclass 是元类，类方法就定义在这里\n\n\n# 第3章 接口与API设计 \n## done 第15条：用前缀避免命名空间冲突 \n## done 第16条：提供“全能初始化方法”\n详见[Designated Initializer](http://www.cnblogs.com/chenyg32/p/4870303.html)\n## done 第17条：实现description方法\n## done 第18条：尽量使用不可变对象\n+ 如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite\n+ 不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法\n\n## done 第19条：使用清晰而协调的命名方式:\n### 如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了\n\n### 对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX\n    @property (nonatomic, assign, getter = isOn) on;\n\n## done 第20条：为私有方法名加前缀 \n## done 第21条：理解Objective—C错误模型 \n## done 第22条：理解NSCopying协议 \n详见[浅析Objective-C的copy](http://www.cnblogs.com/chenyg32/p/5167194.html)\n \n# 第4章 协议与分类 \n## 第23条：通过委托与数据源协议进行对象间通信 \n```objc\nif([_delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)])\n{ \n    [_delegate networkFetcher:self didReceiveData:data];  \n}\n```\n\n如果上面的代码写了很多次，则可以考虑以下优化：\n\n```objc\n// 在扩展中定义结构体\n@interface EOCNetworkFetcher(\n{ \n    struct { \n    unsigned int didReceiveData : 1; \n    unsigned int didFailWithError : 1; \n    } _delegateFlags; \n} \n@end  \n\n@implementation \nEOCNetworkFetcher \n- (void)setDelegate:(id)delegate\n{ \n    _delegate = delegate; // 缓存委托对象相应方法能力 \n    _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]; \n    _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)]; \n} \n@end\n\n这样每次调用delegate相关方法之前就只需要直接查询标志：\nif(_delegateFlags.didReceiveData)\n{ \n    [_delegate networkFetcher:self didReceiveData:data]; \n}\n```\n\n## done 第24条：将类的实现代码分散到便于管理的数个分类之中 \n## 第25条：总是为第三方类的分类名称加前缀\n1. 为第三方类添加分类时，总应给其名称加上你专用的前缀\n2. 为第三方类添加分类时，总应给方法名加上你专用的前缀\n\n```objc\n@interface NSString (ABC_HTTP)\n-(NSString *)abc_urlEncodedString;\n-(NSString *)abc_urlDecodedString;\n@end\n```\n\n## 第26条：勿在分类中声明属性 \n属性应该在主类中声明\n\n如果分类中声明属性需要自己重写 setter 和 getter\n\n方法如下：\n```objc\n#import <objc/runtime.h>\n\nstatic const char *kFriendsPropertyKey = \"kFriendsPropertyKey\";\n\n@implementation Person(Friendship)\n@dynamic friends;\n\n-(NSArray*)friends \n{\n　　return objc_getAssociatedObject(self, kFriendsPropertyKey);\n}\n\n-(void)setFriends:(NSArray*)friends \n{\n　　objc_setAssociaedObject(self, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);\n}\n@end\n```\n\n缺点如下\n1. 相似的代码要写很多遍\n2. 极易忽略属性定义的内存管理语义，且不好维护\n\n## 第27条：使用“class—continuation分类”隐藏实现细节\n声明私有实例变量的3种方法\n\n+ 方法1：对外暴露，声明为 private（暴露了细节，不建议）\n\n    .h\n\n    ```objectivec\n    @interface ABC:NSObject\n    {\n    @private\n        XYZ *_xyz;\n    }\n    @end\n    ```\n    1. 把私有变量放在头文件，暴露了细节，不好\n    2. 假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题\n    3. 所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？\n    \n    \n+ 方法2：不对外暴露\n\n    .m\n    \n    ```objectivec\n    @interface ABC()\n    {\n        XYZ *_xyz;\n    }\n    @property (nonatomic, strong) XYZ *xyz2;\n    @end\n    ```\n+ 方法3：对外只读，对内读写\n\n    .h\n    \n    ```objectivec\n    @property (nonatomic, readonly) XYZ *xyz;\n    ```\n    .m\n    \n    ```objectivec\n    @interface ABC()\n    @property (nonatomic, readwrite) XYZ *xyz;\n    @end\n    ```\n\n## done 第28条：通过协议提供匿名对象 \n\n# 第5章 内存管理 \n## 第29条：理解引用计数 \n### 悬浮指针\n\n```objectivec\nNSNumber *number = [[NSNumber alloc] initWithInt:1];\n[array addObject:number];\n[number release];\nnumber = nil;   //如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知\n```\n\n### autorelease\n\n```objectivec\n- (NSString *)stringValue\n{\n    NSString *str = [[NSString alloc] initWithFormat:@\"Hello\"];\n    return str;\n}\n```\n这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放\n\n但是，这是十分不合理的，因为从方法名上看（不含`alloc/new/copy/mutableCopy`），调用者并不知道它需要负责释放该对象\n\n所以此时，autorelease 就应运而生了\n\n```objectivec\n- (NSString *)stringValue\n{\n    NSString *str = [[NSString alloc] initWithFormat:@\"Hello\"];\n    return [str autorelease];\n}\n```\n\nstr 对象会在其所在的释放池释放的时候被释放\n\n如果外部需要 retain 该返回值，则需要这样做\n\n```objectivec\nNSString *str = [[self stringValue] retain];\n// ...\n[str release];\n```\n\n> autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间\n\n## 第30条：以ARC简化引用计数\n### ARC 的本质是自动添加 release/retian/autorelease 等\n```objectivec\n+ (XYZ *)newXYZ\n{\n    XYZ *xyz = [[XYZ alloc] init];\n    return xyz;\n}\n\n+ (XYZ *)createXYZ\n{\n    XYZ *xyz = [[XYZ alloc] init];\n    /*ARC自动添加\n    xyz = [xyz autorelease];\n     */\n    return xyz;\n}\n\n- (void)f\n{\n    XYZ *xyz1 = [XYZ newXYZ];\n    XYZ *xyz2 = [XYZ createXYZ];\n    /*ARC自动添加\n    [xyz1 release];\n     */\n}\n```\n\n### 扩展阅读：[iOS开发ARC内存管理技术要点](http://www.cnblogs.com/flyFreeZn/p/4264220.html)\n\n## done 第31条：在dealloc方法中只释放引用并解除监听 \n## done 第32条：编写“异常安全代码”时留意内存管理问题 \n```objc\n@try {\n EOCSomeClass *object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];\n [object release];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏\n\n解决方法：\n\n```objc\nEOCSomeClass *object;\n@try {\n object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n@finally {\n [object release];\n}\n```\n\n同理，ARC 下也会发生这个问题\n\n```objc\n@try {\n EOCSomeClass *object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题\n\n总结：\n\n1. 当捕获到异常,应该注意确保@try中创建的对象被清理完成.\n2. ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.\n\n\n## done 第33条：以弱引用避免保留环 \n## done 第34条：以“自动释放池块”降低内存峰值 \n\nARC下，可以使用 @autoreleasepool 来降低内存峰值\n\n```objc\nfor (int i = 0; i < 9999; ++i)\n{\n    @autoreleasepool{\n        A *a = [[A alloc] init];\n        [self handle:a];\n    }\n}\n```\n\na 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值\n\n使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有\n```objc\n[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n    // 这里被一个局部@autoreleasepool包围着\n}];\n```\n\n另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用\n\n另外，关于降低内存峰值的之前也有学习过，见[Objective-C 内存管理](http://www.cnblogs.com/chenyg32/p/3859110.html)\n## done 第35条：用“僵尸对象”调试内存管理问题 \n僵尸对象是调试内存管理问题的最佳方式\n\n被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。\n\n打开僵尸对象的方法：\n\nXcode -> Run -> Diagnostics -> Enable Zombie Objects\n![](http://img.blog.csdn.net/20150803102818758)\n\n\n僵尸对象的原理：\n\n替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存\n\n原理代码：\n\n```objc\n// Obtain the class of the object being deallocated\nClass cls = object_getClass(self);\n\n// Get the class's name\nconst char *clsName = class_getName(cls);\n\n// Prepend _NSZombie_ to the class name\nconst char *zombieClsName = @\"_NSZombie_\" + clsName;\n\n// See if the specific zombie class exists\nClass zombieCls = objc_lookUpClass(zombieClsName);\n\n// If the specific zombie class doesn't exists,\n// then it needs to be created\n\nif(!zombieCls){\n// Obtain the template  zombie class, where the new class's \n// name is the prepended string from above\n   zombieCls = objc_duplicateClass(baseZombieCls,   \n   zombieClsName,0);\n}\n\n// Perform normal destruction of the object being deallocated\nobjc_destructInstance(self);\n\n// Set the class of the object being deallocated\n// to the zombie class\nobjc_setClass(self, zombieCls) \n\n// The class of \"self\" is now _NSZombie_OriginalClass\n```\n\n## done 第36条：不要使用retainCount \n \n# 第6章 块与大中枢派发 \n## done 第37条：理解“块”这一概念 \n\n\t在Objective-C语言中，一共有3种类型的block：\n\t_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。\n\t_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。\n\t_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。\n\n+ 全局 Block：_NSConcreteGlobalBlock\n\n    + 定义在函数外面的 block 是全局静态的，没有访问任何外部变量\n    + 定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的\n\n\t问题：那么定义在函数外部的，捕获变量的，是 global 吗？\n\n\t```objc\n\tvoid f()\n\t{\n\t    ^{ printf(\"Hello, World!\\n\"); } ();\n\t}\n\t```\n\n+ 栈 Block：_NSConcreteStackBlock\n\n\t```objc\n\tvoid f()\n\t{\n\t    char a = 'A';\n\t    ^{ printf(\"%c\\n\",a); } ();\n\t}\n\t```\n\n+ 堆 Block：_NSConcreteMallocBlock\n\n\tNSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中\n\n\t```objc\n\tvoid f()\n\t{\n\t    char a = 'A';\n\t    void (^block)() = [^{ printf(\"%c\\n\",a); } copy];\n\t}\n\t```\n\n\t\t对全局 Block 进行 copy 后，什么事也不会发生\n\t\t对栈 Block 进行 copy 后，会得到一个堆 Block\n\t\t对堆 Block 进行 copy 后，其引用计数会加1\n\n+ 例子\n\n\t```objc\n\tvoid (^blcok)();\n\tif (1)\n\t{\n\t    block = ^{\n\t        NSLog(@\"Hello\");\n\t    }\n\t}\n\tblock();\n```\n\n\tblock执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放\n\n\t正确做法是\n\n\t```objc\n\tvoid (^blcok)();\n\tif (1)\n\t{\n\t    block = [^{\n\t        NSLog(@\"Hello\");\n\t    } copy];\n\t}\n\tblock();\n\t```\n\n+ 更多细节见[《谈Objective-C block的实现》](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/)\n\n## done 第38条：为常用的块类型创建typedef \n## done 第39条：用handler块降低代码分散程度 \n## 第40条：用块引用其所属对象时不要出现保留环 \n例子1\n\n```objc\n// EOCNetworkFetcher.h\n\n#import <Foundation/Foundation.h>\n\ntypedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);\n\n@interface EOCNetworkFetcher : NSObject\n\n@property (nonatomic, strong, readonly) NSURL *url;\n\n- (id)initWithURL:(NSURL*)url;\n\n- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;\n\n@end\n```\n\n```objc\n// EOCNetworkFetcher.m\n#import \"EOCNetworkFetcher.h\"\n\n@interface EOCNetworkFetcher ()\n@property (nonatomic, strong, readwrite) NSURL *url;\n@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;\n@property (nonatomic, strong) NSData *downloadedData;\n@end\n\n\n@implementation EOCNetworkFetcher\n\n- (id)initWithURL:(NSURL*)url\n{\n\t\tif ((self = [super init])) {\n\t\t\t\t_url = url;\n\t\t}\n\t\treturn self;\n}\n\n- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion\n{\n\t\tself.completionHandler = completion;\n\t\t// Start the request\n\t\t// Request sets downloadedData property\n\t\t// When request is finished, p_requestCompleted is called\n}\n\n- (void)p_requestCompleted {\n\t\tif (_completionHandler) {\n\t\t\t\t_completionHandler(_downloadedData);\n\t\t}\n}\n\n@end\n```\n\n```objc\n@implementation EOCClass\n{\n    EOCNetworkFetcher* _networkFetcher;\n    NSData* _fetchedData;\n}\n\n- (void)downloadData\n{\n    NSURL* url = [[NSURL alloc] initWithString:@\"http://www.example.com/something.dat\"];\n\t\t\n    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];\n\n\t\t[_networkFetcher startWithCompletionHandler:^(NSData *data){\n\n\t\t\t\tNSLog(@\"Request URL %@ finished\", _networkFetcher.url);\n\t\t\t\t_fetchedData = data;\n\n\t\t}];\n}\n@end\n```\n\nEoCClass -> networkFetcher -> block -> self(通过_fetchedData)\n\n例子2\n\n将 networkFetcher 变为局部变量，修改如下：\n\n```objc\n- (void)downloadData {\n NSURL *url = [[NSURL alloc] initWithString:\n @\"http://www.example.com/something.dat\"];\n EOCNetworkFetcher *networkFetcher =\n [[EOCNetworkFetcher alloc] initWithURL:url];\n [networkFetcher startWithCompletionHandler:^(NSData *data){\n NSLog(@\"Request URL %@ finished\", networkFetcher.url);\n _fetchedData = data;\n }];\n}\n```\n\nnetworkFetcher -> block -> networkFetcher(通过url)\n\n## 第41条：多用派发队列，少用同步锁\n \n## 第42条：多用GCD，少用performSelector系列方法\n### 如何延迟执行一个方法\n```objc\n// 方法1：使用 performSelector\n[self performSelector:@selector(foo) withObject:nil afterDelay:5.0];\n\n// 方法2：使用 dispatch_after\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    [self foo];\n});\n```\n使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题\n\n当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消\n\n\n### 如何让一个方法在主线程执行\n```objc\n// 方法1：使用 performSelector\n[self performSelectorOnMainThread:@selector(foo) withObject:nil waitUntilDone:NO];\n\n// 方法2：使用 dispatch_after\ndispatch_async(dispatch_get_main_queue(), ^{\n    [self foo];\n});\n```\n使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题\n \n## 第43条：掌握GCD及操作队列的使用时机\n要知道有个东西叫做 NSOperationQueue 就行了\n## 第44条：通过Dispatch Group机制，根据系统资源状况来执行任务 \n## 第45条：使用dispatch_once来执行只需运行一次的线程安全代码\n以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once\n\n比如单例的书写方式\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n```\n\n \n## 第46条：不要使用`dispatch_get_current_queue`\n尽量别用，该接口已废弃\n \n# 第7章 系统框架 \n## 第47条：熟悉系统框架\n+ CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）\n+ CoreAudio:音频处理 API（C语言）\n+ AVFoundation:视频处理接口（Objective-C）\n+ CoreData:数据库接口（Objective-C）\n+ CoreText:文字渲染排版接口（C语言）\n \n## done 第48条：多用块枚举，少用for循环\n\n## 第49条：对自定义其内存管理语义的collection使用无缝桥接 \n### 使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge CFArrayRef)array;\nNSLog(@\"%@ count: %li\", cfArray, CFArrayGetCount(cfArray));\n```\n+ NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray\n+ CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数\n\n### 桥式转换\n+ `__bridge`：只做类型转换，不修改对象（内存）管理权；\n+ `__bridge_retained`：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；\n+ `__bridge_transfer`：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC\n\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge_retained CFArrayRef)array;\nCFRelease(cfArray);  // 因为是 __bridge_retained，所以需要调用 CFRelease\n```\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge_retained CFArrayRef)array;\nNSArray *array2 = (__bridge_transfer NSArray *)cfArray;\n//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理\n```\n\n### 使用无缝桥接修改 Collection 的内存管理语义\nNSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error\n\n关于拷贝协议可以查看：[浅析Objective-C的copy](http://www.cnblogs.com/chenyg32/p/5167194.html)\n\n无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典\n\n创建函数\n\n```objc\nCFMutableDictionaryRef CFDictionaryCreateMutable(\n    CFAllocatorRef allocator,  // 一般传NULL，采用系统默认的内存分配器\n    CFIndex capacity,          // 初始大小，并非最大容量\n    const CFDictionaryKeyCallBacks *keyCallBacks,    // 回调\n    const CFDictionaryValueCallBacks *valueCallBacks // 回调\n);\n```\n\n键值回调\n\n```objc\ntypedef struct {\n    CFIndex\t\t\t\tversion;    //一般为0\n    CFDictionaryRetainCallBack\t\tretain; //遇到retain的回调\n    CFDictionaryReleaseCallBack\t\trelease;//遇到release的回调\n    CFDictionaryCopyDescriptionCallBack\tcopyDescription;//一般传NULL，采用系统默认\n    CFDictionaryEqualCallBack\t\tequal;  //一般传CFEqual\n    CFDictionaryHashCallBack\t\thash;   //一般传CFHash\n} CFDictionaryKeyCallBacks;\n\ntypedef struct {\n    CFIndex\t\t\t\tversion;    //一般为0\n    CFDictionaryRetainCallBack\t\tretain; //遇到retain的回调\n    CFDictionaryReleaseCallBack\t\trelease;//遇到release的回调\n    CFDictionaryCopyDescriptionCallBack\tcopyDescription;    //一般传NULL，采用系统默认\n    CFDictionaryEqualCallBack\t\tequal;  //一般传CFEqual\n} CFDictionaryValueCallBacks;\n```\n\n创建“保留”键，“保留”值的 NSDictionary\n\n```objc\nconst void* EOCRetainCallback (CFAllocatorRef allocator , const void *value)\n{\n    return CFRetain(value);\n}\n\nvoid EOCReleaseCallback(CFAllocatorRef allocator , const void *value)\n{\n    CFRelease(value);\n}\n\nCFDictionaryKeyCallBacks keyCallbacks = \n{\n    0,\n    EOCRetainCallback,\n    EOCReleaseCallback,\n    NULL,\n    CFEqual,\n    CFHash\n};\n\nCFDictionaryValueCallBacks valueCallbacks = \n{\n    0,\n    EOCRetainCallback,\n    EOCReleaseCallback,\n    NULL,\n    CFEqual,\n};\n    \nCFMutableDictionaryRef aCFDictionary = CFDictionaryCreateMutable(NULL, 0, &keyCallbacks, &valueCallbacks);\nNSMutableDictionary *anNSdictionary = (__bridge_transfer NSMutableDictionary *)aCFDictionary;\n```\n\n## 第50条：构建缓存时选用NSCache而非NSDictionary \n+ 实现缓存时应选用 NSCache 而非 NSDictionary\n+ 可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据\n+ NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）\n+ NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）\n+ 使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除\n\n扩展阅读：[利用NSCache提升效率](https://www.ganlvji.com/nscache/)\n\n## 第51条：精简initialize与load的实现代码\n|           | load  | initialize |\n| :--: |:--:| :-:|\n| 执行次数   | 1次 | 1次 |\n| 执行时机   | app启动时所有运行时需要用到的类 | 惰性调用，需要使用到具体类的时候才调用 |\n| 作用      | 调试 现基本不用 |初始化全局oc对象（普通对象可以在声明的时候初始化）|\n| 执行时环境 | 系统不稳定，许多东西尚未初始化 | 系统处于正常状态 |\n| 调用顺序   | 1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类 | 跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名 |\n| 相同点    | 1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁| 同左 |\n\n### initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\n假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：\n```objc\n@interface A : NSObject\n@end\n@implementation A\n+ (void)initialize\n{\n    NSLog(@\"%@\", self);\n}\n@end\n\n@interface B : A\n@end\n@implementation B\n@end\n```\n此时创建一个B对象，输出是\n> A  \n> B\n\n初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B\n\n所以 A 的 initialize 方法应该这样写\n\n```objc\n+ (void)initialize\n{\n    if (self == [A class])\n    {\n        NSLog(@\"%@\", self);\n    }\n}\n```\n此时创建一个B对象，输出是\n> B\n\n## 第52条：别忘了NSTimer会保留其目标对象\n参见：[NSTimer 会保留目标对象](http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/)","slug":"Effective-Objective-C-读书笔记","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","link":"","_id":"cjp2opl380007u3qwt49l9d7z","content":"<h1 id=\"第1章-熟悉Objective—C\"><a href=\"#第1章-熟悉Objective—C\" class=\"headerlink\" title=\"第1章 熟悉Objective—C\"></a>第1章 熟悉Objective—C</h1><h2 id=\"第1条：了解Objective—C语言的起源\"><a href=\"#第1条：了解Objective—C语言的起源\" class=\"headerlink\" title=\"第1条：了解Objective—C语言的起源\"></a>第1条：了解Objective—C语言的起源</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *s1 = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *s2 = s1;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>s1 和s2 的内存分配在栈上</li>\n<li>@”Hello”的内存分配在堆上</li>\n<li>s1 和 s2 指向同一块内存</li>\n</ul>\n<h2 id=\"第2条：在类的头文件中尽量少引入其他头文件\"><a href=\"#第2条：在类的头文件中尽量少引入其他头文件\" class=\"headerlink\" title=\"第2条：在类的头文件中尽量少引入其他头文件\"></a>第2条：在类的头文件中尽量少引入其他头文件</h2><h2 id=\"第3条：多用字面量语法，少用与之等价的方法\"><a href=\"#第3条：多用字面量语法，少用与之等价的方法\" class=\"headerlink\" title=\"第3条：多用字面量语法，少用与之等价的方法\"></a>第3条：多用字面量语法，少用与之等价的方法</h2><h3 id=\"使用字面量语法，它是一种语法糖：\"><a href=\"#使用字面量语法，它是一种语法糖：\" class=\"headerlink\" title=\"使用字面量语法，它是一种语法糖：\"></a>使用字面量语法，它是一种语法糖：</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *intNum = @<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *doubleNum = @<span class=\"number\">2.5</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *charNum = @<span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *boolNum = @YES;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"hello\"</span>, @<span class=\"number\">1</span>, @<span class=\"number\">2.5</span>, @<span class=\"string\">'a'</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *str2 = array[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dic = @&#123;<span class=\"string\">@\"1\"</span>:@<span class=\"number\">1</span>, <span class=\"string\">@\"2\"</span>:@<span class=\"number\">2</span>&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"这个语法糖更容易暴露隐藏的问题\"><a href=\"#这个语法糖更容易暴露隐藏的问题\" class=\"headerlink\" title=\"这个语法糖更容易暴露隐藏的问题\"></a>这个语法糖更容易暴露隐藏的问题</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array1 = [<span class=\"built_in\">NSArray</span> arrayWithObjects: obj1, obj2, obj3, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array2 = @[obj1, obj2, obj3];</span><br></pre></td></tr></table></figure>\n<p>如果 obj1 和 obj3 非空，而 obj2 是 nil</p>\n<p>那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常</p>\n<h3 id=\"使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\"><a href=\"#使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\" class=\"headerlink\" title=\"使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\"></a>使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMuatableArray</span> *mArray = [@[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>] mutableCopy];</span><br></pre></td></tr></table></figure>\n<h2 id=\"第4条：多用类型常量，少用-define预处理指令\"><a href=\"#第4条：多用类型常量，少用-define预处理指令\" class=\"headerlink\" title=\"第4条：多用类型常量，少用#define预处理指令\"></a>第4条：多用类型常量，少用#define预处理指令</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/5080301.html\" target=\"_blank\" rel=\"noopener\">NSNotification Name 最佳写法</a></p>\n<h2 id=\"第5条：用枚举表示状态、选项、状态码\"><a href=\"#第5条：用枚举表示状态、选项、状态码\" class=\"headerlink\" title=\"第5条：用枚举表示状态、选项、状态码\"></a>第5条：用枚举表示状态、选项、状态码</h2><h3 id=\"使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，\"><a href=\"#使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，\" class=\"headerlink\" title=\"使用 NS_ENUM 和 NS_OPTIONS 来表示状态机，\"></a>使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 来表示<code>状态机</code>，</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NS_ENUM，定义状态等普通枚举</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, TTGState) &#123;</span><br><span class=\"line\">    TTGStateOK = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGStateError,</span><br><span class=\"line\">    TTGStateUnknow</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NS_OPTIONS，定义选项</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, TTGDirection) &#123;</span><br><span class=\"line\">    TTGDirectionNone = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGDirectionTop = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGDirectionLeft = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">    TTGDirectionRight = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">    TTGDirectionBottom = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示\"><a href=\"#如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示\" class=\"headerlink\" title=\"如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用 NS_OPTIONS，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用或操作将其组合起来进行表示\"></a>如果一个<code>枚举变量</code>可以同时表示一个或多个选项的集合，那么应当使用 <code>NS_OPTIONS</code>，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用<code>或操作</code>将其组合起来进行表示</h3><h3 id=\"相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\"><a href=\"#相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\" class=\"headerlink\" title=\"相比较 C 语言中的枚举，使用 NS_ENUM 和 NS_OPTIONS 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\"></a>相比较 C 语言中的枚举，使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> _TTGState &#123;</span><br><span class=\"line\">    TTGStateOK  = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGStateError,</span><br><span class=\"line\">    TTGStateUnknow</span><br><span class=\"line\">&#125; TTGState;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举\"><a href=\"#处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举\" class=\"headerlink\" title=\"处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举\"></a>处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举</h3><h3 id=\"参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\"><a href=\"#参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\" class=\"headerlink\" title=\"参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\"></a>参考链接：<a href=\"http://tutuge.me/2015/03/21/effective-objective-c-5-enum/\" target=\"_blank\" rel=\"noopener\">Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5</a></h3><h1 id=\"第2章-对象、消息、运行期\"><a href=\"#第2章-对象、消息、运行期\" class=\"headerlink\" title=\"第2章 对象、消息、运行期\"></a>第2章 对象、消息、运行期</h1><h2 id=\"第6条：理解“属性”这一概念\"><a href=\"#第6条：理解“属性”这一概念\" class=\"headerlink\" title=\"第6条：理解“属性”这一概念\"></a>第6条：理解“属性”这一概念</h2><h3 id=\"理解好属性和实例变量的区别\"><a href=\"#理解好属性和实例变量的区别\" class=\"headerlink\" title=\"理解好属性和实例变量的区别\"></a>理解好<code>属性</code>和<code>实例变量</code>的区别</h3><p>属性 = 实例变量 + setter + getter</p>\n<p>如果声明属性</p>\n<pre><code>@property (nonatomic, copy) NSString *str;\n</code></pre><p>则编译器会默认实现</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setStr:(<span class=\"built_in\">NSString</span> *)str;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setStr:(<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_str = [str <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>_str</code> 就是<code>实例变量</code></p>\n<h3 id=\"使用点语法访问属性-调用-setter-getter-方法\"><a href=\"#使用点语法访问属性-调用-setter-getter-方法\" class=\"headerlink\" title=\"使用点语法访问属性 = 调用 setter/getter 方法\"></a>使用<code>点语法</code>访问属性 = 调用 setter/getter 方法</h3><h3 id=\"Property-的4种-attribute\"><a href=\"#Property-的4种-attribute\" class=\"headerlink\" title=\"Property 的4种 attribute\"></a>Property 的4种 attribute</h3><ul>\n<li>原子性(atomic, nonatomic)</li>\n<li>读写权限(readonly, readwrite)</li>\n<li>内存管理(strong, weak, unsafe_unretained, retain, assign, copy)</li>\n<li>存取方法(getter, setter)</li>\n</ul>\n<h3 id=\"非-ARC-下，没有-weak\"><a href=\"#非-ARC-下，没有-weak\" class=\"headerlink\" title=\"非 ARC 下，没有 weak\"></a>非 ARC 下，没有 weak</h3><h3 id=\"ARC下，修饰指针的内存修饰符\"><a href=\"#ARC下，修饰指针的内存修饰符\" class=\"headerlink\" title=\"ARC下，修饰指针的内存修饰符\"></a>ARC下，修饰指针的内存修饰符</h3><ul>\n<li><code>__weak</code>:不retain，如果对象被回收，该指针会被置nil</li>\n<li><code>__strong</code>:默认，如果对象被回收，需要手动将指针置为nil？</li>\n<li><code>__unsafe__unretained</code>:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）</li>\n<li><code>__autoreleasing</code>:实现把对象”按引用传递”给方法，变量在方法返回时自动释放</li>\n</ul>\n<p>编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量</p>\n<h3 id=\"常见数据类型的内存修饰符（待补充）\"><a href=\"#常见数据类型的内存修饰符（待补充）\" class=\"headerlink\" title=\"常见数据类型的内存修饰符（待补充）\"></a>常见数据类型的内存修饰符（待补充）</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">内存修饰符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">基本数据类型(int, NSInteger)</td>\n<td style=\"text-align:center\">assign</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">block</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSString</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableString</td>\n<td style=\"text-align:center\">strong</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSArray</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableArray</td>\n<td style=\"text-align:center\">strong</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"NSArray-用-strong-还是-copy-修饰\"><a href=\"#NSArray-用-strong-还是-copy-修饰\" class=\"headerlink\" title=\"NSArray 用 strong 还是 copy 修饰\"></a>NSArray 用 strong 还是 copy 修饰</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> *strongArray;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>)   <span class=\"built_in\">NSArray</span> *copyedArray;</span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongArray = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyedArray = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableArray = [@[<span class=\"string\">@\"1\"</span>] mutableCopy];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongArray = mutableArray;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyedArray = mutableArray;</span><br><span class=\"line\">    </span><br><span class=\"line\">[mutableArray addObject:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\\n%@\\n%@\"</span>, mutableArray, <span class=\"keyword\">self</span>.strongArray, <span class=\"keyword\">self</span>.copyedArray); <span class=\"comment\">//输出 (1,2) (1,2) (1)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。</p>\n<h2 id=\"第7条：在对象内部尽量直接访问实例变量\"><a href=\"#第7条：在对象内部尽量直接访问实例变量\" class=\"headerlink\" title=\"第7条：在对象内部尽量直接访问实例变量\"></a>第7条：在对象内部尽量直接访问实例变量</h2><h3 id=\"类内使用-self-xxx-和-xxx-的区别\"><a href=\"#类内使用-self-xxx-和-xxx-的区别\" class=\"headerlink\" title=\"类内使用 self.xxx 和 _xxx 的区别\"></a>类内使用 self.xxx 和 _xxx 的区别</h3><ul>\n<li>访问 _xxx 不经过 setter/getter 方法，速度更快</li>\n<li>访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作</li>\n<li>访问 _xxx 不经过 setter/getter 方法，无法触发 KVO</li>\n<li>访问 _xxx 不经过 setter/getter 方法，无法断点</li>\n</ul>\n<h3 id=\"什么时候使用-xxx\"><a href=\"#什么时候使用-xxx\" class=\"headerlink\" title=\"什么时候使用 _xxx\"></a>什么时候使用 _xxx</h3><ul>\n<li>折中方案，读的时候使用 _xxx，写的时候使用 self.xxx</li>\n<li>父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错</li>\n<li>如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性</li>\n<li>使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!_str)</span><br><span class=\"line\">\t\t_str = [[<span class=\"built_in\">NSString</span> alloc] init];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"第8条：理解“对象等同性”这一概念\"><a href=\"#第8条：理解“对象等同性”这一概念\" class=\"headerlink\" title=\"第8条：理解“对象等同性”这一概念\"></a>第8条：理解“对象等同性”这一概念</h2><h2 id=\"第9条：以“类族模式”隐藏实现细节\"><a href=\"#第9条：以“类族模式”隐藏实现细节\" class=\"headerlink\" title=\"第9条：以“类族模式”隐藏实现细节\"></a>第9条：以“类族模式”隐藏实现细节</h2><h2 id=\"第10条：在既有类中使用关联对象存放自定义数据\"><a href=\"#第10条：在既有类中使用关联对象存放自定义数据\" class=\"headerlink\" title=\"第10条：在既有类中使用关联对象存放自定义数据\"></a>第10条：在既有类中使用关联对象存放自定义数据</h2><p>“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> objc_setAssociatedObject (<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> objc_getAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> objc_removeAssociatedObject(<span class=\"keyword\">id</span> object);    <span class=\"comment\">// 移除object上的所有关联对象</span></span><br></pre></td></tr></table></figure>\n<p>其中 objc_AssociationPolicy 是关联对象的属性，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_ASSOCIATION_ASSIGN             --- <span class=\"keyword\">assign</span></span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN_NONATOMIC   --- <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span></span><br><span class=\"line\">OBJC_ASSOCIATION_COPY_NONATOMIC     --- <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span></span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN             --- <span class=\"keyword\">retain</span></span><br><span class=\"line\">OBJC_ASSOCIATION_COPY               --- <span class=\"keyword\">copy</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"与-NSDictionary-的区别\"><a href=\"#与-NSDictionary-的区别\" class=\"headerlink\" title=\"与 NSDictionary 的区别\"></a>与 NSDictionary 的区别</h3><p>设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。</p>\n<p>所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @”xxx”</p>\n<h3 id=\"例子1\"><a href=\"#例子1\" class=\"headerlink\" title=\"例子1\"></a>例子1</h3><p>假如一个页面有2个弹窗，那么代码可能是这样写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)askUserAQuestion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]</span><br><span class=\"line\">            initWithTitle:<span class=\"string\">@\"Question\"</span></span><br><span class=\"line\">                  message:<span class=\"string\">@\"What do you want to do?\"</span></span><br><span class=\"line\">                 delegate:<span class=\"keyword\">self</span></span><br><span class=\"line\">        cancelButtonTitle:<span class=\"string\">@\"Cancel\"</span></span><br><span class=\"line\">        otherButtonTitles:<span class=\"string\">@\"Continue\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [alert show];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UIAlertViewDelegate protocol method</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)alertView:(<span class=\"built_in\">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class=\"built_in\">NSInteger</span>)buttonIndex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buttonIndex == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doCancel];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doContinue];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *EOCMyAlertViewKey = <span class=\"string\">\"EOCMyAlertViewKey\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)askUserAQuestion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]</span><br><span class=\"line\">\t        initWithTitle:<span class=\"string\">@\"Question\"</span></span><br><span class=\"line\">\t              message:<span class=\"string\">@\"What do you want to do?\"</span></span><br><span class=\"line\">\t             delegate:<span class=\"keyword\">self</span></span><br><span class=\"line\">\t    cancelButtonTitle:<span class=\"string\">@\"Cancel\"</span></span><br><span class=\"line\">\t    otherButtonTitles:<span class=\"string\">@\"Continue\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (^block)(<span class=\"built_in\">NSInteger</span>) = ^(<span class=\"built_in\">NSInteger</span> buttonIndex) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (buttonIndex == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\t    [<span class=\"keyword\">self</span> doCancel];</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"keyword\">else</span></span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\t    [<span class=\"keyword\">self</span> doContinue];</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tobjc_setAssociatedObject(alert,</span><br><span class=\"line\">                             EOCMyAlertViewKey,</span><br><span class=\"line\">                             block,</span><br><span class=\"line\">                             OBJC_ASSOCIATION_COPY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t[alert show];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UIAlertViewDelegate protocol method</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)alertView:(<span class=\"built_in\">UIAlertView</span> *)alertView</span><br><span class=\"line\">    clickedButtonAtIndex:(<span class=\"built_in\">NSInteger</span>)buttonIndex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (^block)(<span class=\"built_in\">NSInteger</span>) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);</span><br><span class=\"line\">\tblock(buttonIndex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView</p>\n<h3 id=\"例子2-为协议文件添加属性\"><a href=\"#例子2-为协议文件添加属性\" class=\"headerlink\" title=\"例子2 为协议文件添加属性\"></a>例子2 为协议文件添加属性</h3><p>.h</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"QLJCEONAVRSSFeed.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">QLJCEONAVRSSFeed</span> (<span class=\"title\">contentOffset</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>)<span class=\"built_in\">CGPoint</span> savedOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"QLJCEONAVRSSFeed+contentOffset.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define feed_saved_Off_set_x_key @<span class=\"meta-string\">\"feed_saved_Off_set_x_key\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#define feed_saved_Off_set_y_key @<span class=\"meta-string\">\"feed_saved_Off_set_y_key\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">QLJCEONAVRSSFeed</span> (<span class=\"title\">contentOffset</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> savedOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGPoint</span>)savedOffset</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *xObj = objc_getAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_x_key);</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *yObj = objc_getAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_y_key);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> point = <span class=\"built_in\">CGPointMake</span>([xObj floatValue], [yObj floatValue]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> point;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSavedOffset:(<span class=\"built_in\">CGPoint</span>)savedOffset</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第11条：理解objc-msgSend的作用\"><a href=\"#第11条：理解objc-msgSend的作用\" class=\"headerlink\" title=\"第11条：理解objc_msgSend的作用\"></a>第11条：理解objc_msgSend的作用</h2><p>见 <a href=\"http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/\">Objective-C中的消息转发机制</a></p>\n<h2 id=\"第12条：理解消息转发机制\"><a href=\"#第12条：理解消息转发机制\" class=\"headerlink\" title=\"第12条：理解消息转发机制\"></a>第12条：理解消息转发机制</h2><p>见 <a href=\"http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/\">Objective-C中的消息转发机制</a></p>\n<h2 id=\"第13条：用“方法调配技术”调试“黑盒方法”\"><a href=\"#第13条：用“方法调配技术”调试“黑盒方法”\" class=\"headerlink\" title=\"第13条：用“方法调配技术”调试“黑盒方法”\"></a>第13条：用“方法调配技术”调试“黑盒方法”</h2><p>创建自己的方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSString+MyAdditions.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSString</span> (<span class=\"title\">MyAdditions</span>)</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)myLowercaseString</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *lowercase = [<span class=\"keyword\">self</span> myLowercaseString];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"This is my own method: %@\"</span>, lowercase);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lowercase;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>替换</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method originalMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(lowercaseString));</span><br><span class=\"line\">Method swappedMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(myLowercaseString));</span><br><span class=\"line\">method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure>\n<h2 id=\"第14条：理解“类对象”的用意\"><a href=\"#第14条：理解“类对象”的用意\" class=\"headerlink\" title=\"第14条：理解“类对象”的用意\"></a>第14条：理解“类对象”的用意</h2><h3 id=\"我们所说的-Objective-C-对象究竟是什么\"><a href=\"#我们所说的-Objective-C-对象究竟是什么\" class=\"headerlink\" title=\"我们所说的 Objective-C 对象究竟是什么\"></a>我们所说的 Objective-C 对象究竟是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object&#123;</span><br><span class=\"line\">  Class isa;  <span class=\"comment\">//=&gt; 指向对象所属的类</span></span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>结论：Objective-C 对象 = id = objc_object</p>\n<h3 id=\"那么-Class-是什么\"><a href=\"#那么-Class-是什么\" class=\"headerlink\" title=\"那么 Class 是什么\"></a>那么 Class 是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>\n<h3 id=\"那么-objc-class-又是什么\"><a href=\"#那么-objc-class-又是什么\" class=\"headerlink\" title=\"那么 objc_class 又是什么\"></a>那么 objc_class 又是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;  </span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class super_class;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> version;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> info;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类的继承体系\"><a href=\"#类的继承体系\" class=\"headerlink\" title=\"类的继承体系\"></a>类的继承体系</h3><p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/isa.png\" alt=\"\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"Hello\"</span>;</span><br></pre></td></tr></table></figure>\n<p>str 是一个对象，is a NSString</p>\n<p>NSString 是类，is a NSString metaclass</p>\n<p>NSString metaclass 是元类，类方法就定义在这里</p>\n<h1 id=\"第3章-接口与API设计\"><a href=\"#第3章-接口与API设计\" class=\"headerlink\" title=\"第3章 接口与API设计\"></a>第3章 接口与API设计</h1><h2 id=\"done-第15条：用前缀避免命名空间冲突\"><a href=\"#done-第15条：用前缀避免命名空间冲突\" class=\"headerlink\" title=\"done 第15条：用前缀避免命名空间冲突\"></a>done 第15条：用前缀避免命名空间冲突</h2><h2 id=\"done-第16条：提供“全能初始化方法”\"><a href=\"#done-第16条：提供“全能初始化方法”\" class=\"headerlink\" title=\"done 第16条：提供“全能初始化方法”\"></a>done 第16条：提供“全能初始化方法”</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/4870303.html\" target=\"_blank\" rel=\"noopener\">Designated Initializer</a></p>\n<h2 id=\"done-第17条：实现description方法\"><a href=\"#done-第17条：实现description方法\" class=\"headerlink\" title=\"done 第17条：实现description方法\"></a>done 第17条：实现description方法</h2><h2 id=\"done-第18条：尽量使用不可变对象\"><a href=\"#done-第18条：尽量使用不可变对象\" class=\"headerlink\" title=\"done 第18条：尽量使用不可变对象\"></a>done 第18条：尽量使用不可变对象</h2><ul>\n<li>如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite</li>\n<li>不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法</li>\n</ul>\n<h2 id=\"done-第19条：使用清晰而协调的命名方式\"><a href=\"#done-第19条：使用清晰而协调的命名方式\" class=\"headerlink\" title=\"done 第19条：使用清晰而协调的命名方式:\"></a>done 第19条：使用清晰而协调的命名方式:</h2><h3 id=\"如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了\"><a href=\"#如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了\" class=\"headerlink\" title=\"如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了\"></a>如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了</h3><h3 id=\"对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX\"><a href=\"#对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX\" class=\"headerlink\" title=\"对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX\"></a>对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX</h3><pre><code>@property (nonatomic, assign, getter = isOn) on;\n</code></pre><h2 id=\"done-第20条：为私有方法名加前缀\"><a href=\"#done-第20条：为私有方法名加前缀\" class=\"headerlink\" title=\"done 第20条：为私有方法名加前缀\"></a>done 第20条：为私有方法名加前缀</h2><h2 id=\"done-第21条：理解Objective—C错误模型\"><a href=\"#done-第21条：理解Objective—C错误模型\" class=\"headerlink\" title=\"done 第21条：理解Objective—C错误模型\"></a>done 第21条：理解Objective—C错误模型</h2><h2 id=\"done-第22条：理解NSCopying协议\"><a href=\"#done-第22条：理解NSCopying协议\" class=\"headerlink\" title=\"done 第22条：理解NSCopying协议\"></a>done 第22条：理解NSCopying协议</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/5167194.html\" target=\"_blank\" rel=\"noopener\">浅析Objective-C的copy</a></p>\n<h1 id=\"第4章-协议与分类\"><a href=\"#第4章-协议与分类\" class=\"headerlink\" title=\"第4章 协议与分类\"></a>第4章 协议与分类</h1><h2 id=\"第23条：通过委托与数据源协议进行对象间通信\"><a href=\"#第23条：通过委托与数据源协议进行对象间通信\" class=\"headerlink\" title=\"第23条：通过委托与数据源协议进行对象间通信\"></a>第23条：通过委托与数据源协议进行对象间通信</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>([_delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didReceiveData:)])</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [_delegate networkFetcher:<span class=\"keyword\">self</span> didReceiveData:data];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果上面的代码写了很多次，则可以考虑以下优化：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在扩展中定义结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span>(</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> didReceiveData : <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> didFailWithError : <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125; _delegateFlags; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> </span></span><br><span class=\"line\">EOCNetworkFetcher </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setDelegate:(<span class=\"keyword\">id</span>)delegate</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    _delegate = delegate; <span class=\"comment\">// 缓存委托对象相应方法能力 </span></span><br><span class=\"line\">    _delegateFlags.didReceiveData = [delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didReceiveData:)]; </span><br><span class=\"line\">    _delegateFlags.didFailWithError = [delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didFailWithError:)]; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\">这样每次调用delegate相关方法之前就只需要直接查询标志：</span><br><span class=\"line\"><span class=\"keyword\">if</span>(_delegateFlags.didReceiveData)</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [_delegate networkFetcher:<span class=\"keyword\">self</span> didReceiveData:data]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"done-第24条：将类的实现代码分散到便于管理的数个分类之中\"><a href=\"#done-第24条：将类的实现代码分散到便于管理的数个分类之中\" class=\"headerlink\" title=\"done 第24条：将类的实现代码分散到便于管理的数个分类之中\"></a>done 第24条：将类的实现代码分散到便于管理的数个分类之中</h2><h2 id=\"第25条：总是为第三方类的分类名称加前缀\"><a href=\"#第25条：总是为第三方类的分类名称加前缀\" class=\"headerlink\" title=\"第25条：总是为第三方类的分类名称加前缀\"></a>第25条：总是为第三方类的分类名称加前缀</h2><ol>\n<li>为第三方类添加分类时，总应给其名称加上你专用的前缀</li>\n<li>为第三方类添加分类时，总应给方法名加上你专用的前缀</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">ABC_HTTP</span>)</span></span><br><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)abc_urlEncodedString;</span><br><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)abc_urlDecodedString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"第26条：勿在分类中声明属性\"><a href=\"#第26条：勿在分类中声明属性\" class=\"headerlink\" title=\"第26条：勿在分类中声明属性\"></a>第26条：勿在分类中声明属性</h2><p>属性应该在主类中声明</p>\n<p>如果分类中声明属性需要自己重写 setter 和 getter</p>\n<p>方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *kFriendsPropertyKey = <span class=\"string\">\"kFriendsPropertyKey\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span>(<span class=\"title\">Friendship</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> friends;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"built_in\">NSArray</span>*)friends </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setFriends:(<span class=\"built_in\">NSArray</span>*)friends </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　objc_setAssociaedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>缺点如下</p>\n<ol>\n<li>相似的代码要写很多遍</li>\n<li>极易忽略属性定义的内存管理语义，且不好维护</li>\n</ol>\n<h2 id=\"第27条：使用“class—continuation分类”隐藏实现细节\"><a href=\"#第27条：使用“class—continuation分类”隐藏实现细节\" class=\"headerlink\" title=\"第27条：使用“class—continuation分类”隐藏实现细节\"></a>第27条：使用“class—continuation分类”隐藏实现细节</h2><p>声明私有实例变量的3种方法</p>\n<ul>\n<li><p>方法1：对外暴露，声明为 private（暴露了细节，不建议）</p>\n<p>  .h</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>:<span class=\"title\">NSObject</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">@private</span></span><br><span class=\"line\">    XYZ *_xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>把私有变量放在头文件，暴露了细节，不好</li>\n<li>假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题</li>\n<li>所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>方法2：不对外暴露</p>\n<p>  .m</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *_xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) XYZ *xyz2;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法3：对外只读，对内读写</p>\n<p>  .h</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) XYZ *xyz;</span><br></pre></td></tr></table></figure>\n<p>  .m</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readwrite</span>) XYZ *xyz;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"done-第28条：通过协议提供匿名对象\"><a href=\"#done-第28条：通过协议提供匿名对象\" class=\"headerlink\" title=\"done 第28条：通过协议提供匿名对象\"></a>done 第28条：通过协议提供匿名对象</h2><h1 id=\"第5章-内存管理\"><a href=\"#第5章-内存管理\" class=\"headerlink\" title=\"第5章 内存管理\"></a>第5章 内存管理</h1><h2 id=\"第29条：理解引用计数\"><a href=\"#第29条：理解引用计数\" class=\"headerlink\" title=\"第29条：理解引用计数\"></a>第29条：理解引用计数</h2><h3 id=\"悬浮指针\"><a href=\"#悬浮指针\" class=\"headerlink\" title=\"悬浮指针\"></a>悬浮指针</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number = [[<span class=\"built_in\">NSNumber</span> alloc] initWithInt:<span class=\"number\">1</span>];</span><br><span class=\"line\">[array addObject:number];</span><br><span class=\"line\">[number release];</span><br><span class=\"line\">number = <span class=\"literal\">nil</span>;   <span class=\"comment\">//如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"autorelease\"><a href=\"#autorelease\" class=\"headerlink\" title=\"autorelease\"></a>autorelease</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringValue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"Hello\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放</p>\n<p>但是，这是十分不合理的，因为从方法名上看（不含<code>alloc/new/copy/mutableCopy</code>），调用者并不知道它需要负责释放该对象</p>\n<p>所以此时，autorelease 就应运而生了</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringValue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"Hello\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [str autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>str 对象会在其所在的释放池释放的时候被释放</p>\n<p>如果外部需要 retain 该返回值，则需要这样做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = [[<span class=\"keyword\">self</span> stringValue] <span class=\"keyword\">retain</span>];</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">[str release];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间</p>\n</blockquote>\n<h2 id=\"第30条：以ARC简化引用计数\"><a href=\"#第30条：以ARC简化引用计数\" class=\"headerlink\" title=\"第30条：以ARC简化引用计数\"></a>第30条：以ARC简化引用计数</h2><h3 id=\"ARC-的本质是自动添加-release-retian-autorelease-等\"><a href=\"#ARC-的本质是自动添加-release-retian-autorelease-等\" class=\"headerlink\" title=\"ARC 的本质是自动添加 release/retian/autorelease 等\"></a>ARC 的本质是自动添加 release/retian/autorelease 等</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (XYZ *)newXYZ</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (XYZ *)createXYZ</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">/*ARC自动添加</span></span><br><span class=\"line\"><span class=\"comment\">    xyz = [xyz autorelease];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)f</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz1 = [XYZ newXYZ];</span><br><span class=\"line\">    XYZ *xyz2 = [XYZ createXYZ];</span><br><span class=\"line\">    <span class=\"comment\">/*ARC自动添加</span></span><br><span class=\"line\"><span class=\"comment\">    [xyz1 release];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展阅读：iOS开发ARC内存管理技术要点\"><a href=\"#扩展阅读：iOS开发ARC内存管理技术要点\" class=\"headerlink\" title=\"扩展阅读：iOS开发ARC内存管理技术要点\"></a>扩展阅读：<a href=\"http://www.cnblogs.com/flyFreeZn/p/4264220.html\" target=\"_blank\" rel=\"noopener\">iOS开发ARC内存管理技术要点</a></h3><h2 id=\"done-第31条：在dealloc方法中只释放引用并解除监听\"><a href=\"#done-第31条：在dealloc方法中只释放引用并解除监听\" class=\"headerlink\" title=\"done 第31条：在dealloc方法中只释放引用并解除监听\"></a>done 第31条：在dealloc方法中只释放引用并解除监听</h2><h2 id=\"done-第32条：编写“异常安全代码”时留意内存管理问题\"><a href=\"#done-第32条：编写“异常安全代码”时留意内存管理问题\" class=\"headerlink\" title=\"done 第32条：编写“异常安全代码”时留意内存管理问题\"></a>done 第32条：编写“异常安全代码”时留意内存管理问题</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];</span><br><span class=\"line\"> [object release];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏</p>\n<p>解决方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EOCSomeClass *object;</span><br><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@finally</span> &#123;</span><br><span class=\"line\"> [object release];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理，ARC 下也会发生这个问题</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题</p>\n<p>总结：</p>\n<ol>\n<li>当捕获到异常,应该注意确保@try中创建的对象被清理完成.</li>\n<li>ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.</li>\n</ol>\n<h2 id=\"done-第33条：以弱引用避免保留环\"><a href=\"#done-第33条：以弱引用避免保留环\" class=\"headerlink\" title=\"done 第33条：以弱引用避免保留环\"></a>done 第33条：以弱引用避免保留环</h2><h2 id=\"done-第34条：以“自动释放池块”降低内存峰值\"><a href=\"#done-第34条：以“自动释放池块”降低内存峰值\" class=\"headerlink\" title=\"done 第34条：以“自动释放池块”降低内存峰值\"></a>done 第34条：以“自动释放池块”降低内存峰值</h2><p>ARC下，可以使用 @autoreleasepool 来降低内存峰值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9999</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span>&#123;</span><br><span class=\"line\">        A *a = [[A alloc] init];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> handle:a];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>a 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值</p>\n<p>使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用</p>\n<p>另外，关于降低内存峰值的之前也有学习过，见<a href=\"http://www.cnblogs.com/chenyg32/p/3859110.html\" target=\"_blank\" rel=\"noopener\">Objective-C 内存管理</a></p>\n<h2 id=\"done-第35条：用“僵尸对象”调试内存管理问题\"><a href=\"#done-第35条：用“僵尸对象”调试内存管理问题\" class=\"headerlink\" title=\"done 第35条：用“僵尸对象”调试内存管理问题\"></a>done 第35条：用“僵尸对象”调试内存管理问题</h2><p>僵尸对象是调试内存管理问题的最佳方式</p>\n<p>被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。</p>\n<p>打开僵尸对象的方法：</p>\n<p>Xcode -&gt; Run -&gt; Diagnostics -&gt; Enable Zombie Objects<br><img src=\"http://img.blog.csdn.net/20150803102818758\" alt=\"\"></p>\n<p>僵尸对象的原理：</p>\n<p>替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存</p>\n<p>原理代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Obtain the class of the object being deallocated</span></span><br><span class=\"line\">Class cls = object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the class's name</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *clsName = class_getName(cls);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prepend _NSZombie_ to the class name</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *zombieClsName = <span class=\"string\">@\"_NSZombie_\"</span> + clsName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// See if the specific zombie class exists</span></span><br><span class=\"line\">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If the specific zombie class doesn't exists,</span></span><br><span class=\"line\"><span class=\"comment\">// then it needs to be created</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!zombieCls)&#123;</span><br><span class=\"line\"><span class=\"comment\">// Obtain the template  zombie class, where the new class's </span></span><br><span class=\"line\"><span class=\"comment\">// name is the prepended string from above</span></span><br><span class=\"line\">   zombieCls = objc_duplicateClass(baseZombieCls,   </span><br><span class=\"line\">   zombieClsName,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Perform normal destruction of the object being deallocated</span></span><br><span class=\"line\">objc_destructInstance(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set the class of the object being deallocated</span></span><br><span class=\"line\"><span class=\"comment\">// to the zombie class</span></span><br><span class=\"line\">objc_setClass(<span class=\"keyword\">self</span>, zombieCls) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The class of \"self\" is now _NSZombie_OriginalClass</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"done-第36条：不要使用retainCount\"><a href=\"#done-第36条：不要使用retainCount\" class=\"headerlink\" title=\"done 第36条：不要使用retainCount\"></a>done 第36条：不要使用retainCount</h2><h1 id=\"第6章-块与大中枢派发\"><a href=\"#第6章-块与大中枢派发\" class=\"headerlink\" title=\"第6章 块与大中枢派发\"></a>第6章 块与大中枢派发</h1><h2 id=\"done-第37条：理解“块”这一概念\"><a href=\"#done-第37条：理解“块”这一概念\" class=\"headerlink\" title=\"done 第37条：理解“块”这一概念\"></a>done 第37条：理解“块”这一概念</h2><pre><code>在Objective-C语言中，一共有3种类型的block：\n_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。\n_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。\n_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。\n</code></pre><ul>\n<li><p>全局 Block：_NSConcreteGlobalBlock</p>\n<ul>\n<li>定义在函数外面的 block 是全局静态的，没有访问任何外部变量</li>\n<li><p>定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的</p>\n<p>问题：那么定义在函数外部的，捕获变量的，是 global 吗？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ^&#123; printf(<span class=\"string\">\"Hello, World!\\n\"</span>); &#125; ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>栈 Block：_NSConcreteStackBlock</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    ^&#123; printf(<span class=\"string\">\"%c\\n\"</span>,a); &#125; ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>堆 Block：_NSConcreteMallocBlock</p>\n<p>  NSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = [^&#123; printf(<span class=\"string\">\"%c\\n\"</span>,a); &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>对全局 Block 进行 copy 后，什么事也不会发生\n对栈 Block 进行 copy 后，会得到一个堆 Block\n对堆 Block 进行 copy 后，其引用计数会加1\n</code></pre></li>\n<li><p>例子</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^blcok)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    block = ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n<p>  block执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放</p>\n<p>  正确做法是</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^blcok)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    block = [^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更多细节见<a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/\" target=\"_blank\" rel=\"noopener\">《谈Objective-C block的实现》</a></p>\n</li>\n</ul>\n<h2 id=\"done-第38条：为常用的块类型创建typedef\"><a href=\"#done-第38条：为常用的块类型创建typedef\" class=\"headerlink\" title=\"done 第38条：为常用的块类型创建typedef\"></a>done 第38条：为常用的块类型创建typedef</h2><h2 id=\"done-第39条：用handler块降低代码分散程度\"><a href=\"#done-第39条：用handler块降低代码分散程度\" class=\"headerlink\" title=\"done 第39条：用handler块降低代码分散程度\"></a>done 第39条：用handler块降低代码分散程度</h2><h2 id=\"第40条：用块引用其所属对象时不要出现保留环\"><a href=\"#第40条：用块引用其所属对象时不要出现保留环\" class=\"headerlink\" title=\"第40条：用块引用其所属对象时不要出现保留环\"></a>第40条：用块引用其所属对象时不要出现保留环</h2><p>例子1</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOCNetworkFetcher.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class=\"built_in\">NSData</span> *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSURL</span> *url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithURL:(<span class=\"built_in\">NSURL</span>*)url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOCNetworkFetcher.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCNetworkFetcher.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readwrite</span>) <span class=\"built_in\">NSURL</span> *url;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) EOCNetworkFetcherCompletionHandler completionHandler;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSData</span> *downloadedData;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCNetworkFetcher</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithURL:(<span class=\"built_in\">NSURL</span>*)url</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])) &#123;</span><br><span class=\"line\">\t\t\t\t_url = url;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">self</span>.completionHandler = completion;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Start the request</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Request sets downloadedData property</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// When request is finished, p_requestCompleted is called</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)p_requestCompleted &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_completionHandler) &#123;</span><br><span class=\"line\">\t\t\t\t_completionHandler(_downloadedData);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCClass</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EOCNetworkFetcher* _networkFetcher;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span>* _fetchedData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span>* url = [[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"http://www.example.com/something.dat\"</span>];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t[_networkFetcher startWithCompletionHandler:^(<span class=\"built_in\">NSData</span> *data)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Request URL %@ finished\"</span>, _networkFetcher.url);</span><br><span class=\"line\">\t\t\t\t_fetchedData = data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>EoCClass -&gt; networkFetcher -&gt; block -&gt; self(通过_fetchedData)</p>\n<p>例子2</p>\n<p>将 networkFetcher 变为局部变量，修改如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadData &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSURL</span> *url = [[<span class=\"built_in\">NSURL</span> alloc] initWithString:</span><br><span class=\"line\"> <span class=\"string\">@\"http://www.example.com/something.dat\"</span>];</span><br><span class=\"line\"> EOCNetworkFetcher *networkFetcher =</span><br><span class=\"line\"> [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class=\"line\"> [networkFetcher startWithCompletionHandler:^(<span class=\"built_in\">NSData</span> *data)&#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Request URL %@ finished\"</span>, networkFetcher.url);</span><br><span class=\"line\"> _fetchedData = data;</span><br><span class=\"line\"> &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>networkFetcher -&gt; block -&gt; networkFetcher(通过url)</p>\n<h2 id=\"第41条：多用派发队列，少用同步锁\"><a href=\"#第41条：多用派发队列，少用同步锁\" class=\"headerlink\" title=\"第41条：多用派发队列，少用同步锁\"></a>第41条：多用派发队列，少用同步锁</h2><h2 id=\"第42条：多用GCD，少用performSelector系列方法\"><a href=\"#第42条：多用GCD，少用performSelector系列方法\" class=\"headerlink\" title=\"第42条：多用GCD，少用performSelector系列方法\"></a>第42条：多用GCD，少用performSelector系列方法</h2><h3 id=\"如何延迟执行一个方法\"><a href=\"#如何延迟执行一个方法\" class=\"headerlink\" title=\"如何延迟执行一个方法\"></a>如何延迟执行一个方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1：使用 performSelector</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(foo) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">5.0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2：使用 dispatch_after</span></span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">5.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> foo];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>\n<p>当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消</p>\n<h3 id=\"如何让一个方法在主线程执行\"><a href=\"#如何让一个方法在主线程执行\" class=\"headerlink\" title=\"如何让一个方法在主线程执行\"></a>如何让一个方法在主线程执行</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1：使用 performSelector</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(foo) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2：使用 dispatch_after</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> foo];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>\n<h2 id=\"第43条：掌握GCD及操作队列的使用时机\"><a href=\"#第43条：掌握GCD及操作队列的使用时机\" class=\"headerlink\" title=\"第43条：掌握GCD及操作队列的使用时机\"></a>第43条：掌握GCD及操作队列的使用时机</h2><p>要知道有个东西叫做 NSOperationQueue 就行了</p>\n<h2 id=\"第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务\"><a href=\"#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务\" class=\"headerlink\" title=\"第44条：通过Dispatch Group机制，根据系统资源状况来执行任务\"></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务</h2><h2 id=\"第45条：使用dispatch-once来执行只需运行一次的线程安全代码\"><a href=\"#第45条：使用dispatch-once来执行只需运行一次的线程安全代码\" class=\"headerlink\" title=\"第45条：使用dispatch_once来执行只需运行一次的线程安全代码\"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h2><p>以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once</p>\n<p>比如单例的书写方式<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"第46条：不要使用dispatch-get-current-queue\"><a href=\"#第46条：不要使用dispatch-get-current-queue\" class=\"headerlink\" title=\"第46条：不要使用dispatch_get_current_queue\"></a>第46条：不要使用<code>dispatch_get_current_queue</code></h2><p>尽量别用，该接口已废弃</p>\n<h1 id=\"第7章-系统框架\"><a href=\"#第7章-系统框架\" class=\"headerlink\" title=\"第7章 系统框架\"></a>第7章 系统框架</h1><h2 id=\"第47条：熟悉系统框架\"><a href=\"#第47条：熟悉系统框架\" class=\"headerlink\" title=\"第47条：熟悉系统框架\"></a>第47条：熟悉系统框架</h2><ul>\n<li>CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）</li>\n<li>CoreAudio:音频处理 API（C语言）</li>\n<li>AVFoundation:视频处理接口（Objective-C）</li>\n<li>CoreData:数据库接口（Objective-C）</li>\n<li>CoreText:文字渲染排版接口（C语言）</li>\n</ul>\n<h2 id=\"done-第48条：多用块枚举，少用for循环\"><a href=\"#done-第48条：多用块枚举，少用for循环\" class=\"headerlink\" title=\"done 第48条：多用块枚举，少用for循环\"></a>done 第48条：多用块枚举，少用for循环</h2><h2 id=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"><a href=\"#第49条：对自定义其内存管理语义的collection使用无缝桥接\" class=\"headerlink\" title=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h2><h3 id=\"使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构\"><a href=\"#使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构\" class=\"headerlink\" title=\"使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构\"></a>使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ count: %li\"</span>, cfArray, <span class=\"built_in\">CFArrayGetCount</span>(cfArray));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray</li>\n<li>CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数</li>\n</ul>\n<h3 id=\"桥式转换\"><a href=\"#桥式转换\" class=\"headerlink\" title=\"桥式转换\"></a>桥式转换</h3><ul>\n<li><code>__bridge</code>：只做类型转换，不修改对象（内存）管理权；</li>\n<li><code>__bridge_retained</code>：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；</li>\n<li><code>__bridge_transfer</code>：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge_retained <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(cfArray);  <span class=\"comment\">// 因为是 __bridge_retained，所以需要调用 CFRelease</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge_retained <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array2 = (__bridge_transfer <span class=\"built_in\">NSArray</span> *)cfArray;</span><br><span class=\"line\"><span class=\"comment\">//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用无缝桥接修改-Collection-的内存管理语义\"><a href=\"#使用无缝桥接修改-Collection-的内存管理语义\" class=\"headerlink\" title=\"使用无缝桥接修改 Collection 的内存管理语义\"></a>使用无缝桥接修改 Collection 的内存管理语义</h3><p>NSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error</p>\n<p>关于拷贝协议可以查看：<a href=\"http://www.cnblogs.com/chenyg32/p/5167194.html\" target=\"_blank\" rel=\"noopener\">浅析Objective-C的copy</a></p>\n<p>无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典</p>\n<p>创建函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> <span class=\"built_in\">CFDictionaryCreateMutable</span>(</span><br><span class=\"line\">    <span class=\"built_in\">CFAllocatorRef</span> allocator,  <span class=\"comment\">// 一般传NULL，采用系统默认的内存分配器</span></span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span> capacity,          <span class=\"comment\">// 初始大小，并非最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFDictionaryKeyCallBacks</span> *keyCallBacks,    <span class=\"comment\">// 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFDictionaryValueCallBacks</span> *valueCallBacks <span class=\"comment\">// 回调</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>键值回调</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span>\t\t\t\tversion;    <span class=\"comment\">//一般为0</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRetainCallBack</span>\t\t<span class=\"keyword\">retain</span>; <span class=\"comment\">//遇到retain的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryReleaseCallBack</span>\t\trelease;<span class=\"comment\">//遇到release的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryCopyDescriptionCallBack</span>\tcopyDescription;<span class=\"comment\">//一般传NULL，采用系统默认</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryEqualCallBack</span>\t\tequal;  <span class=\"comment\">//一般传CFEqual</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryHashCallBack</span>\t\thash;   <span class=\"comment\">//一般传CFHash</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">CFDictionaryKeyCallBacks</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span>\t\t\t\tversion;    <span class=\"comment\">//一般为0</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRetainCallBack</span>\t\t<span class=\"keyword\">retain</span>; <span class=\"comment\">//遇到retain的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryReleaseCallBack</span>\t\trelease;<span class=\"comment\">//遇到release的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryCopyDescriptionCallBack</span>\tcopyDescription;    <span class=\"comment\">//一般传NULL，采用系统默认</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryEqualCallBack</span>\t\tequal;  <span class=\"comment\">//一般传CFEqual</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">CFDictionaryValueCallBacks</span>;</span><br></pre></td></tr></table></figure>\n<p>创建“保留”键，“保留”值的 NSDictionary</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* EOCRetainCallback (<span class=\"built_in\">CFAllocatorRef</span> allocator , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CFRetain</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> EOCReleaseCallback(<span class=\"built_in\">CFAllocatorRef</span> allocator , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryKeyCallBacks</span> keyCallbacks = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCRetainCallback,</span><br><span class=\"line\">    EOCReleaseCallback,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFEqual</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFHash</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryValueCallBacks</span> valueCallbacks = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCRetainCallback,</span><br><span class=\"line\">    EOCReleaseCallback,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFEqual</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> aCFDictionary = <span class=\"built_in\">CFDictionaryCreateMutable</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, &amp;keyCallbacks, &amp;valueCallbacks);</span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *anNSdictionary = (__bridge_transfer <span class=\"built_in\">NSMutableDictionary</span> *)aCFDictionary;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第50条：构建缓存时选用NSCache而非NSDictionary\"><a href=\"#第50条：构建缓存时选用NSCache而非NSDictionary\" class=\"headerlink\" title=\"第50条：构建缓存时选用NSCache而非NSDictionary\"></a>第50条：构建缓存时选用NSCache而非NSDictionary</h2><ul>\n<li>实现缓存时应选用 NSCache 而非 NSDictionary</li>\n<li>可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据</li>\n<li>NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）</li>\n<li>NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）</li>\n<li>使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除</li>\n</ul>\n<p>扩展阅读：<a href=\"https://www.ganlvji.com/nscache/\" target=\"_blank\" rel=\"noopener\">利用NSCache提升效率</a></p>\n<h2 id=\"第51条：精简initialize与load的实现代码\"><a href=\"#第51条：精简initialize与load的实现代码\" class=\"headerlink\" title=\"第51条：精简initialize与load的实现代码\"></a>第51条：精简initialize与load的实现代码</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">load</th>\n<th style=\"text-align:center\">initialize</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">执行次数</td>\n<td style=\"text-align:center\">1次</td>\n<td style=\"text-align:center\">1次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">执行时机</td>\n<td style=\"text-align:center\">app启动时所有运行时需要用到的类</td>\n<td style=\"text-align:center\">惰性调用，需要使用到具体类的时候才调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">作用</td>\n<td style=\"text-align:center\">调试 现基本不用</td>\n<td style=\"text-align:center\">初始化全局oc对象（普通对象可以在声明的时候初始化）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">执行时环境</td>\n<td style=\"text-align:center\">系统不稳定，许多东西尚未初始化</td>\n<td style=\"text-align:center\">系统处于正常状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">调用顺序</td>\n<td style=\"text-align:center\">1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类</td>\n<td style=\"text-align:center\">跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">相同点</td>\n<td style=\"text-align:center\">1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁</td>\n<td style=\"text-align:center\">同左</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\"><a href=\"#initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\" class=\"headerlink\" title=\"initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\"></a>initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）</h3><p>假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">A</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">A</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">B</span> : <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>此时创建一个B对象，输出是</p>\n<blockquote>\n<p>A<br>B</p>\n</blockquote>\n<p>初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B</p>\n<p>所以 A 的 initialize 方法应该这样写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [A <span class=\"keyword\">class</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时创建一个B对象，输出是</p>\n<blockquote>\n<p>B</p>\n</blockquote>\n<h2 id=\"第52条：别忘了NSTimer会保留其目标对象\"><a href=\"#第52条：别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"第52条：别忘了NSTimer会保留其目标对象\"></a>第52条：别忘了NSTimer会保留其目标对象</h2><p>参见：<a href=\"http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/\">NSTimer 会保留目标对象</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第1章-熟悉Objective—C\"><a href=\"#第1章-熟悉Objective—C\" class=\"headerlink\" title=\"第1章 熟悉Objective—C\"></a>第1章 熟悉Objective—C</h1><h2 id=\"第1条：了解Objective—C语言的起源\"><a href=\"#第1条：了解Objective—C语言的起源\" class=\"headerlink\" title=\"第1条：了解Objective—C语言的起源\"></a>第1条：了解Objective—C语言的起源</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *s1 = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *s2 = s1;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>s1 和s2 的内存分配在栈上</li>\n<li>@”Hello”的内存分配在堆上</li>\n<li>s1 和 s2 指向同一块内存</li>\n</ul>\n<h2 id=\"第2条：在类的头文件中尽量少引入其他头文件\"><a href=\"#第2条：在类的头文件中尽量少引入其他头文件\" class=\"headerlink\" title=\"第2条：在类的头文件中尽量少引入其他头文件\"></a>第2条：在类的头文件中尽量少引入其他头文件</h2><h2 id=\"第3条：多用字面量语法，少用与之等价的方法\"><a href=\"#第3条：多用字面量语法，少用与之等价的方法\" class=\"headerlink\" title=\"第3条：多用字面量语法，少用与之等价的方法\"></a>第3条：多用字面量语法，少用与之等价的方法</h2><h3 id=\"使用字面量语法，它是一种语法糖：\"><a href=\"#使用字面量语法，它是一种语法糖：\" class=\"headerlink\" title=\"使用字面量语法，它是一种语法糖：\"></a>使用字面量语法，它是一种语法糖：</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *intNum = @<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *doubleNum = @<span class=\"number\">2.5</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *charNum = @<span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *boolNum = @YES;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"hello\"</span>, @<span class=\"number\">1</span>, @<span class=\"number\">2.5</span>, @<span class=\"string\">'a'</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *str2 = array[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dic = @&#123;<span class=\"string\">@\"1\"</span>:@<span class=\"number\">1</span>, <span class=\"string\">@\"2\"</span>:@<span class=\"number\">2</span>&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"这个语法糖更容易暴露隐藏的问题\"><a href=\"#这个语法糖更容易暴露隐藏的问题\" class=\"headerlink\" title=\"这个语法糖更容易暴露隐藏的问题\"></a>这个语法糖更容易暴露隐藏的问题</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array1 = [<span class=\"built_in\">NSArray</span> arrayWithObjects: obj1, obj2, obj3, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array2 = @[obj1, obj2, obj3];</span><br></pre></td></tr></table></figure>\n<p>如果 obj1 和 obj3 非空，而 obj2 是 nil</p>\n<p>那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常</p>\n<h3 id=\"使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\"><a href=\"#使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\" class=\"headerlink\" title=\"使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\"></a>使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMuatableArray</span> *mArray = [@[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>] mutableCopy];</span><br></pre></td></tr></table></figure>\n<h2 id=\"第4条：多用类型常量，少用-define预处理指令\"><a href=\"#第4条：多用类型常量，少用-define预处理指令\" class=\"headerlink\" title=\"第4条：多用类型常量，少用#define预处理指令\"></a>第4条：多用类型常量，少用#define预处理指令</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/5080301.html\" target=\"_blank\" rel=\"noopener\">NSNotification Name 最佳写法</a></p>\n<h2 id=\"第5条：用枚举表示状态、选项、状态码\"><a href=\"#第5条：用枚举表示状态、选项、状态码\" class=\"headerlink\" title=\"第5条：用枚举表示状态、选项、状态码\"></a>第5条：用枚举表示状态、选项、状态码</h2><h3 id=\"使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，\"><a href=\"#使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，\" class=\"headerlink\" title=\"使用 NS_ENUM 和 NS_OPTIONS 来表示状态机，\"></a>使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 来表示<code>状态机</code>，</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NS_ENUM，定义状态等普通枚举</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, TTGState) &#123;</span><br><span class=\"line\">    TTGStateOK = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGStateError,</span><br><span class=\"line\">    TTGStateUnknow</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NS_OPTIONS，定义选项</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, TTGDirection) &#123;</span><br><span class=\"line\">    TTGDirectionNone = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGDirectionTop = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGDirectionLeft = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">    TTGDirectionRight = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">    TTGDirectionBottom = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示\"><a href=\"#如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示\" class=\"headerlink\" title=\"如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用 NS_OPTIONS，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用或操作将其组合起来进行表示\"></a>如果一个<code>枚举变量</code>可以同时表示一个或多个选项的集合，那么应当使用 <code>NS_OPTIONS</code>，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用<code>或操作</code>将其组合起来进行表示</h3><h3 id=\"相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\"><a href=\"#相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\" class=\"headerlink\" title=\"相比较 C 语言中的枚举，使用 NS_ENUM 和 NS_OPTIONS 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\"></a>相比较 C 语言中的枚举，使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> _TTGState &#123;</span><br><span class=\"line\">    TTGStateOK  = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGStateError,</span><br><span class=\"line\">    TTGStateUnknow</span><br><span class=\"line\">&#125; TTGState;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举\"><a href=\"#处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举\" class=\"headerlink\" title=\"处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举\"></a>处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举</h3><h3 id=\"参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\"><a href=\"#参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\" class=\"headerlink\" title=\"参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\"></a>参考链接：<a href=\"http://tutuge.me/2015/03/21/effective-objective-c-5-enum/\" target=\"_blank\" rel=\"noopener\">Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5</a></h3><h1 id=\"第2章-对象、消息、运行期\"><a href=\"#第2章-对象、消息、运行期\" class=\"headerlink\" title=\"第2章 对象、消息、运行期\"></a>第2章 对象、消息、运行期</h1><h2 id=\"第6条：理解“属性”这一概念\"><a href=\"#第6条：理解“属性”这一概念\" class=\"headerlink\" title=\"第6条：理解“属性”这一概念\"></a>第6条：理解“属性”这一概念</h2><h3 id=\"理解好属性和实例变量的区别\"><a href=\"#理解好属性和实例变量的区别\" class=\"headerlink\" title=\"理解好属性和实例变量的区别\"></a>理解好<code>属性</code>和<code>实例变量</code>的区别</h3><p>属性 = 实例变量 + setter + getter</p>\n<p>如果声明属性</p>\n<pre><code>@property (nonatomic, copy) NSString *str;\n</code></pre><p>则编译器会默认实现</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setStr:(<span class=\"built_in\">NSString</span> *)str;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setStr:(<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_str = [str <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>_str</code> 就是<code>实例变量</code></p>\n<h3 id=\"使用点语法访问属性-调用-setter-getter-方法\"><a href=\"#使用点语法访问属性-调用-setter-getter-方法\" class=\"headerlink\" title=\"使用点语法访问属性 = 调用 setter/getter 方法\"></a>使用<code>点语法</code>访问属性 = 调用 setter/getter 方法</h3><h3 id=\"Property-的4种-attribute\"><a href=\"#Property-的4种-attribute\" class=\"headerlink\" title=\"Property 的4种 attribute\"></a>Property 的4种 attribute</h3><ul>\n<li>原子性(atomic, nonatomic)</li>\n<li>读写权限(readonly, readwrite)</li>\n<li>内存管理(strong, weak, unsafe_unretained, retain, assign, copy)</li>\n<li>存取方法(getter, setter)</li>\n</ul>\n<h3 id=\"非-ARC-下，没有-weak\"><a href=\"#非-ARC-下，没有-weak\" class=\"headerlink\" title=\"非 ARC 下，没有 weak\"></a>非 ARC 下，没有 weak</h3><h3 id=\"ARC下，修饰指针的内存修饰符\"><a href=\"#ARC下，修饰指针的内存修饰符\" class=\"headerlink\" title=\"ARC下，修饰指针的内存修饰符\"></a>ARC下，修饰指针的内存修饰符</h3><ul>\n<li><code>__weak</code>:不retain，如果对象被回收，该指针会被置nil</li>\n<li><code>__strong</code>:默认，如果对象被回收，需要手动将指针置为nil？</li>\n<li><code>__unsafe__unretained</code>:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）</li>\n<li><code>__autoreleasing</code>:实现把对象”按引用传递”给方法，变量在方法返回时自动释放</li>\n</ul>\n<p>编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量</p>\n<h3 id=\"常见数据类型的内存修饰符（待补充）\"><a href=\"#常见数据类型的内存修饰符（待补充）\" class=\"headerlink\" title=\"常见数据类型的内存修饰符（待补充）\"></a>常见数据类型的内存修饰符（待补充）</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">内存修饰符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">基本数据类型(int, NSInteger)</td>\n<td style=\"text-align:center\">assign</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">block</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSString</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableString</td>\n<td style=\"text-align:center\">strong</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSArray</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableArray</td>\n<td style=\"text-align:center\">strong</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"NSArray-用-strong-还是-copy-修饰\"><a href=\"#NSArray-用-strong-还是-copy-修饰\" class=\"headerlink\" title=\"NSArray 用 strong 还是 copy 修饰\"></a>NSArray 用 strong 还是 copy 修饰</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> *strongArray;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>)   <span class=\"built_in\">NSArray</span> *copyedArray;</span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongArray = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyedArray = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableArray = [@[<span class=\"string\">@\"1\"</span>] mutableCopy];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongArray = mutableArray;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyedArray = mutableArray;</span><br><span class=\"line\">    </span><br><span class=\"line\">[mutableArray addObject:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\\n%@\\n%@\"</span>, mutableArray, <span class=\"keyword\">self</span>.strongArray, <span class=\"keyword\">self</span>.copyedArray); <span class=\"comment\">//输出 (1,2) (1,2) (1)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。</p>\n<h2 id=\"第7条：在对象内部尽量直接访问实例变量\"><a href=\"#第7条：在对象内部尽量直接访问实例变量\" class=\"headerlink\" title=\"第7条：在对象内部尽量直接访问实例变量\"></a>第7条：在对象内部尽量直接访问实例变量</h2><h3 id=\"类内使用-self-xxx-和-xxx-的区别\"><a href=\"#类内使用-self-xxx-和-xxx-的区别\" class=\"headerlink\" title=\"类内使用 self.xxx 和 _xxx 的区别\"></a>类内使用 self.xxx 和 _xxx 的区别</h3><ul>\n<li>访问 _xxx 不经过 setter/getter 方法，速度更快</li>\n<li>访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作</li>\n<li>访问 _xxx 不经过 setter/getter 方法，无法触发 KVO</li>\n<li>访问 _xxx 不经过 setter/getter 方法，无法断点</li>\n</ul>\n<h3 id=\"什么时候使用-xxx\"><a href=\"#什么时候使用-xxx\" class=\"headerlink\" title=\"什么时候使用 _xxx\"></a>什么时候使用 _xxx</h3><ul>\n<li>折中方案，读的时候使用 _xxx，写的时候使用 self.xxx</li>\n<li>父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错</li>\n<li>如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性</li>\n<li>使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!_str)</span><br><span class=\"line\">\t\t_str = [[<span class=\"built_in\">NSString</span> alloc] init];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"第8条：理解“对象等同性”这一概念\"><a href=\"#第8条：理解“对象等同性”这一概念\" class=\"headerlink\" title=\"第8条：理解“对象等同性”这一概念\"></a>第8条：理解“对象等同性”这一概念</h2><h2 id=\"第9条：以“类族模式”隐藏实现细节\"><a href=\"#第9条：以“类族模式”隐藏实现细节\" class=\"headerlink\" title=\"第9条：以“类族模式”隐藏实现细节\"></a>第9条：以“类族模式”隐藏实现细节</h2><h2 id=\"第10条：在既有类中使用关联对象存放自定义数据\"><a href=\"#第10条：在既有类中使用关联对象存放自定义数据\" class=\"headerlink\" title=\"第10条：在既有类中使用关联对象存放自定义数据\"></a>第10条：在既有类中使用关联对象存放自定义数据</h2><p>“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> objc_setAssociatedObject (<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> objc_getAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> objc_removeAssociatedObject(<span class=\"keyword\">id</span> object);    <span class=\"comment\">// 移除object上的所有关联对象</span></span><br></pre></td></tr></table></figure>\n<p>其中 objc_AssociationPolicy 是关联对象的属性，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_ASSOCIATION_ASSIGN             --- <span class=\"keyword\">assign</span></span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN_NONATOMIC   --- <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span></span><br><span class=\"line\">OBJC_ASSOCIATION_COPY_NONATOMIC     --- <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span></span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN             --- <span class=\"keyword\">retain</span></span><br><span class=\"line\">OBJC_ASSOCIATION_COPY               --- <span class=\"keyword\">copy</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"与-NSDictionary-的区别\"><a href=\"#与-NSDictionary-的区别\" class=\"headerlink\" title=\"与 NSDictionary 的区别\"></a>与 NSDictionary 的区别</h3><p>设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。</p>\n<p>所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @”xxx”</p>\n<h3 id=\"例子1\"><a href=\"#例子1\" class=\"headerlink\" title=\"例子1\"></a>例子1</h3><p>假如一个页面有2个弹窗，那么代码可能是这样写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)askUserAQuestion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]</span><br><span class=\"line\">            initWithTitle:<span class=\"string\">@\"Question\"</span></span><br><span class=\"line\">                  message:<span class=\"string\">@\"What do you want to do?\"</span></span><br><span class=\"line\">                 delegate:<span class=\"keyword\">self</span></span><br><span class=\"line\">        cancelButtonTitle:<span class=\"string\">@\"Cancel\"</span></span><br><span class=\"line\">        otherButtonTitles:<span class=\"string\">@\"Continue\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [alert show];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UIAlertViewDelegate protocol method</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)alertView:(<span class=\"built_in\">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class=\"built_in\">NSInteger</span>)buttonIndex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buttonIndex == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doCancel];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doContinue];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *EOCMyAlertViewKey = <span class=\"string\">\"EOCMyAlertViewKey\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)askUserAQuestion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]</span><br><span class=\"line\">\t        initWithTitle:<span class=\"string\">@\"Question\"</span></span><br><span class=\"line\">\t              message:<span class=\"string\">@\"What do you want to do?\"</span></span><br><span class=\"line\">\t             delegate:<span class=\"keyword\">self</span></span><br><span class=\"line\">\t    cancelButtonTitle:<span class=\"string\">@\"Cancel\"</span></span><br><span class=\"line\">\t    otherButtonTitles:<span class=\"string\">@\"Continue\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (^block)(<span class=\"built_in\">NSInteger</span>) = ^(<span class=\"built_in\">NSInteger</span> buttonIndex) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (buttonIndex == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\t    [<span class=\"keyword\">self</span> doCancel];</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"keyword\">else</span></span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\t    [<span class=\"keyword\">self</span> doContinue];</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tobjc_setAssociatedObject(alert,</span><br><span class=\"line\">                             EOCMyAlertViewKey,</span><br><span class=\"line\">                             block,</span><br><span class=\"line\">                             OBJC_ASSOCIATION_COPY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t[alert show];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UIAlertViewDelegate protocol method</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)alertView:(<span class=\"built_in\">UIAlertView</span> *)alertView</span><br><span class=\"line\">    clickedButtonAtIndex:(<span class=\"built_in\">NSInteger</span>)buttonIndex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (^block)(<span class=\"built_in\">NSInteger</span>) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);</span><br><span class=\"line\">\tblock(buttonIndex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView</p>\n<h3 id=\"例子2-为协议文件添加属性\"><a href=\"#例子2-为协议文件添加属性\" class=\"headerlink\" title=\"例子2 为协议文件添加属性\"></a>例子2 为协议文件添加属性</h3><p>.h</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"QLJCEONAVRSSFeed.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">QLJCEONAVRSSFeed</span> (<span class=\"title\">contentOffset</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>)<span class=\"built_in\">CGPoint</span> savedOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"QLJCEONAVRSSFeed+contentOffset.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define feed_saved_Off_set_x_key @<span class=\"meta-string\">\"feed_saved_Off_set_x_key\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#define feed_saved_Off_set_y_key @<span class=\"meta-string\">\"feed_saved_Off_set_y_key\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">QLJCEONAVRSSFeed</span> (<span class=\"title\">contentOffset</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> savedOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGPoint</span>)savedOffset</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *xObj = objc_getAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_x_key);</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *yObj = objc_getAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_y_key);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> point = <span class=\"built_in\">CGPointMake</span>([xObj floatValue], [yObj floatValue]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> point;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSavedOffset:(<span class=\"built_in\">CGPoint</span>)savedOffset</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第11条：理解objc-msgSend的作用\"><a href=\"#第11条：理解objc-msgSend的作用\" class=\"headerlink\" title=\"第11条：理解objc_msgSend的作用\"></a>第11条：理解objc_msgSend的作用</h2><p>见 <a href=\"http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/\">Objective-C中的消息转发机制</a></p>\n<h2 id=\"第12条：理解消息转发机制\"><a href=\"#第12条：理解消息转发机制\" class=\"headerlink\" title=\"第12条：理解消息转发机制\"></a>第12条：理解消息转发机制</h2><p>见 <a href=\"http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/\">Objective-C中的消息转发机制</a></p>\n<h2 id=\"第13条：用“方法调配技术”调试“黑盒方法”\"><a href=\"#第13条：用“方法调配技术”调试“黑盒方法”\" class=\"headerlink\" title=\"第13条：用“方法调配技术”调试“黑盒方法”\"></a>第13条：用“方法调配技术”调试“黑盒方法”</h2><p>创建自己的方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSString+MyAdditions.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSString</span> (<span class=\"title\">MyAdditions</span>)</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)myLowercaseString</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *lowercase = [<span class=\"keyword\">self</span> myLowercaseString];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"This is my own method: %@\"</span>, lowercase);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lowercase;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>替换</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method originalMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(lowercaseString));</span><br><span class=\"line\">Method swappedMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(myLowercaseString));</span><br><span class=\"line\">method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure>\n<h2 id=\"第14条：理解“类对象”的用意\"><a href=\"#第14条：理解“类对象”的用意\" class=\"headerlink\" title=\"第14条：理解“类对象”的用意\"></a>第14条：理解“类对象”的用意</h2><h3 id=\"我们所说的-Objective-C-对象究竟是什么\"><a href=\"#我们所说的-Objective-C-对象究竟是什么\" class=\"headerlink\" title=\"我们所说的 Objective-C 对象究竟是什么\"></a>我们所说的 Objective-C 对象究竟是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object&#123;</span><br><span class=\"line\">  Class isa;  <span class=\"comment\">//=&gt; 指向对象所属的类</span></span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>结论：Objective-C 对象 = id = objc_object</p>\n<h3 id=\"那么-Class-是什么\"><a href=\"#那么-Class-是什么\" class=\"headerlink\" title=\"那么 Class 是什么\"></a>那么 Class 是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>\n<h3 id=\"那么-objc-class-又是什么\"><a href=\"#那么-objc-class-又是什么\" class=\"headerlink\" title=\"那么 objc_class 又是什么\"></a>那么 objc_class 又是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;  </span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class super_class;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> version;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> info;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类的继承体系\"><a href=\"#类的继承体系\" class=\"headerlink\" title=\"类的继承体系\"></a>类的继承体系</h3><p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/isa.png\" alt=\"\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"Hello\"</span>;</span><br></pre></td></tr></table></figure>\n<p>str 是一个对象，is a NSString</p>\n<p>NSString 是类，is a NSString metaclass</p>\n<p>NSString metaclass 是元类，类方法就定义在这里</p>\n<h1 id=\"第3章-接口与API设计\"><a href=\"#第3章-接口与API设计\" class=\"headerlink\" title=\"第3章 接口与API设计\"></a>第3章 接口与API设计</h1><h2 id=\"done-第15条：用前缀避免命名空间冲突\"><a href=\"#done-第15条：用前缀避免命名空间冲突\" class=\"headerlink\" title=\"done 第15条：用前缀避免命名空间冲突\"></a>done 第15条：用前缀避免命名空间冲突</h2><h2 id=\"done-第16条：提供“全能初始化方法”\"><a href=\"#done-第16条：提供“全能初始化方法”\" class=\"headerlink\" title=\"done 第16条：提供“全能初始化方法”\"></a>done 第16条：提供“全能初始化方法”</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/4870303.html\" target=\"_blank\" rel=\"noopener\">Designated Initializer</a></p>\n<h2 id=\"done-第17条：实现description方法\"><a href=\"#done-第17条：实现description方法\" class=\"headerlink\" title=\"done 第17条：实现description方法\"></a>done 第17条：实现description方法</h2><h2 id=\"done-第18条：尽量使用不可变对象\"><a href=\"#done-第18条：尽量使用不可变对象\" class=\"headerlink\" title=\"done 第18条：尽量使用不可变对象\"></a>done 第18条：尽量使用不可变对象</h2><ul>\n<li>如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite</li>\n<li>不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法</li>\n</ul>\n<h2 id=\"done-第19条：使用清晰而协调的命名方式\"><a href=\"#done-第19条：使用清晰而协调的命名方式\" class=\"headerlink\" title=\"done 第19条：使用清晰而协调的命名方式:\"></a>done 第19条：使用清晰而协调的命名方式:</h2><h3 id=\"如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了\"><a href=\"#如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了\" class=\"headerlink\" title=\"如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了\"></a>如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了</h3><h3 id=\"对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX\"><a href=\"#对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX\" class=\"headerlink\" title=\"对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX\"></a>对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX</h3><pre><code>@property (nonatomic, assign, getter = isOn) on;\n</code></pre><h2 id=\"done-第20条：为私有方法名加前缀\"><a href=\"#done-第20条：为私有方法名加前缀\" class=\"headerlink\" title=\"done 第20条：为私有方法名加前缀\"></a>done 第20条：为私有方法名加前缀</h2><h2 id=\"done-第21条：理解Objective—C错误模型\"><a href=\"#done-第21条：理解Objective—C错误模型\" class=\"headerlink\" title=\"done 第21条：理解Objective—C错误模型\"></a>done 第21条：理解Objective—C错误模型</h2><h2 id=\"done-第22条：理解NSCopying协议\"><a href=\"#done-第22条：理解NSCopying协议\" class=\"headerlink\" title=\"done 第22条：理解NSCopying协议\"></a>done 第22条：理解NSCopying协议</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/5167194.html\" target=\"_blank\" rel=\"noopener\">浅析Objective-C的copy</a></p>\n<h1 id=\"第4章-协议与分类\"><a href=\"#第4章-协议与分类\" class=\"headerlink\" title=\"第4章 协议与分类\"></a>第4章 协议与分类</h1><h2 id=\"第23条：通过委托与数据源协议进行对象间通信\"><a href=\"#第23条：通过委托与数据源协议进行对象间通信\" class=\"headerlink\" title=\"第23条：通过委托与数据源协议进行对象间通信\"></a>第23条：通过委托与数据源协议进行对象间通信</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>([_delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didReceiveData:)])</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [_delegate networkFetcher:<span class=\"keyword\">self</span> didReceiveData:data];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果上面的代码写了很多次，则可以考虑以下优化：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在扩展中定义结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span>(</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> didReceiveData : <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> didFailWithError : <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125; _delegateFlags; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> </span></span><br><span class=\"line\">EOCNetworkFetcher </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setDelegate:(<span class=\"keyword\">id</span>)delegate</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    _delegate = delegate; <span class=\"comment\">// 缓存委托对象相应方法能力 </span></span><br><span class=\"line\">    _delegateFlags.didReceiveData = [delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didReceiveData:)]; </span><br><span class=\"line\">    _delegateFlags.didFailWithError = [delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didFailWithError:)]; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\">这样每次调用delegate相关方法之前就只需要直接查询标志：</span><br><span class=\"line\"><span class=\"keyword\">if</span>(_delegateFlags.didReceiveData)</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [_delegate networkFetcher:<span class=\"keyword\">self</span> didReceiveData:data]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"done-第24条：将类的实现代码分散到便于管理的数个分类之中\"><a href=\"#done-第24条：将类的实现代码分散到便于管理的数个分类之中\" class=\"headerlink\" title=\"done 第24条：将类的实现代码分散到便于管理的数个分类之中\"></a>done 第24条：将类的实现代码分散到便于管理的数个分类之中</h2><h2 id=\"第25条：总是为第三方类的分类名称加前缀\"><a href=\"#第25条：总是为第三方类的分类名称加前缀\" class=\"headerlink\" title=\"第25条：总是为第三方类的分类名称加前缀\"></a>第25条：总是为第三方类的分类名称加前缀</h2><ol>\n<li>为第三方类添加分类时，总应给其名称加上你专用的前缀</li>\n<li>为第三方类添加分类时，总应给方法名加上你专用的前缀</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">ABC_HTTP</span>)</span></span><br><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)abc_urlEncodedString;</span><br><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)abc_urlDecodedString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"第26条：勿在分类中声明属性\"><a href=\"#第26条：勿在分类中声明属性\" class=\"headerlink\" title=\"第26条：勿在分类中声明属性\"></a>第26条：勿在分类中声明属性</h2><p>属性应该在主类中声明</p>\n<p>如果分类中声明属性需要自己重写 setter 和 getter</p>\n<p>方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *kFriendsPropertyKey = <span class=\"string\">\"kFriendsPropertyKey\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span>(<span class=\"title\">Friendship</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> friends;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"built_in\">NSArray</span>*)friends </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setFriends:(<span class=\"built_in\">NSArray</span>*)friends </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　objc_setAssociaedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>缺点如下</p>\n<ol>\n<li>相似的代码要写很多遍</li>\n<li>极易忽略属性定义的内存管理语义，且不好维护</li>\n</ol>\n<h2 id=\"第27条：使用“class—continuation分类”隐藏实现细节\"><a href=\"#第27条：使用“class—continuation分类”隐藏实现细节\" class=\"headerlink\" title=\"第27条：使用“class—continuation分类”隐藏实现细节\"></a>第27条：使用“class—continuation分类”隐藏实现细节</h2><p>声明私有实例变量的3种方法</p>\n<ul>\n<li><p>方法1：对外暴露，声明为 private（暴露了细节，不建议）</p>\n<p>  .h</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>:<span class=\"title\">NSObject</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">@private</span></span><br><span class=\"line\">    XYZ *_xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>把私有变量放在头文件，暴露了细节，不好</li>\n<li>假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题</li>\n<li>所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>方法2：不对外暴露</p>\n<p>  .m</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *_xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) XYZ *xyz2;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法3：对外只读，对内读写</p>\n<p>  .h</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) XYZ *xyz;</span><br></pre></td></tr></table></figure>\n<p>  .m</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readwrite</span>) XYZ *xyz;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"done-第28条：通过协议提供匿名对象\"><a href=\"#done-第28条：通过协议提供匿名对象\" class=\"headerlink\" title=\"done 第28条：通过协议提供匿名对象\"></a>done 第28条：通过协议提供匿名对象</h2><h1 id=\"第5章-内存管理\"><a href=\"#第5章-内存管理\" class=\"headerlink\" title=\"第5章 内存管理\"></a>第5章 内存管理</h1><h2 id=\"第29条：理解引用计数\"><a href=\"#第29条：理解引用计数\" class=\"headerlink\" title=\"第29条：理解引用计数\"></a>第29条：理解引用计数</h2><h3 id=\"悬浮指针\"><a href=\"#悬浮指针\" class=\"headerlink\" title=\"悬浮指针\"></a>悬浮指针</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number = [[<span class=\"built_in\">NSNumber</span> alloc] initWithInt:<span class=\"number\">1</span>];</span><br><span class=\"line\">[array addObject:number];</span><br><span class=\"line\">[number release];</span><br><span class=\"line\">number = <span class=\"literal\">nil</span>;   <span class=\"comment\">//如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"autorelease\"><a href=\"#autorelease\" class=\"headerlink\" title=\"autorelease\"></a>autorelease</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringValue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"Hello\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放</p>\n<p>但是，这是十分不合理的，因为从方法名上看（不含<code>alloc/new/copy/mutableCopy</code>），调用者并不知道它需要负责释放该对象</p>\n<p>所以此时，autorelease 就应运而生了</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringValue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"Hello\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [str autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>str 对象会在其所在的释放池释放的时候被释放</p>\n<p>如果外部需要 retain 该返回值，则需要这样做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = [[<span class=\"keyword\">self</span> stringValue] <span class=\"keyword\">retain</span>];</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">[str release];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间</p>\n</blockquote>\n<h2 id=\"第30条：以ARC简化引用计数\"><a href=\"#第30条：以ARC简化引用计数\" class=\"headerlink\" title=\"第30条：以ARC简化引用计数\"></a>第30条：以ARC简化引用计数</h2><h3 id=\"ARC-的本质是自动添加-release-retian-autorelease-等\"><a href=\"#ARC-的本质是自动添加-release-retian-autorelease-等\" class=\"headerlink\" title=\"ARC 的本质是自动添加 release/retian/autorelease 等\"></a>ARC 的本质是自动添加 release/retian/autorelease 等</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (XYZ *)newXYZ</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (XYZ *)createXYZ</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">/*ARC自动添加</span></span><br><span class=\"line\"><span class=\"comment\">    xyz = [xyz autorelease];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)f</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz1 = [XYZ newXYZ];</span><br><span class=\"line\">    XYZ *xyz2 = [XYZ createXYZ];</span><br><span class=\"line\">    <span class=\"comment\">/*ARC自动添加</span></span><br><span class=\"line\"><span class=\"comment\">    [xyz1 release];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展阅读：iOS开发ARC内存管理技术要点\"><a href=\"#扩展阅读：iOS开发ARC内存管理技术要点\" class=\"headerlink\" title=\"扩展阅读：iOS开发ARC内存管理技术要点\"></a>扩展阅读：<a href=\"http://www.cnblogs.com/flyFreeZn/p/4264220.html\" target=\"_blank\" rel=\"noopener\">iOS开发ARC内存管理技术要点</a></h3><h2 id=\"done-第31条：在dealloc方法中只释放引用并解除监听\"><a href=\"#done-第31条：在dealloc方法中只释放引用并解除监听\" class=\"headerlink\" title=\"done 第31条：在dealloc方法中只释放引用并解除监听\"></a>done 第31条：在dealloc方法中只释放引用并解除监听</h2><h2 id=\"done-第32条：编写“异常安全代码”时留意内存管理问题\"><a href=\"#done-第32条：编写“异常安全代码”时留意内存管理问题\" class=\"headerlink\" title=\"done 第32条：编写“异常安全代码”时留意内存管理问题\"></a>done 第32条：编写“异常安全代码”时留意内存管理问题</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];</span><br><span class=\"line\"> [object release];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏</p>\n<p>解决方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EOCSomeClass *object;</span><br><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@finally</span> &#123;</span><br><span class=\"line\"> [object release];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理，ARC 下也会发生这个问题</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题</p>\n<p>总结：</p>\n<ol>\n<li>当捕获到异常,应该注意确保@try中创建的对象被清理完成.</li>\n<li>ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.</li>\n</ol>\n<h2 id=\"done-第33条：以弱引用避免保留环\"><a href=\"#done-第33条：以弱引用避免保留环\" class=\"headerlink\" title=\"done 第33条：以弱引用避免保留环\"></a>done 第33条：以弱引用避免保留环</h2><h2 id=\"done-第34条：以“自动释放池块”降低内存峰值\"><a href=\"#done-第34条：以“自动释放池块”降低内存峰值\" class=\"headerlink\" title=\"done 第34条：以“自动释放池块”降低内存峰值\"></a>done 第34条：以“自动释放池块”降低内存峰值</h2><p>ARC下，可以使用 @autoreleasepool 来降低内存峰值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9999</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span>&#123;</span><br><span class=\"line\">        A *a = [[A alloc] init];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> handle:a];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>a 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值</p>\n<p>使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用</p>\n<p>另外，关于降低内存峰值的之前也有学习过，见<a href=\"http://www.cnblogs.com/chenyg32/p/3859110.html\" target=\"_blank\" rel=\"noopener\">Objective-C 内存管理</a></p>\n<h2 id=\"done-第35条：用“僵尸对象”调试内存管理问题\"><a href=\"#done-第35条：用“僵尸对象”调试内存管理问题\" class=\"headerlink\" title=\"done 第35条：用“僵尸对象”调试内存管理问题\"></a>done 第35条：用“僵尸对象”调试内存管理问题</h2><p>僵尸对象是调试内存管理问题的最佳方式</p>\n<p>被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。</p>\n<p>打开僵尸对象的方法：</p>\n<p>Xcode -&gt; Run -&gt; Diagnostics -&gt; Enable Zombie Objects<br><img src=\"http://img.blog.csdn.net/20150803102818758\" alt=\"\"></p>\n<p>僵尸对象的原理：</p>\n<p>替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存</p>\n<p>原理代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Obtain the class of the object being deallocated</span></span><br><span class=\"line\">Class cls = object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the class's name</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *clsName = class_getName(cls);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prepend _NSZombie_ to the class name</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *zombieClsName = <span class=\"string\">@\"_NSZombie_\"</span> + clsName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// See if the specific zombie class exists</span></span><br><span class=\"line\">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If the specific zombie class doesn't exists,</span></span><br><span class=\"line\"><span class=\"comment\">// then it needs to be created</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!zombieCls)&#123;</span><br><span class=\"line\"><span class=\"comment\">// Obtain the template  zombie class, where the new class's </span></span><br><span class=\"line\"><span class=\"comment\">// name is the prepended string from above</span></span><br><span class=\"line\">   zombieCls = objc_duplicateClass(baseZombieCls,   </span><br><span class=\"line\">   zombieClsName,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Perform normal destruction of the object being deallocated</span></span><br><span class=\"line\">objc_destructInstance(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set the class of the object being deallocated</span></span><br><span class=\"line\"><span class=\"comment\">// to the zombie class</span></span><br><span class=\"line\">objc_setClass(<span class=\"keyword\">self</span>, zombieCls) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The class of \"self\" is now _NSZombie_OriginalClass</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"done-第36条：不要使用retainCount\"><a href=\"#done-第36条：不要使用retainCount\" class=\"headerlink\" title=\"done 第36条：不要使用retainCount\"></a>done 第36条：不要使用retainCount</h2><h1 id=\"第6章-块与大中枢派发\"><a href=\"#第6章-块与大中枢派发\" class=\"headerlink\" title=\"第6章 块与大中枢派发\"></a>第6章 块与大中枢派发</h1><h2 id=\"done-第37条：理解“块”这一概念\"><a href=\"#done-第37条：理解“块”这一概念\" class=\"headerlink\" title=\"done 第37条：理解“块”这一概念\"></a>done 第37条：理解“块”这一概念</h2><pre><code>在Objective-C语言中，一共有3种类型的block：\n_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。\n_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。\n_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。\n</code></pre><ul>\n<li><p>全局 Block：_NSConcreteGlobalBlock</p>\n<ul>\n<li>定义在函数外面的 block 是全局静态的，没有访问任何外部变量</li>\n<li><p>定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的</p>\n<p>问题：那么定义在函数外部的，捕获变量的，是 global 吗？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ^&#123; printf(<span class=\"string\">\"Hello, World!\\n\"</span>); &#125; ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>栈 Block：_NSConcreteStackBlock</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    ^&#123; printf(<span class=\"string\">\"%c\\n\"</span>,a); &#125; ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>堆 Block：_NSConcreteMallocBlock</p>\n<p>  NSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = [^&#123; printf(<span class=\"string\">\"%c\\n\"</span>,a); &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>对全局 Block 进行 copy 后，什么事也不会发生\n对栈 Block 进行 copy 后，会得到一个堆 Block\n对堆 Block 进行 copy 后，其引用计数会加1\n</code></pre></li>\n<li><p>例子</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^blcok)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    block = ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n<p>  block执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放</p>\n<p>  正确做法是</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^blcok)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    block = [^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更多细节见<a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/\" target=\"_blank\" rel=\"noopener\">《谈Objective-C block的实现》</a></p>\n</li>\n</ul>\n<h2 id=\"done-第38条：为常用的块类型创建typedef\"><a href=\"#done-第38条：为常用的块类型创建typedef\" class=\"headerlink\" title=\"done 第38条：为常用的块类型创建typedef\"></a>done 第38条：为常用的块类型创建typedef</h2><h2 id=\"done-第39条：用handler块降低代码分散程度\"><a href=\"#done-第39条：用handler块降低代码分散程度\" class=\"headerlink\" title=\"done 第39条：用handler块降低代码分散程度\"></a>done 第39条：用handler块降低代码分散程度</h2><h2 id=\"第40条：用块引用其所属对象时不要出现保留环\"><a href=\"#第40条：用块引用其所属对象时不要出现保留环\" class=\"headerlink\" title=\"第40条：用块引用其所属对象时不要出现保留环\"></a>第40条：用块引用其所属对象时不要出现保留环</h2><p>例子1</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOCNetworkFetcher.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class=\"built_in\">NSData</span> *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSURL</span> *url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithURL:(<span class=\"built_in\">NSURL</span>*)url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOCNetworkFetcher.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCNetworkFetcher.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readwrite</span>) <span class=\"built_in\">NSURL</span> *url;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) EOCNetworkFetcherCompletionHandler completionHandler;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSData</span> *downloadedData;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCNetworkFetcher</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithURL:(<span class=\"built_in\">NSURL</span>*)url</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])) &#123;</span><br><span class=\"line\">\t\t\t\t_url = url;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">self</span>.completionHandler = completion;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Start the request</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Request sets downloadedData property</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// When request is finished, p_requestCompleted is called</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)p_requestCompleted &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_completionHandler) &#123;</span><br><span class=\"line\">\t\t\t\t_completionHandler(_downloadedData);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCClass</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EOCNetworkFetcher* _networkFetcher;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span>* _fetchedData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span>* url = [[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"http://www.example.com/something.dat\"</span>];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t[_networkFetcher startWithCompletionHandler:^(<span class=\"built_in\">NSData</span> *data)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Request URL %@ finished\"</span>, _networkFetcher.url);</span><br><span class=\"line\">\t\t\t\t_fetchedData = data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>EoCClass -&gt; networkFetcher -&gt; block -&gt; self(通过_fetchedData)</p>\n<p>例子2</p>\n<p>将 networkFetcher 变为局部变量，修改如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadData &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSURL</span> *url = [[<span class=\"built_in\">NSURL</span> alloc] initWithString:</span><br><span class=\"line\"> <span class=\"string\">@\"http://www.example.com/something.dat\"</span>];</span><br><span class=\"line\"> EOCNetworkFetcher *networkFetcher =</span><br><span class=\"line\"> [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class=\"line\"> [networkFetcher startWithCompletionHandler:^(<span class=\"built_in\">NSData</span> *data)&#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Request URL %@ finished\"</span>, networkFetcher.url);</span><br><span class=\"line\"> _fetchedData = data;</span><br><span class=\"line\"> &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>networkFetcher -&gt; block -&gt; networkFetcher(通过url)</p>\n<h2 id=\"第41条：多用派发队列，少用同步锁\"><a href=\"#第41条：多用派发队列，少用同步锁\" class=\"headerlink\" title=\"第41条：多用派发队列，少用同步锁\"></a>第41条：多用派发队列，少用同步锁</h2><h2 id=\"第42条：多用GCD，少用performSelector系列方法\"><a href=\"#第42条：多用GCD，少用performSelector系列方法\" class=\"headerlink\" title=\"第42条：多用GCD，少用performSelector系列方法\"></a>第42条：多用GCD，少用performSelector系列方法</h2><h3 id=\"如何延迟执行一个方法\"><a href=\"#如何延迟执行一个方法\" class=\"headerlink\" title=\"如何延迟执行一个方法\"></a>如何延迟执行一个方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1：使用 performSelector</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(foo) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">5.0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2：使用 dispatch_after</span></span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">5.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> foo];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>\n<p>当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消</p>\n<h3 id=\"如何让一个方法在主线程执行\"><a href=\"#如何让一个方法在主线程执行\" class=\"headerlink\" title=\"如何让一个方法在主线程执行\"></a>如何让一个方法在主线程执行</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1：使用 performSelector</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(foo) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2：使用 dispatch_after</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> foo];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>\n<h2 id=\"第43条：掌握GCD及操作队列的使用时机\"><a href=\"#第43条：掌握GCD及操作队列的使用时机\" class=\"headerlink\" title=\"第43条：掌握GCD及操作队列的使用时机\"></a>第43条：掌握GCD及操作队列的使用时机</h2><p>要知道有个东西叫做 NSOperationQueue 就行了</p>\n<h2 id=\"第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务\"><a href=\"#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务\" class=\"headerlink\" title=\"第44条：通过Dispatch Group机制，根据系统资源状况来执行任务\"></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务</h2><h2 id=\"第45条：使用dispatch-once来执行只需运行一次的线程安全代码\"><a href=\"#第45条：使用dispatch-once来执行只需运行一次的线程安全代码\" class=\"headerlink\" title=\"第45条：使用dispatch_once来执行只需运行一次的线程安全代码\"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h2><p>以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once</p>\n<p>比如单例的书写方式<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"第46条：不要使用dispatch-get-current-queue\"><a href=\"#第46条：不要使用dispatch-get-current-queue\" class=\"headerlink\" title=\"第46条：不要使用dispatch_get_current_queue\"></a>第46条：不要使用<code>dispatch_get_current_queue</code></h2><p>尽量别用，该接口已废弃</p>\n<h1 id=\"第7章-系统框架\"><a href=\"#第7章-系统框架\" class=\"headerlink\" title=\"第7章 系统框架\"></a>第7章 系统框架</h1><h2 id=\"第47条：熟悉系统框架\"><a href=\"#第47条：熟悉系统框架\" class=\"headerlink\" title=\"第47条：熟悉系统框架\"></a>第47条：熟悉系统框架</h2><ul>\n<li>CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）</li>\n<li>CoreAudio:音频处理 API（C语言）</li>\n<li>AVFoundation:视频处理接口（Objective-C）</li>\n<li>CoreData:数据库接口（Objective-C）</li>\n<li>CoreText:文字渲染排版接口（C语言）</li>\n</ul>\n<h2 id=\"done-第48条：多用块枚举，少用for循环\"><a href=\"#done-第48条：多用块枚举，少用for循环\" class=\"headerlink\" title=\"done 第48条：多用块枚举，少用for循环\"></a>done 第48条：多用块枚举，少用for循环</h2><h2 id=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"><a href=\"#第49条：对自定义其内存管理语义的collection使用无缝桥接\" class=\"headerlink\" title=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h2><h3 id=\"使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构\"><a href=\"#使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构\" class=\"headerlink\" title=\"使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构\"></a>使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ count: %li\"</span>, cfArray, <span class=\"built_in\">CFArrayGetCount</span>(cfArray));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray</li>\n<li>CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数</li>\n</ul>\n<h3 id=\"桥式转换\"><a href=\"#桥式转换\" class=\"headerlink\" title=\"桥式转换\"></a>桥式转换</h3><ul>\n<li><code>__bridge</code>：只做类型转换，不修改对象（内存）管理权；</li>\n<li><code>__bridge_retained</code>：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；</li>\n<li><code>__bridge_transfer</code>：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge_retained <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(cfArray);  <span class=\"comment\">// 因为是 __bridge_retained，所以需要调用 CFRelease</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge_retained <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array2 = (__bridge_transfer <span class=\"built_in\">NSArray</span> *)cfArray;</span><br><span class=\"line\"><span class=\"comment\">//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用无缝桥接修改-Collection-的内存管理语义\"><a href=\"#使用无缝桥接修改-Collection-的内存管理语义\" class=\"headerlink\" title=\"使用无缝桥接修改 Collection 的内存管理语义\"></a>使用无缝桥接修改 Collection 的内存管理语义</h3><p>NSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error</p>\n<p>关于拷贝协议可以查看：<a href=\"http://www.cnblogs.com/chenyg32/p/5167194.html\" target=\"_blank\" rel=\"noopener\">浅析Objective-C的copy</a></p>\n<p>无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典</p>\n<p>创建函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> <span class=\"built_in\">CFDictionaryCreateMutable</span>(</span><br><span class=\"line\">    <span class=\"built_in\">CFAllocatorRef</span> allocator,  <span class=\"comment\">// 一般传NULL，采用系统默认的内存分配器</span></span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span> capacity,          <span class=\"comment\">// 初始大小，并非最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFDictionaryKeyCallBacks</span> *keyCallBacks,    <span class=\"comment\">// 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFDictionaryValueCallBacks</span> *valueCallBacks <span class=\"comment\">// 回调</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>键值回调</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span>\t\t\t\tversion;    <span class=\"comment\">//一般为0</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRetainCallBack</span>\t\t<span class=\"keyword\">retain</span>; <span class=\"comment\">//遇到retain的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryReleaseCallBack</span>\t\trelease;<span class=\"comment\">//遇到release的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryCopyDescriptionCallBack</span>\tcopyDescription;<span class=\"comment\">//一般传NULL，采用系统默认</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryEqualCallBack</span>\t\tequal;  <span class=\"comment\">//一般传CFEqual</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryHashCallBack</span>\t\thash;   <span class=\"comment\">//一般传CFHash</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">CFDictionaryKeyCallBacks</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span>\t\t\t\tversion;    <span class=\"comment\">//一般为0</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRetainCallBack</span>\t\t<span class=\"keyword\">retain</span>; <span class=\"comment\">//遇到retain的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryReleaseCallBack</span>\t\trelease;<span class=\"comment\">//遇到release的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryCopyDescriptionCallBack</span>\tcopyDescription;    <span class=\"comment\">//一般传NULL，采用系统默认</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryEqualCallBack</span>\t\tequal;  <span class=\"comment\">//一般传CFEqual</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">CFDictionaryValueCallBacks</span>;</span><br></pre></td></tr></table></figure>\n<p>创建“保留”键，“保留”值的 NSDictionary</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* EOCRetainCallback (<span class=\"built_in\">CFAllocatorRef</span> allocator , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CFRetain</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> EOCReleaseCallback(<span class=\"built_in\">CFAllocatorRef</span> allocator , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryKeyCallBacks</span> keyCallbacks = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCRetainCallback,</span><br><span class=\"line\">    EOCReleaseCallback,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFEqual</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFHash</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryValueCallBacks</span> valueCallbacks = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCRetainCallback,</span><br><span class=\"line\">    EOCReleaseCallback,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFEqual</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> aCFDictionary = <span class=\"built_in\">CFDictionaryCreateMutable</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, &amp;keyCallbacks, &amp;valueCallbacks);</span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *anNSdictionary = (__bridge_transfer <span class=\"built_in\">NSMutableDictionary</span> *)aCFDictionary;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第50条：构建缓存时选用NSCache而非NSDictionary\"><a href=\"#第50条：构建缓存时选用NSCache而非NSDictionary\" class=\"headerlink\" title=\"第50条：构建缓存时选用NSCache而非NSDictionary\"></a>第50条：构建缓存时选用NSCache而非NSDictionary</h2><ul>\n<li>实现缓存时应选用 NSCache 而非 NSDictionary</li>\n<li>可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据</li>\n<li>NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）</li>\n<li>NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）</li>\n<li>使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除</li>\n</ul>\n<p>扩展阅读：<a href=\"https://www.ganlvji.com/nscache/\" target=\"_blank\" rel=\"noopener\">利用NSCache提升效率</a></p>\n<h2 id=\"第51条：精简initialize与load的实现代码\"><a href=\"#第51条：精简initialize与load的实现代码\" class=\"headerlink\" title=\"第51条：精简initialize与load的实现代码\"></a>第51条：精简initialize与load的实现代码</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">load</th>\n<th style=\"text-align:center\">initialize</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">执行次数</td>\n<td style=\"text-align:center\">1次</td>\n<td style=\"text-align:center\">1次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">执行时机</td>\n<td style=\"text-align:center\">app启动时所有运行时需要用到的类</td>\n<td style=\"text-align:center\">惰性调用，需要使用到具体类的时候才调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">作用</td>\n<td style=\"text-align:center\">调试 现基本不用</td>\n<td style=\"text-align:center\">初始化全局oc对象（普通对象可以在声明的时候初始化）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">执行时环境</td>\n<td style=\"text-align:center\">系统不稳定，许多东西尚未初始化</td>\n<td style=\"text-align:center\">系统处于正常状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">调用顺序</td>\n<td style=\"text-align:center\">1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类</td>\n<td style=\"text-align:center\">跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">相同点</td>\n<td style=\"text-align:center\">1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁</td>\n<td style=\"text-align:center\">同左</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\"><a href=\"#initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\" class=\"headerlink\" title=\"initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\"></a>initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）</h3><p>假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">A</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">A</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">B</span> : <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>此时创建一个B对象，输出是</p>\n<blockquote>\n<p>A<br>B</p>\n</blockquote>\n<p>初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B</p>\n<p>所以 A 的 initialize 方法应该这样写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [A <span class=\"keyword\">class</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时创建一个B对象，输出是</p>\n<blockquote>\n<p>B</p>\n</blockquote>\n<h2 id=\"第52条：别忘了NSTimer会保留其目标对象\"><a href=\"#第52条：别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"第52条：别忘了NSTimer会保留其目标对象\"></a>第52条：别忘了NSTimer会保留其目标对象</h2><p>参见：<a href=\"http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/\">NSTimer 会保留目标对象</a></p>\n"},{"title":"NSUserdefaults与NSMutableArray的坑","date":"2016-06-11T16:00:00.000Z","keywords":"NSUserdefaults;NSMutableArray;死锁;mutex lock;immutable","_content":"\n# 需求\nApp 本地记录用户看过的视频记录\n# 方案\n很简单的需求，我们可以使用 NSUserDefaults 来维护一个数组，每次有新的视频记录产生的时候，如果该视频记录不存在，则添加进数组，并更新 NSUserDefaults，否则不做任何操作\n\n# 代码与坑\n## 版本一\n很直观地，我写出了下面这段代码\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] objectForKey:VIDEOKEY]; \nif (![videoArray containsObject:item])  //nil at first time\n{\n    [videoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n问题来了\n\n+ 如果是首次运行这段代码，videoArray 将会是空的，之后对 videoArray 做的一切操作都是没用的\n\n## 版本二\n\n好，继续修改我们的代码，确保 videoArray 不空\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] objectForKey:VIDEOKEY];\nif (!videoArray)\n    videoArray = [NSMutableArray array];\nif (![videoArray containsObject:item])\n{\n    [videoArray addObject:item];    //crash\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n问题来了\n\n+ 第一次插入元素没问题，但是第二次插入的时候在`[videoArray addObject:item];`就 Crash 了\n\nCrash信息：\n\n```objectivec\nTerminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'\n```\n\n为什么？因为我对 NSUserDefaults 的理解出错了，其实\n\n```objectivec\nNSUserDefaults 的 objectForKey 方法永远返回不可变对象\n(NSUserDefaults will always return an immutable version of the object you pass in)\n```\n\n+ 第一次运行，videoArray 是一个 NSMutableArray（__NSArrayM），往 NSUserDefaults 里塞 NSMutableArray 也不会出错\n+ 第二次运行，videoArray 已经存在，它是一个 NSArray（__NSCFArray），NSArray 执行 addObject，必挂无疑！\n\n## 版本三\n好啊，那 NSUserDefaults 会不会有可以返回可变对象的接口呢，比如\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];\nif (![videoArray containsObject:item])\n{\n    [videoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n这样看起来好像很完美，但是要明白的是\n\n+ `mutableArrayValueForKey` 是 KVC 里面的内容，而不是 NSUserDefaults 里的\n+ 即使 key 没找到，`mutableArrayValueForKey` 也不会返回 nil，所以这一段代码不需要做非空判断\n+ videoArray 打印出来是一个 `NSKeyValueSlowMutableArray`\n+ 其实如果直接修改 KVC 获取的这个可变对象而不写入 NSUserDefaults，其实是会影响 NSUserDefaults 里的内容，所以删除最后一行代码运行结果也是对的\n+ NSUserdefaults 返回不可变对象一定有它的原因（比如不想返回的对象被别人直接修改，而是必须通过自身的`setObject:forKey:`接口来修改），这里其实是借 KVC 的手实现了获得一个可变对象，这其实是违背了 NSUserdefaults 的初衷的，这种做法不可取\n\n但是，这里还有个最大最大的问题，**死锁**，留到后面讲。\n\n## 版本四\n最终版本出炉，使用`arrayForKey:`获取数组，并新建一个可变数组来执行增删操作\n\n```objectivec\nNSMutableArray *mutableVideoArray;\nNSArray *videoArray = [[NSUserDefaults standardUserDefaults] arrayForKey:VIDEOKEY];\nif (videoArray)\n    mutableVideoArray = [videoArray mutableCopy];\nelse\n    mutableVideoArray = [NSMutableArray array];\n    \nif (![mutableVideoArray containsObject:item])\n{\n    [mutableVideoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:mutableVideoArray forKey:VIDEOKEY];\n}\n```\n+ 这里使用`arrayForKey`而不是`objectForKey`，这样更贴切。\n\n# 关于死锁\n经实验，下面是发生死锁需要的最少行的代码\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];\n[videoArray addObject:item];\n[[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n```\n1. 如果删除`[videoArray addObject:item];`这一行，直接 Crash，因此要研究死锁问题，必须先保证数组非空，所以这里是最少代码\n2. 发生死锁是在最后一行代码里，是 iOS8 及以后版本的系统 bug（不过这种使用方法根本不对，也可以不算是 bug）\n3. 如果断点在最后一行，则不会死锁，而断点在第二行还是会死锁。因为断点错开了代码之间执行的时间，所以我们有理由推测，死锁是 KVC 里面的 addObject: 与 setObject: 同时进行的时候而产生的\n4. [StackOverFlow](http://stackoverflow.com/questions/26004892/ios-8-freezes-at-updating-userdefaults-object)上有类似问题\n\n# 结论\n+ 使用 NSUserDefaults 的时候注意非空判断\n+ NSUserDefaults 的 objectForKey 方法永远返回不可变对象，但 setObject:forKey: 的 object 参数可以是可变对象\n+ mutableArrayValueForKey 是 KVC 里面的内容，而不是 NSUserDefaults 里的，不建议使用它来获取 NSUserDefaults 的内容\n+ NSUserDefaults+KVC 的组合在 iOS8 及其之后是会有死锁的问题\n\n","source":"_posts/NSUserdefaults与NSMutableArray的坑.md","raw":"---\ntitle: NSUserdefaults与NSMutableArray的坑\ndate: 2016-06-12\ncategories:\n- iOS\nkeywords: NSUserdefaults;NSMutableArray;死锁;mutex lock;immutable\n---\n\n# 需求\nApp 本地记录用户看过的视频记录\n# 方案\n很简单的需求，我们可以使用 NSUserDefaults 来维护一个数组，每次有新的视频记录产生的时候，如果该视频记录不存在，则添加进数组，并更新 NSUserDefaults，否则不做任何操作\n\n# 代码与坑\n## 版本一\n很直观地，我写出了下面这段代码\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] objectForKey:VIDEOKEY]; \nif (![videoArray containsObject:item])  //nil at first time\n{\n    [videoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n问题来了\n\n+ 如果是首次运行这段代码，videoArray 将会是空的，之后对 videoArray 做的一切操作都是没用的\n\n## 版本二\n\n好，继续修改我们的代码，确保 videoArray 不空\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] objectForKey:VIDEOKEY];\nif (!videoArray)\n    videoArray = [NSMutableArray array];\nif (![videoArray containsObject:item])\n{\n    [videoArray addObject:item];    //crash\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n问题来了\n\n+ 第一次插入元素没问题，但是第二次插入的时候在`[videoArray addObject:item];`就 Crash 了\n\nCrash信息：\n\n```objectivec\nTerminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'\n```\n\n为什么？因为我对 NSUserDefaults 的理解出错了，其实\n\n```objectivec\nNSUserDefaults 的 objectForKey 方法永远返回不可变对象\n(NSUserDefaults will always return an immutable version of the object you pass in)\n```\n\n+ 第一次运行，videoArray 是一个 NSMutableArray（__NSArrayM），往 NSUserDefaults 里塞 NSMutableArray 也不会出错\n+ 第二次运行，videoArray 已经存在，它是一个 NSArray（__NSCFArray），NSArray 执行 addObject，必挂无疑！\n\n## 版本三\n好啊，那 NSUserDefaults 会不会有可以返回可变对象的接口呢，比如\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];\nif (![videoArray containsObject:item])\n{\n    [videoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n这样看起来好像很完美，但是要明白的是\n\n+ `mutableArrayValueForKey` 是 KVC 里面的内容，而不是 NSUserDefaults 里的\n+ 即使 key 没找到，`mutableArrayValueForKey` 也不会返回 nil，所以这一段代码不需要做非空判断\n+ videoArray 打印出来是一个 `NSKeyValueSlowMutableArray`\n+ 其实如果直接修改 KVC 获取的这个可变对象而不写入 NSUserDefaults，其实是会影响 NSUserDefaults 里的内容，所以删除最后一行代码运行结果也是对的\n+ NSUserdefaults 返回不可变对象一定有它的原因（比如不想返回的对象被别人直接修改，而是必须通过自身的`setObject:forKey:`接口来修改），这里其实是借 KVC 的手实现了获得一个可变对象，这其实是违背了 NSUserdefaults 的初衷的，这种做法不可取\n\n但是，这里还有个最大最大的问题，**死锁**，留到后面讲。\n\n## 版本四\n最终版本出炉，使用`arrayForKey:`获取数组，并新建一个可变数组来执行增删操作\n\n```objectivec\nNSMutableArray *mutableVideoArray;\nNSArray *videoArray = [[NSUserDefaults standardUserDefaults] arrayForKey:VIDEOKEY];\nif (videoArray)\n    mutableVideoArray = [videoArray mutableCopy];\nelse\n    mutableVideoArray = [NSMutableArray array];\n    \nif (![mutableVideoArray containsObject:item])\n{\n    [mutableVideoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:mutableVideoArray forKey:VIDEOKEY];\n}\n```\n+ 这里使用`arrayForKey`而不是`objectForKey`，这样更贴切。\n\n# 关于死锁\n经实验，下面是发生死锁需要的最少行的代码\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];\n[videoArray addObject:item];\n[[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n```\n1. 如果删除`[videoArray addObject:item];`这一行，直接 Crash，因此要研究死锁问题，必须先保证数组非空，所以这里是最少代码\n2. 发生死锁是在最后一行代码里，是 iOS8 及以后版本的系统 bug（不过这种使用方法根本不对，也可以不算是 bug）\n3. 如果断点在最后一行，则不会死锁，而断点在第二行还是会死锁。因为断点错开了代码之间执行的时间，所以我们有理由推测，死锁是 KVC 里面的 addObject: 与 setObject: 同时进行的时候而产生的\n4. [StackOverFlow](http://stackoverflow.com/questions/26004892/ios-8-freezes-at-updating-userdefaults-object)上有类似问题\n\n# 结论\n+ 使用 NSUserDefaults 的时候注意非空判断\n+ NSUserDefaults 的 objectForKey 方法永远返回不可变对象，但 setObject:forKey: 的 object 参数可以是可变对象\n+ mutableArrayValueForKey 是 KVC 里面的内容，而不是 NSUserDefaults 里的，不建议使用它来获取 NSUserDefaults 的内容\n+ NSUserDefaults+KVC 的组合在 iOS8 及其之后是会有死锁的问题\n\n","slug":"NSUserdefaults与NSMutableArray的坑","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp2opl390008u3qwsnjxk6l7","content":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>App 本地记录用户看过的视频记录</p>\n<h1 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h1><p>很简单的需求，我们可以使用 NSUserDefaults 来维护一个数组，每次有新的视频记录产生的时候，如果该视频记录不存在，则添加进数组，并更新 NSUserDefaults，否则不做任何操作</p>\n<h1 id=\"代码与坑\"><a href=\"#代码与坑\" class=\"headerlink\" title=\"代码与坑\"></a>代码与坑</h1><h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>很直观地，我写出了下面这段代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:VIDEOKEY]; </span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])  <span class=\"comment\">//nil at first time</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了</p>\n<ul>\n<li>如果是首次运行这段代码，videoArray 将会是空的，之后对 videoArray 做的一切操作都是没用的</li>\n</ul>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>好，继续修改我们的代码，确保 videoArray 不空</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!videoArray)</span><br><span class=\"line\">    videoArray = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];    <span class=\"comment\">//crash</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了</p>\n<ul>\n<li>第一次插入元素没问题，但是第二次插入的时候在<code>[videoArray addObject:item];</code>就 Crash 了</li>\n</ul>\n<p>Crash信息：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'</span><br></pre></td></tr></table></figure>\n<p>为什么？因为我对 NSUserDefaults 的理解出错了，其实</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUserDefaults</span> 的 objectForKey 方法永远返回不可变对象</span><br><span class=\"line\">(<span class=\"built_in\">NSUserDefaults</span> will always <span class=\"keyword\">return</span> an immutable version of the object you pass <span class=\"keyword\">in</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一次运行，videoArray 是一个 NSMutableArray（__NSArrayM），往 NSUserDefaults 里塞 NSMutableArray 也不会出错</li>\n<li>第二次运行，videoArray 已经存在，它是一个 NSArray（__NSCFArray），NSArray 执行 addObject，必挂无疑！</li>\n</ul>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><p>好啊，那 NSUserDefaults 会不会有可以返回可变对象的接口呢，比如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来好像很完美，但是要明白的是</p>\n<ul>\n<li><code>mutableArrayValueForKey</code> 是 KVC 里面的内容，而不是 NSUserDefaults 里的</li>\n<li>即使 key 没找到，<code>mutableArrayValueForKey</code> 也不会返回 nil，所以这一段代码不需要做非空判断</li>\n<li>videoArray 打印出来是一个 <code>NSKeyValueSlowMutableArray</code></li>\n<li>其实如果直接修改 KVC 获取的这个可变对象而不写入 NSUserDefaults，其实是会影响 NSUserDefaults 里的内容，所以删除最后一行代码运行结果也是对的</li>\n<li>NSUserdefaults 返回不可变对象一定有它的原因（比如不想返回的对象被别人直接修改，而是必须通过自身的<code>setObject:forKey:</code>接口来修改），这里其实是借 KVC 的手实现了获得一个可变对象，这其实是违背了 NSUserdefaults 的初衷的，这种做法不可取</li>\n</ul>\n<p>但是，这里还有个最大最大的问题，<strong>死锁</strong>，留到后面讲。</p>\n<h2 id=\"版本四\"><a href=\"#版本四\" class=\"headerlink\" title=\"版本四\"></a>版本四</h2><p>最终版本出炉，使用<code>arrayForKey:</code>获取数组，并新建一个可变数组来执行增删操作</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableVideoArray;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] arrayForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (videoArray)</span><br><span class=\"line\">    mutableVideoArray = [videoArray mutableCopy];</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    mutableVideoArray = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> (![mutableVideoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [mutableVideoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:mutableVideoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里使用<code>arrayForKey</code>而不是<code>objectForKey</code>，这样更贴切。</li>\n</ul>\n<h1 id=\"关于死锁\"><a href=\"#关于死锁\" class=\"headerlink\" title=\"关于死锁\"></a>关于死锁</h1><p>经实验，下面是发生死锁需要的最少行的代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];</span><br><span class=\"line\">[videoArray addObject:item];</span><br><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果删除<code>[videoArray addObject:item];</code>这一行，直接 Crash，因此要研究死锁问题，必须先保证数组非空，所以这里是最少代码</li>\n<li>发生死锁是在最后一行代码里，是 iOS8 及以后版本的系统 bug（不过这种使用方法根本不对，也可以不算是 bug）</li>\n<li>如果断点在最后一行，则不会死锁，而断点在第二行还是会死锁。因为断点错开了代码之间执行的时间，所以我们有理由推测，死锁是 KVC 里面的 addObject: 与 setObject: 同时进行的时候而产生的</li>\n<li><a href=\"http://stackoverflow.com/questions/26004892/ios-8-freezes-at-updating-userdefaults-object\" target=\"_blank\" rel=\"noopener\">StackOverFlow</a>上有类似问题</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><ul>\n<li>使用 NSUserDefaults 的时候注意非空判断</li>\n<li>NSUserDefaults 的 objectForKey 方法永远返回不可变对象，但 setObject:forKey: 的 object 参数可以是可变对象</li>\n<li>mutableArrayValueForKey 是 KVC 里面的内容，而不是 NSUserDefaults 里的，不建议使用它来获取 NSUserDefaults 的内容</li>\n<li>NSUserDefaults+KVC 的组合在 iOS8 及其之后是会有死锁的问题</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>App 本地记录用户看过的视频记录</p>\n<h1 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h1><p>很简单的需求，我们可以使用 NSUserDefaults 来维护一个数组，每次有新的视频记录产生的时候，如果该视频记录不存在，则添加进数组，并更新 NSUserDefaults，否则不做任何操作</p>\n<h1 id=\"代码与坑\"><a href=\"#代码与坑\" class=\"headerlink\" title=\"代码与坑\"></a>代码与坑</h1><h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>很直观地，我写出了下面这段代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:VIDEOKEY]; </span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])  <span class=\"comment\">//nil at first time</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了</p>\n<ul>\n<li>如果是首次运行这段代码，videoArray 将会是空的，之后对 videoArray 做的一切操作都是没用的</li>\n</ul>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>好，继续修改我们的代码，确保 videoArray 不空</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!videoArray)</span><br><span class=\"line\">    videoArray = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];    <span class=\"comment\">//crash</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了</p>\n<ul>\n<li>第一次插入元素没问题，但是第二次插入的时候在<code>[videoArray addObject:item];</code>就 Crash 了</li>\n</ul>\n<p>Crash信息：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'</span><br></pre></td></tr></table></figure>\n<p>为什么？因为我对 NSUserDefaults 的理解出错了，其实</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUserDefaults</span> 的 objectForKey 方法永远返回不可变对象</span><br><span class=\"line\">(<span class=\"built_in\">NSUserDefaults</span> will always <span class=\"keyword\">return</span> an immutable version of the object you pass <span class=\"keyword\">in</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一次运行，videoArray 是一个 NSMutableArray（__NSArrayM），往 NSUserDefaults 里塞 NSMutableArray 也不会出错</li>\n<li>第二次运行，videoArray 已经存在，它是一个 NSArray（__NSCFArray），NSArray 执行 addObject，必挂无疑！</li>\n</ul>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><p>好啊，那 NSUserDefaults 会不会有可以返回可变对象的接口呢，比如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来好像很完美，但是要明白的是</p>\n<ul>\n<li><code>mutableArrayValueForKey</code> 是 KVC 里面的内容，而不是 NSUserDefaults 里的</li>\n<li>即使 key 没找到，<code>mutableArrayValueForKey</code> 也不会返回 nil，所以这一段代码不需要做非空判断</li>\n<li>videoArray 打印出来是一个 <code>NSKeyValueSlowMutableArray</code></li>\n<li>其实如果直接修改 KVC 获取的这个可变对象而不写入 NSUserDefaults，其实是会影响 NSUserDefaults 里的内容，所以删除最后一行代码运行结果也是对的</li>\n<li>NSUserdefaults 返回不可变对象一定有它的原因（比如不想返回的对象被别人直接修改，而是必须通过自身的<code>setObject:forKey:</code>接口来修改），这里其实是借 KVC 的手实现了获得一个可变对象，这其实是违背了 NSUserdefaults 的初衷的，这种做法不可取</li>\n</ul>\n<p>但是，这里还有个最大最大的问题，<strong>死锁</strong>，留到后面讲。</p>\n<h2 id=\"版本四\"><a href=\"#版本四\" class=\"headerlink\" title=\"版本四\"></a>版本四</h2><p>最终版本出炉，使用<code>arrayForKey:</code>获取数组，并新建一个可变数组来执行增删操作</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableVideoArray;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] arrayForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (videoArray)</span><br><span class=\"line\">    mutableVideoArray = [videoArray mutableCopy];</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    mutableVideoArray = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> (![mutableVideoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [mutableVideoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:mutableVideoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里使用<code>arrayForKey</code>而不是<code>objectForKey</code>，这样更贴切。</li>\n</ul>\n<h1 id=\"关于死锁\"><a href=\"#关于死锁\" class=\"headerlink\" title=\"关于死锁\"></a>关于死锁</h1><p>经实验，下面是发生死锁需要的最少行的代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];</span><br><span class=\"line\">[videoArray addObject:item];</span><br><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果删除<code>[videoArray addObject:item];</code>这一行，直接 Crash，因此要研究死锁问题，必须先保证数组非空，所以这里是最少代码</li>\n<li>发生死锁是在最后一行代码里，是 iOS8 及以后版本的系统 bug（不过这种使用方法根本不对，也可以不算是 bug）</li>\n<li>如果断点在最后一行，则不会死锁，而断点在第二行还是会死锁。因为断点错开了代码之间执行的时间，所以我们有理由推测，死锁是 KVC 里面的 addObject: 与 setObject: 同时进行的时候而产生的</li>\n<li><a href=\"http://stackoverflow.com/questions/26004892/ios-8-freezes-at-updating-userdefaults-object\" target=\"_blank\" rel=\"noopener\">StackOverFlow</a>上有类似问题</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><ul>\n<li>使用 NSUserDefaults 的时候注意非空判断</li>\n<li>NSUserDefaults 的 objectForKey 方法永远返回不可变对象，但 setObject:forKey: 的 object 参数可以是可变对象</li>\n<li>mutableArrayValueForKey 是 KVC 里面的内容，而不是 NSUserDefaults 里的，不建议使用它来获取 NSUserDefaults 的内容</li>\n<li>NSUserDefaults+KVC 的组合在 iOS8 及其之后是会有死锁的问题</li>\n</ul>\n"},{"title":"Objective-C中的消息转发机制","date":"2016-09-24T16:00:00.000Z","photos":[],"keywords":"Objective-C;objc_msgSend;消息转发;runtime;dynamic;","_content":"\n# Objective-C 中函数调用的实质\n\n```objc\nid returnValue = [someObj messageName:params];\n\n// 运行时转化为\nid returnValue = objc_msgSend(someObj, @selector(messageName:), params);\n```\n注意：\n\n从该接收者所属的类的方法列表中寻找（每次找到都会缓存下，以供下次查找用），找不到就沿着继承树向上搜索，最后还是没找到，就执行消息转发\n\n# 消息转发分为三大阶段\n第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做__动态方法解析__（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。\n\n第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。\n\n第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/msgSend.png)\n\n## 动态方法解析\n对象在收到无法响应的消息后，会调用其所属类的下列方法\n\n```objc\n/**\n *  如果尚未实现的方法是实例方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增实例方法用以处理selector\n */\n+ (BOOL)resolveInstanceMethod:(SEL)selector;\n/**\n *  如果尚未实现的方法是类方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增类方法用以处理selector\n */\n+ (BOOL)resolveClassMethod:(SEL)selector;\n```\n\n## 备援接收者\n如果无法动态解析方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为\n\n```objc\n/**\n *  此方法询问是否能将消息转给其他接收者来处理\n *\n *  @param aSelector 未处理的方法\n *\n *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；\n */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n```\n\n## 完整的消息转发机制\n如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为\n\n```objc\n/**\n *  消息派发系统通过此方法，将消息派发给目标对象\n *\n *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容\n */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n\n# 例子：利用消息转发机制实现@dynamic属性\n.h\n\n```objc\n#import <Foundation/Foundation.h>\n\n@interface NCYAutoDictionary : NSObject\n@property (nonatomic,strong) NSString *myName;\n@end\n```\n.m\n\n```objc\n#import \"NCYAutoDictionary.h\"\n#import <objc/message.h>\n\nid autoDictionaryGetter(id self, SEL _cmd);\nvoid autoDictionarySetter(id self, SEL _cmd, id value);\n\n@interface NCYAutoDictionary ()\n@property (nonatomic, strong) NSMutableDictionary *backingStore;\n@end\n\n@implementation NCYAutoDictionary\n@dynamic myName;\n\n- (instancetype)init\n{\n\tif (self = [super init])\n\t{\n\t\t_backingStore = [NSMutableDictionary new];\n\t}\n\treturn self;\n}\n\nid autoDictionaryGetter(id self, SEL _cmd)\n{\n\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)self;\n\tNSMutableDictionary *backingStore = typeSelf.backingStore;\n\n\tNSString *key = NSStringFromSelector(_cmd);\n\n\treturn [backingStore objectForKey:key];\n}\n\nvoid autoDictionarySetter(id self, SEL _cmd, id value)\n{\n\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)self;\n\tNSMutableDictionary *backingStore = typeSelf.backingStore;\n\n\tNSString *seletorString = NSStringFromSelector(_cmd);\n\n\tNSMutableString *key = [seletorString mutableCopy];\n\n\t// 将 \"setSomething:\" 转为 \"something\"\n\t// remove :\n\t[key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];\n\n\t// remove set\n\t[key deleteCharactersInRange:NSMakeRange(0, 3)];\n\n\t// lowercase the first character\n\tNSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];\n\n\t[key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];\n\n\tif (value)\n\t{\n\t\t[backingStore setObject:value forKey:key];\n\t}\n\telse\n\t{\n\t\t[backingStore removeObjectForKey:key];\n\t}\n}\n\n// 运行时动态添加方法，对于同一个SEL，执行完该函数后，就不会再次走到这里，因为方法已经添加到类中去了（程序运行时都有效）\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n\tNSString *selectorString = NSStringFromSelector(sel);\n\tif ([selectorString hasPrefix:@\"set\"])\n\t{\n\t\tclass_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");\n\t}\n\telse\n\t{\n\t\tclass_addMethod(self, sel, (IMP)autoDictionaryGetter, \"@@:\");\n\t}\n\treturn true;\n}\n@end\n```\n\n测试\n\n```objc\nNCYAutoDictionary *myDic = [[NCYAutoDictionary alloc] init];\nmyDic.myName = @\"Norcy\";\nNSLog(@\"%@\", myDic.myName);   // 打印\"Norcy\"\n```\n## 注意\n1. 对于同一个SEL，执行完 `resolveInstanceMethod:` 后，下次调用该SEL的方法时，就不会再次执行 `resolveInstanceMethod:`，因为方法已经添加到类中去了（程序运行时都有效）\n2. `class_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");`\n\n    最后一个参数是编码格式，详见[苹果官方文档](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)\n3. `autoDictionarySetter`的参数是怎么确定的？\n\n    因为外部调用的时候其实是 `[myDic setMyName:@\"Norcy\"]`\n    \n    即 `objc_msgSend(myDic, @selector(setMyName:), @\"Norcy\")`\n    \n    经过 `resolveInstanceMethod:` 替换之后，`setMyName:` 的消息都会转发给 `autoDictionarySetter` 来实现\n    \n    `autoDictionarySetter` 是一个 IMP，默认的参数就有2个，id self 和 SEL _cmd，最后一个参数 value 是 `setMyName:` 带过来的参数，以此确定\n\n# 参考文章\n+ 《Effective Objective-C 2.0》第11条和第12条\n","source":"_posts/Objective-C中的消息转发机制.md","raw":"---\ntitle: Objective-C中的消息转发机制\ndate: 2016-09-25\ncategories:\n- iOS\nphotos: \nkeywords: Objective-C;objc_msgSend;消息转发;runtime;dynamic;\n---\n\n# Objective-C 中函数调用的实质\n\n```objc\nid returnValue = [someObj messageName:params];\n\n// 运行时转化为\nid returnValue = objc_msgSend(someObj, @selector(messageName:), params);\n```\n注意：\n\n从该接收者所属的类的方法列表中寻找（每次找到都会缓存下，以供下次查找用），找不到就沿着继承树向上搜索，最后还是没找到，就执行消息转发\n\n# 消息转发分为三大阶段\n第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做__动态方法解析__（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。\n\n第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。\n\n第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/msgSend.png)\n\n## 动态方法解析\n对象在收到无法响应的消息后，会调用其所属类的下列方法\n\n```objc\n/**\n *  如果尚未实现的方法是实例方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增实例方法用以处理selector\n */\n+ (BOOL)resolveInstanceMethod:(SEL)selector;\n/**\n *  如果尚未实现的方法是类方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增类方法用以处理selector\n */\n+ (BOOL)resolveClassMethod:(SEL)selector;\n```\n\n## 备援接收者\n如果无法动态解析方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为\n\n```objc\n/**\n *  此方法询问是否能将消息转给其他接收者来处理\n *\n *  @param aSelector 未处理的方法\n *\n *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；\n */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n```\n\n## 完整的消息转发机制\n如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为\n\n```objc\n/**\n *  消息派发系统通过此方法，将消息派发给目标对象\n *\n *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容\n */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n\n# 例子：利用消息转发机制实现@dynamic属性\n.h\n\n```objc\n#import <Foundation/Foundation.h>\n\n@interface NCYAutoDictionary : NSObject\n@property (nonatomic,strong) NSString *myName;\n@end\n```\n.m\n\n```objc\n#import \"NCYAutoDictionary.h\"\n#import <objc/message.h>\n\nid autoDictionaryGetter(id self, SEL _cmd);\nvoid autoDictionarySetter(id self, SEL _cmd, id value);\n\n@interface NCYAutoDictionary ()\n@property (nonatomic, strong) NSMutableDictionary *backingStore;\n@end\n\n@implementation NCYAutoDictionary\n@dynamic myName;\n\n- (instancetype)init\n{\n\tif (self = [super init])\n\t{\n\t\t_backingStore = [NSMutableDictionary new];\n\t}\n\treturn self;\n}\n\nid autoDictionaryGetter(id self, SEL _cmd)\n{\n\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)self;\n\tNSMutableDictionary *backingStore = typeSelf.backingStore;\n\n\tNSString *key = NSStringFromSelector(_cmd);\n\n\treturn [backingStore objectForKey:key];\n}\n\nvoid autoDictionarySetter(id self, SEL _cmd, id value)\n{\n\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)self;\n\tNSMutableDictionary *backingStore = typeSelf.backingStore;\n\n\tNSString *seletorString = NSStringFromSelector(_cmd);\n\n\tNSMutableString *key = [seletorString mutableCopy];\n\n\t// 将 \"setSomething:\" 转为 \"something\"\n\t// remove :\n\t[key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];\n\n\t// remove set\n\t[key deleteCharactersInRange:NSMakeRange(0, 3)];\n\n\t// lowercase the first character\n\tNSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];\n\n\t[key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];\n\n\tif (value)\n\t{\n\t\t[backingStore setObject:value forKey:key];\n\t}\n\telse\n\t{\n\t\t[backingStore removeObjectForKey:key];\n\t}\n}\n\n// 运行时动态添加方法，对于同一个SEL，执行完该函数后，就不会再次走到这里，因为方法已经添加到类中去了（程序运行时都有效）\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n\tNSString *selectorString = NSStringFromSelector(sel);\n\tif ([selectorString hasPrefix:@\"set\"])\n\t{\n\t\tclass_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");\n\t}\n\telse\n\t{\n\t\tclass_addMethod(self, sel, (IMP)autoDictionaryGetter, \"@@:\");\n\t}\n\treturn true;\n}\n@end\n```\n\n测试\n\n```objc\nNCYAutoDictionary *myDic = [[NCYAutoDictionary alloc] init];\nmyDic.myName = @\"Norcy\";\nNSLog(@\"%@\", myDic.myName);   // 打印\"Norcy\"\n```\n## 注意\n1. 对于同一个SEL，执行完 `resolveInstanceMethod:` 后，下次调用该SEL的方法时，就不会再次执行 `resolveInstanceMethod:`，因为方法已经添加到类中去了（程序运行时都有效）\n2. `class_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");`\n\n    最后一个参数是编码格式，详见[苹果官方文档](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)\n3. `autoDictionarySetter`的参数是怎么确定的？\n\n    因为外部调用的时候其实是 `[myDic setMyName:@\"Norcy\"]`\n    \n    即 `objc_msgSend(myDic, @selector(setMyName:), @\"Norcy\")`\n    \n    经过 `resolveInstanceMethod:` 替换之后，`setMyName:` 的消息都会转发给 `autoDictionarySetter` 来实现\n    \n    `autoDictionarySetter` 是一个 IMP，默认的参数就有2个，id self 和 SEL _cmd，最后一个参数 value 是 `setMyName:` 带过来的参数，以此确定\n\n# 参考文章\n+ 《Effective Objective-C 2.0》第11条和第12条\n","slug":"Objective-C中的消息转发机制","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","link":"","_id":"cjp2opl3a000au3qwpg2z7r78","content":"<h1 id=\"Objective-C-中函数调用的实质\"><a href=\"#Objective-C-中函数调用的实质\" class=\"headerlink\" title=\"Objective-C 中函数调用的实质\"></a>Objective-C 中函数调用的实质</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> returnValue = [someObj messageName:params];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时转化为</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> returnValue = objc_msgSend(someObj, <span class=\"keyword\">@selector</span>(messageName:), params);</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p>从该接收者所属的类的方法列表中寻找（每次找到都会缓存下，以供下次查找用），找不到就沿着继承树向上搜索，最后还是没找到，就执行消息转发</p>\n<h1 id=\"消息转发分为三大阶段\"><a href=\"#消息转发分为三大阶段\" class=\"headerlink\" title=\"消息转发分为三大阶段\"></a>消息转发分为三大阶段</h1><p>第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做<strong>动态方法解析</strong>（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。</p>\n<p>第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。</p>\n<p>第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/msgSend.png\" alt=\"\"></p>\n<h2 id=\"动态方法解析\"><a href=\"#动态方法解析\" class=\"headerlink\" title=\"动态方法解析\"></a>动态方法解析</h2><p>对象在收到无法响应的消息后，会调用其所属类的下列方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果尚未实现的方法是实例方法，则调用此函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param selector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 返回布尔值，表示是否能新增实例方法用以处理selector</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)selector;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果尚未实现的方法是类方法，则调用此函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param selector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 返回布尔值，表示是否能新增类方法用以处理selector</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)selector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"备援接收者\"><a href=\"#备援接收者\" class=\"headerlink\" title=\"备援接收者\"></a>备援接收者</h2><p>如果无法动态解析方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  此方法询问是否能将消息转给其他接收者来处理</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param aSelector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整的消息转发机制\"><a href=\"#完整的消息转发机制\" class=\"headerlink\" title=\"完整的消息转发机制\"></a>完整的消息转发机制</h2><p>如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  消息派发系统通过此方法，将消息派发给目标对象</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure>\n<h1 id=\"例子：利用消息转发机制实现-dynamic属性\"><a href=\"#例子：利用消息转发机制实现-dynamic属性\" class=\"headerlink\" title=\"例子：利用消息转发机制实现@dynamic属性\"></a>例子：利用消息转发机制实现@dynamic属性</h1><p>.h</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NCYAutoDictionary</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *myName;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NCYAutoDictionary.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> autoDictionaryGetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd);</span><br><span class=\"line\"><span class=\"keyword\">void</span> autoDictionarySetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> value);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NCYAutoDictionary</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *backingStore;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NCYAutoDictionary</span></span></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> myName;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_backingStore = [<span class=\"built_in\">NSMutableDictionary</span> new];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> autoDictionaryGetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)<span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableDictionary</span> *backingStore = typeSelf.backingStore;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *key = <span class=\"built_in\">NSStringFromSelector</span>(_cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> [backingStore objectForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> autoDictionarySetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)<span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableDictionary</span> *backingStore = typeSelf.backingStore;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *seletorString = <span class=\"built_in\">NSStringFromSelector</span>(_cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> *key = [seletorString mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将 \"setSomething:\" 转为 \"something\"</span></span><br><span class=\"line\">\t<span class=\"comment\">// remove :</span></span><br><span class=\"line\">\t[key deleteCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(key.length - <span class=\"number\">1</span>, <span class=\"number\">1</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// remove set</span></span><br><span class=\"line\">\t[key deleteCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// lowercase the first character</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *lowercaseFirstChar = [[key substringToIndex:<span class=\"number\">1</span>] lowercaseString];</span><br><span class=\"line\"></span><br><span class=\"line\">\t[key replaceCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>) withString:lowercaseFirstChar];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (value)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t[backingStore setObject:value forKey:key];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t[backingStore removeObjectForKey:key];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时动态添加方法，对于同一个SEL，执行完该函数后，就不会再次走到这里，因为方法已经添加到类中去了（程序运行时都有效）</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *selectorString = <span class=\"built_in\">NSStringFromSelector</span>(sel);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ([selectorString hasPrefix:<span class=\"string\">@\"set\"</span>])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tclass_addMethod(<span class=\"keyword\">self</span>, sel, (IMP)autoDictionarySetter, <span class=\"string\">\"v@:@\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tclass_addMethod(<span class=\"keyword\">self</span>, sel, (IMP)autoDictionaryGetter, <span class=\"string\">\"@@:\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NCYAutoDictionary *myDic = [[NCYAutoDictionary alloc] init];</span><br><span class=\"line\">myDic.myName = <span class=\"string\">@\"Norcy\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myDic.myName);   <span class=\"comment\">// 打印\"Norcy\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>对于同一个SEL，执行完 <code>resolveInstanceMethod:</code> 后，下次调用该SEL的方法时，就不会再次执行 <code>resolveInstanceMethod:</code>，因为方法已经添加到类中去了（程序运行时都有效）</li>\n<li><p><code>class_addMethod(self, sel, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</code></p>\n<p> 最后一个参数是编码格式，详见<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"noopener\">苹果官方文档</a></p>\n</li>\n<li><p><code>autoDictionarySetter</code>的参数是怎么确定的？</p>\n<p> 因为外部调用的时候其实是 <code>[myDic setMyName:@&quot;Norcy&quot;]</code></p>\n<p> 即 <code>objc_msgSend(myDic, @selector(setMyName:), @&quot;Norcy&quot;)</code></p>\n<p> 经过 <code>resolveInstanceMethod:</code> 替换之后，<code>setMyName:</code> 的消息都会转发给 <code>autoDictionarySetter</code> 来实现</p>\n<p> <code>autoDictionarySetter</code> 是一个 IMP，默认的参数就有2个，id self 和 SEL _cmd，最后一个参数 value 是 <code>setMyName:</code> 带过来的参数，以此确定</p>\n</li>\n</ol>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li>《Effective Objective-C 2.0》第11条和第12条</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objective-C-中函数调用的实质\"><a href=\"#Objective-C-中函数调用的实质\" class=\"headerlink\" title=\"Objective-C 中函数调用的实质\"></a>Objective-C 中函数调用的实质</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> returnValue = [someObj messageName:params];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时转化为</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> returnValue = objc_msgSend(someObj, <span class=\"keyword\">@selector</span>(messageName:), params);</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p>从该接收者所属的类的方法列表中寻找（每次找到都会缓存下，以供下次查找用），找不到就沿着继承树向上搜索，最后还是没找到，就执行消息转发</p>\n<h1 id=\"消息转发分为三大阶段\"><a href=\"#消息转发分为三大阶段\" class=\"headerlink\" title=\"消息转发分为三大阶段\"></a>消息转发分为三大阶段</h1><p>第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做<strong>动态方法解析</strong>（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。</p>\n<p>第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。</p>\n<p>第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/msgSend.png\" alt=\"\"></p>\n<h2 id=\"动态方法解析\"><a href=\"#动态方法解析\" class=\"headerlink\" title=\"动态方法解析\"></a>动态方法解析</h2><p>对象在收到无法响应的消息后，会调用其所属类的下列方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果尚未实现的方法是实例方法，则调用此函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param selector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 返回布尔值，表示是否能新增实例方法用以处理selector</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)selector;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果尚未实现的方法是类方法，则调用此函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param selector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 返回布尔值，表示是否能新增类方法用以处理selector</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)selector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"备援接收者\"><a href=\"#备援接收者\" class=\"headerlink\" title=\"备援接收者\"></a>备援接收者</h2><p>如果无法动态解析方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  此方法询问是否能将消息转给其他接收者来处理</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param aSelector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整的消息转发机制\"><a href=\"#完整的消息转发机制\" class=\"headerlink\" title=\"完整的消息转发机制\"></a>完整的消息转发机制</h2><p>如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  消息派发系统通过此方法，将消息派发给目标对象</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure>\n<h1 id=\"例子：利用消息转发机制实现-dynamic属性\"><a href=\"#例子：利用消息转发机制实现-dynamic属性\" class=\"headerlink\" title=\"例子：利用消息转发机制实现@dynamic属性\"></a>例子：利用消息转发机制实现@dynamic属性</h1><p>.h</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NCYAutoDictionary</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *myName;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NCYAutoDictionary.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> autoDictionaryGetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd);</span><br><span class=\"line\"><span class=\"keyword\">void</span> autoDictionarySetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> value);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NCYAutoDictionary</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *backingStore;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NCYAutoDictionary</span></span></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> myName;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_backingStore = [<span class=\"built_in\">NSMutableDictionary</span> new];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> autoDictionaryGetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)<span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableDictionary</span> *backingStore = typeSelf.backingStore;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *key = <span class=\"built_in\">NSStringFromSelector</span>(_cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> [backingStore objectForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> autoDictionarySetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)<span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableDictionary</span> *backingStore = typeSelf.backingStore;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *seletorString = <span class=\"built_in\">NSStringFromSelector</span>(_cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> *key = [seletorString mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将 \"setSomething:\" 转为 \"something\"</span></span><br><span class=\"line\">\t<span class=\"comment\">// remove :</span></span><br><span class=\"line\">\t[key deleteCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(key.length - <span class=\"number\">1</span>, <span class=\"number\">1</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// remove set</span></span><br><span class=\"line\">\t[key deleteCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// lowercase the first character</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *lowercaseFirstChar = [[key substringToIndex:<span class=\"number\">1</span>] lowercaseString];</span><br><span class=\"line\"></span><br><span class=\"line\">\t[key replaceCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>) withString:lowercaseFirstChar];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (value)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t[backingStore setObject:value forKey:key];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t[backingStore removeObjectForKey:key];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时动态添加方法，对于同一个SEL，执行完该函数后，就不会再次走到这里，因为方法已经添加到类中去了（程序运行时都有效）</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *selectorString = <span class=\"built_in\">NSStringFromSelector</span>(sel);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ([selectorString hasPrefix:<span class=\"string\">@\"set\"</span>])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tclass_addMethod(<span class=\"keyword\">self</span>, sel, (IMP)autoDictionarySetter, <span class=\"string\">\"v@:@\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tclass_addMethod(<span class=\"keyword\">self</span>, sel, (IMP)autoDictionaryGetter, <span class=\"string\">\"@@:\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NCYAutoDictionary *myDic = [[NCYAutoDictionary alloc] init];</span><br><span class=\"line\">myDic.myName = <span class=\"string\">@\"Norcy\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myDic.myName);   <span class=\"comment\">// 打印\"Norcy\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>对于同一个SEL，执行完 <code>resolveInstanceMethod:</code> 后，下次调用该SEL的方法时，就不会再次执行 <code>resolveInstanceMethod:</code>，因为方法已经添加到类中去了（程序运行时都有效）</li>\n<li><p><code>class_addMethod(self, sel, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</code></p>\n<p> 最后一个参数是编码格式，详见<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"noopener\">苹果官方文档</a></p>\n</li>\n<li><p><code>autoDictionarySetter</code>的参数是怎么确定的？</p>\n<p> 因为外部调用的时候其实是 <code>[myDic setMyName:@&quot;Norcy&quot;]</code></p>\n<p> 即 <code>objc_msgSend(myDic, @selector(setMyName:), @&quot;Norcy&quot;)</code></p>\n<p> 经过 <code>resolveInstanceMethod:</code> 替换之后，<code>setMyName:</code> 的消息都会转发给 <code>autoDictionarySetter</code> 来实现</p>\n<p> <code>autoDictionarySetter</code> 是一个 IMP，默认的参数就有2个，id self 和 SEL _cmd，最后一个参数 value 是 <code>setMyName:</code> 带过来的参数，以此确定</p>\n</li>\n</ol>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li>《Effective Objective-C 2.0》第11条和第12条</li>\n</ul>\n"},{"title":"UITableView 中，UICollectionView 相互复用之间 contentOffset","date":"2016-03-27T16:00:00.000Z","photos":["images/view.jpg"],"keywords":"UITableView;UITableViewCell;UICollectionView;contentOffset;复用;reuse","_content":"\n# 问题描述\nUIViewController 中有一个 UITableView，UITableViewCell 的 contentView 上添加了横滑列表，横滑列表是用 UICollectionView 实现的。\n如下图所示\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset1.png)\n\n抽象出来就是这样\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset2.png)\n\n\n其中 UITableView 的 DataSource/Delegate 是 Controller，而 UICollectionView 的 DataSource/Delegate 是 UITableViewCell。\nUITableView 的 DataSource 抽象如下：\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath \n\t{\n\t\tJceObject *cellObj = [_dataModel.aryItems objectAtIndex:indexPath.row];\n\t\tUITableViewCell *cell = [QLThumbsMgr makeCellWithJCEPoster:cellObj tableView:tableView userInfo:self];\n\t\treturn cell;\n\t}\n\n好像看似没什么问题是吧，UITableView 的使用一向都是这样的嘛。可是当 UITableViewCell 碰上了 UICollectionView，问题就出来了。\n左右滑动一个 UICollectionView 使其 contentOffset 不为初始值，再上下滑动 UITableView，你会发现，其他的横滑列表也被横滑了，上个动图直观感受一下\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset3.gif)\n\n# 问题分析\n如果对于 UITableView 的 Cell 复用机制有一定了解的同学一定很容易看出问题，就是因为 Cell 之间的复用导致了 UICollectionView 的 contentOffset 也被复用了。\n\n那么之前我们是如何解决 UITableViewCell 的复用问题呢？就是每次 Cell 出现的时候，就根据数据源更新 Cell 的内容，这样就保证了每次看到的 Cell 是正确的。\n\n但是现在棘手的是数据源中并没有包含 UICollectionView 的 contentOffset。\n\n问题可以转化为如何在 UITableViewCell 出现的时候，更新其 UICollectionView 的 contentOffset。依赖 UITableViewCell 去记住是行不通的，因为它自己就是被复用的对象，那么就要外部去帮它记住，这个外部可以是 UITableView 的 Delegate——UIViewController，也可以 UITableViewCell 的数据源。\n\n如果是数据源，则需要对数据源做一个扩展 or 分类，由于数据源与前后台协议是相关的，改动数据源或许不是一个好的选择。所以这里我选择了让 UIViewController 去完成这个记忆的任务。\n\n# 解决方法\n我们可以为 UIViewController 添加一个 NSMutableDictionary 类型的实例变量，该字典存储的是 UITableViewCell 的位置和其 UICollectionView 的横滑位置的映射关系。\n\n+ UITableViewCell 即将从视野里消失的时候，UIViewController 用 NSMutableDictionary 记录该 Cell 的 indexPath.row 和其 UICollectionView 的 contentOffset；（这里只讨论 UITableView 只有一个 section 的情况，多个 section 的处理原理是一样的）\n\n+ UITableViewCell 即将出现在视野里的时候，UIViewController 根据该 Cell 的 indexPath.row，从 NSMutableDictionary 中读取相应的值去设置该 Cell 上的 UICollectionView 的 contentOffset；\n\nUIViewController 是 UITableView 的 Delegate，UITableViewCell 的出现和消失事件可以在以下2个代理方法中捕捉到。\n`- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;`\n和\n`- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;`\n\n那么，UIViewController 中的代码应该类似这样。\n\n\n\t- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n\t    if ([cell isKindOfClass:[QLONAListCell class]])\n\t\t{\n\t        QLONAListCell *listCell = (QLONAListCell *)cell;\n\t        NSInteger row = indexPath.row;\n\t        CGFloat horizontalOffset;\n\t        horizontalOffset = [self.contentOffsetDict[[@(row) stringValue]] floatValue];\n\t        [listCell.horizontalScrollView setContentOffset:CGPointMake(horizontalOffset, 0)];\n\t    }\n\t}\n\t\n\t- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n\t    if ([cell isKindOfClass:[QLONAListCell class]])\n\t    {\n\t        QLONAListCell *listCell = (QLONAListCell *)cell;\n\t        NSInteger row = indexPath.row;\n\t        CGFloat horizontalOffset = listCell.horizontalScrollView.contentOffset.x;\n\t        self.contentOffsetDict[[@(row) stringValue]] = @(horizontalOffset);\n\t    }\n\t}\n\n其中 QLONAListCell 是 UITableViewCell 的子类，它有一个 UICollectionView 类型的属性 horizontalScrollView。\ncontentOffsetDict 是 UIViewController 的实例变量，它是一个 NSMutableDictionary。\n\n哦，还有一个注意点。当对 UITableView 进行下拉刷新的时候，新数据可能与老数据不一样（比如多了某个 Cell 或少了某个 Cell），那么这种情况下，contentOffsetDict 的记录就不再正确，所以每次在数据请求回来的时候，最好清空一下 contentOffsetDict。这样做的后果就是每次下拉刷新就会清空横滑列表的 contentOffset，不过看起来也似乎合情合理。\n\n# 参考链接\n[Putting a UICollectionView in a UITableViewCell](https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/)","source":"_posts/UITableView 中，UICollectionView 相互复用之间 contentOffset.md","raw":"---\ntitle: UITableView 中，UICollectionView 相互复用之间 contentOffset\ndate: 2016-03-28\ncategories:\n- iOS\nphotos: images/view.jpg\nkeywords: UITableView;UITableViewCell;UICollectionView;contentOffset;复用;reuse\n---\n\n# 问题描述\nUIViewController 中有一个 UITableView，UITableViewCell 的 contentView 上添加了横滑列表，横滑列表是用 UICollectionView 实现的。\n如下图所示\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset1.png)\n\n抽象出来就是这样\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset2.png)\n\n\n其中 UITableView 的 DataSource/Delegate 是 Controller，而 UICollectionView 的 DataSource/Delegate 是 UITableViewCell。\nUITableView 的 DataSource 抽象如下：\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath \n\t{\n\t\tJceObject *cellObj = [_dataModel.aryItems objectAtIndex:indexPath.row];\n\t\tUITableViewCell *cell = [QLThumbsMgr makeCellWithJCEPoster:cellObj tableView:tableView userInfo:self];\n\t\treturn cell;\n\t}\n\n好像看似没什么问题是吧，UITableView 的使用一向都是这样的嘛。可是当 UITableViewCell 碰上了 UICollectionView，问题就出来了。\n左右滑动一个 UICollectionView 使其 contentOffset 不为初始值，再上下滑动 UITableView，你会发现，其他的横滑列表也被横滑了，上个动图直观感受一下\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset3.gif)\n\n# 问题分析\n如果对于 UITableView 的 Cell 复用机制有一定了解的同学一定很容易看出问题，就是因为 Cell 之间的复用导致了 UICollectionView 的 contentOffset 也被复用了。\n\n那么之前我们是如何解决 UITableViewCell 的复用问题呢？就是每次 Cell 出现的时候，就根据数据源更新 Cell 的内容，这样就保证了每次看到的 Cell 是正确的。\n\n但是现在棘手的是数据源中并没有包含 UICollectionView 的 contentOffset。\n\n问题可以转化为如何在 UITableViewCell 出现的时候，更新其 UICollectionView 的 contentOffset。依赖 UITableViewCell 去记住是行不通的，因为它自己就是被复用的对象，那么就要外部去帮它记住，这个外部可以是 UITableView 的 Delegate——UIViewController，也可以 UITableViewCell 的数据源。\n\n如果是数据源，则需要对数据源做一个扩展 or 分类，由于数据源与前后台协议是相关的，改动数据源或许不是一个好的选择。所以这里我选择了让 UIViewController 去完成这个记忆的任务。\n\n# 解决方法\n我们可以为 UIViewController 添加一个 NSMutableDictionary 类型的实例变量，该字典存储的是 UITableViewCell 的位置和其 UICollectionView 的横滑位置的映射关系。\n\n+ UITableViewCell 即将从视野里消失的时候，UIViewController 用 NSMutableDictionary 记录该 Cell 的 indexPath.row 和其 UICollectionView 的 contentOffset；（这里只讨论 UITableView 只有一个 section 的情况，多个 section 的处理原理是一样的）\n\n+ UITableViewCell 即将出现在视野里的时候，UIViewController 根据该 Cell 的 indexPath.row，从 NSMutableDictionary 中读取相应的值去设置该 Cell 上的 UICollectionView 的 contentOffset；\n\nUIViewController 是 UITableView 的 Delegate，UITableViewCell 的出现和消失事件可以在以下2个代理方法中捕捉到。\n`- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;`\n和\n`- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;`\n\n那么，UIViewController 中的代码应该类似这样。\n\n\n\t- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n\t    if ([cell isKindOfClass:[QLONAListCell class]])\n\t\t{\n\t        QLONAListCell *listCell = (QLONAListCell *)cell;\n\t        NSInteger row = indexPath.row;\n\t        CGFloat horizontalOffset;\n\t        horizontalOffset = [self.contentOffsetDict[[@(row) stringValue]] floatValue];\n\t        [listCell.horizontalScrollView setContentOffset:CGPointMake(horizontalOffset, 0)];\n\t    }\n\t}\n\t\n\t- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n\t    if ([cell isKindOfClass:[QLONAListCell class]])\n\t    {\n\t        QLONAListCell *listCell = (QLONAListCell *)cell;\n\t        NSInteger row = indexPath.row;\n\t        CGFloat horizontalOffset = listCell.horizontalScrollView.contentOffset.x;\n\t        self.contentOffsetDict[[@(row) stringValue]] = @(horizontalOffset);\n\t    }\n\t}\n\n其中 QLONAListCell 是 UITableViewCell 的子类，它有一个 UICollectionView 类型的属性 horizontalScrollView。\ncontentOffsetDict 是 UIViewController 的实例变量，它是一个 NSMutableDictionary。\n\n哦，还有一个注意点。当对 UITableView 进行下拉刷新的时候，新数据可能与老数据不一样（比如多了某个 Cell 或少了某个 Cell），那么这种情况下，contentOffsetDict 的记录就不再正确，所以每次在数据请求回来的时候，最好清空一下 contentOffsetDict。这样做的后果就是每次下拉刷新就会清空横滑列表的 contentOffset，不过看起来也似乎合情合理。\n\n# 参考链接\n[Putting a UICollectionView in a UITableViewCell](https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/)","slug":"UITableView 中，UICollectionView 相互复用之间 contentOffset","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","link":"","_id":"cjp2opl3b000bu3qwvjwcjk39","content":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>UIViewController 中有一个 UITableView，UITableViewCell 的 contentView 上添加了横滑列表，横滑列表是用 UICollectionView 实现的。<br>如下图所示</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset1.png\" alt=\"\"></p>\n<p>抽象出来就是这样</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset2.png\" alt=\"\"></p>\n<p>其中 UITableView 的 DataSource/Delegate 是 Controller，而 UICollectionView 的 DataSource/Delegate 是 UITableViewCell。<br>UITableView 的 DataSource 抽象如下：</p>\n<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath \n{\n    JceObject *cellObj = [_dataModel.aryItems objectAtIndex:indexPath.row];\n    UITableViewCell *cell = [QLThumbsMgr makeCellWithJCEPoster:cellObj tableView:tableView userInfo:self];\n    return cell;\n}\n</code></pre><p>好像看似没什么问题是吧，UITableView 的使用一向都是这样的嘛。可是当 UITableViewCell 碰上了 UICollectionView，问题就出来了。<br>左右滑动一个 UICollectionView 使其 contentOffset 不为初始值，再上下滑动 UITableView，你会发现，其他的横滑列表也被横滑了，上个动图直观感受一下</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset3.gif\" alt=\"\"></p>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>如果对于 UITableView 的 Cell 复用机制有一定了解的同学一定很容易看出问题，就是因为 Cell 之间的复用导致了 UICollectionView 的 contentOffset 也被复用了。</p>\n<p>那么之前我们是如何解决 UITableViewCell 的复用问题呢？就是每次 Cell 出现的时候，就根据数据源更新 Cell 的内容，这样就保证了每次看到的 Cell 是正确的。</p>\n<p>但是现在棘手的是数据源中并没有包含 UICollectionView 的 contentOffset。</p>\n<p>问题可以转化为如何在 UITableViewCell 出现的时候，更新其 UICollectionView 的 contentOffset。依赖 UITableViewCell 去记住是行不通的，因为它自己就是被复用的对象，那么就要外部去帮它记住，这个外部可以是 UITableView 的 Delegate——UIViewController，也可以 UITableViewCell 的数据源。</p>\n<p>如果是数据源，则需要对数据源做一个扩展 or 分类，由于数据源与前后台协议是相关的，改动数据源或许不是一个好的选择。所以这里我选择了让 UIViewController 去完成这个记忆的任务。</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>我们可以为 UIViewController 添加一个 NSMutableDictionary 类型的实例变量，该字典存储的是 UITableViewCell 的位置和其 UICollectionView 的横滑位置的映射关系。</p>\n<ul>\n<li><p>UITableViewCell 即将从视野里消失的时候，UIViewController 用 NSMutableDictionary 记录该 Cell 的 indexPath.row 和其 UICollectionView 的 contentOffset；（这里只讨论 UITableView 只有一个 section 的情况，多个 section 的处理原理是一样的）</p>\n</li>\n<li><p>UITableViewCell 即将出现在视野里的时候，UIViewController 根据该 Cell 的 indexPath.row，从 NSMutableDictionary 中读取相应的值去设置该 Cell 上的 UICollectionView 的 contentOffset；</p>\n</li>\n</ul>\n<p>UIViewController 是 UITableView 的 Delegate，UITableViewCell 的出现和消失事件可以在以下2个代理方法中捕捉到。<br><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</code><br>和<br><code>- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;</code></p>\n<p>那么，UIViewController 中的代码应该类似这样。</p>\n<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    if ([cell isKindOfClass:[QLONAListCell class]])\n    {\n        QLONAListCell *listCell = (QLONAListCell *)cell;\n        NSInteger row = indexPath.row;\n        CGFloat horizontalOffset;\n        horizontalOffset = [self.contentOffsetDict[[@(row) stringValue]] floatValue];\n        [listCell.horizontalScrollView setContentOffset:CGPointMake(horizontalOffset, 0)];\n    }\n}\n\n- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    if ([cell isKindOfClass:[QLONAListCell class]])\n    {\n        QLONAListCell *listCell = (QLONAListCell *)cell;\n        NSInteger row = indexPath.row;\n        CGFloat horizontalOffset = listCell.horizontalScrollView.contentOffset.x;\n        self.contentOffsetDict[[@(row) stringValue]] = @(horizontalOffset);\n    }\n}\n</code></pre><p>其中 QLONAListCell 是 UITableViewCell 的子类，它有一个 UICollectionView 类型的属性 horizontalScrollView。<br>contentOffsetDict 是 UIViewController 的实例变量，它是一个 NSMutableDictionary。</p>\n<p>哦，还有一个注意点。当对 UITableView 进行下拉刷新的时候，新数据可能与老数据不一样（比如多了某个 Cell 或少了某个 Cell），那么这种情况下，contentOffsetDict 的记录就不再正确，所以每次在数据请求回来的时候，最好清空一下 contentOffsetDict。这样做的后果就是每次下拉刷新就会清空横滑列表的 contentOffset，不过看起来也似乎合情合理。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/\" target=\"_blank\" rel=\"noopener\">Putting a UICollectionView in a UITableViewCell</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>UIViewController 中有一个 UITableView，UITableViewCell 的 contentView 上添加了横滑列表，横滑列表是用 UICollectionView 实现的。<br>如下图所示</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset1.png\" alt=\"\"></p>\n<p>抽象出来就是这样</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset2.png\" alt=\"\"></p>\n<p>其中 UITableView 的 DataSource/Delegate 是 Controller，而 UICollectionView 的 DataSource/Delegate 是 UITableViewCell。<br>UITableView 的 DataSource 抽象如下：</p>\n<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath \n{\n    JceObject *cellObj = [_dataModel.aryItems objectAtIndex:indexPath.row];\n    UITableViewCell *cell = [QLThumbsMgr makeCellWithJCEPoster:cellObj tableView:tableView userInfo:self];\n    return cell;\n}\n</code></pre><p>好像看似没什么问题是吧，UITableView 的使用一向都是这样的嘛。可是当 UITableViewCell 碰上了 UICollectionView，问题就出来了。<br>左右滑动一个 UICollectionView 使其 contentOffset 不为初始值，再上下滑动 UITableView，你会发现，其他的横滑列表也被横滑了，上个动图直观感受一下</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset3.gif\" alt=\"\"></p>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>如果对于 UITableView 的 Cell 复用机制有一定了解的同学一定很容易看出问题，就是因为 Cell 之间的复用导致了 UICollectionView 的 contentOffset 也被复用了。</p>\n<p>那么之前我们是如何解决 UITableViewCell 的复用问题呢？就是每次 Cell 出现的时候，就根据数据源更新 Cell 的内容，这样就保证了每次看到的 Cell 是正确的。</p>\n<p>但是现在棘手的是数据源中并没有包含 UICollectionView 的 contentOffset。</p>\n<p>问题可以转化为如何在 UITableViewCell 出现的时候，更新其 UICollectionView 的 contentOffset。依赖 UITableViewCell 去记住是行不通的，因为它自己就是被复用的对象，那么就要外部去帮它记住，这个外部可以是 UITableView 的 Delegate——UIViewController，也可以 UITableViewCell 的数据源。</p>\n<p>如果是数据源，则需要对数据源做一个扩展 or 分类，由于数据源与前后台协议是相关的，改动数据源或许不是一个好的选择。所以这里我选择了让 UIViewController 去完成这个记忆的任务。</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>我们可以为 UIViewController 添加一个 NSMutableDictionary 类型的实例变量，该字典存储的是 UITableViewCell 的位置和其 UICollectionView 的横滑位置的映射关系。</p>\n<ul>\n<li><p>UITableViewCell 即将从视野里消失的时候，UIViewController 用 NSMutableDictionary 记录该 Cell 的 indexPath.row 和其 UICollectionView 的 contentOffset；（这里只讨论 UITableView 只有一个 section 的情况，多个 section 的处理原理是一样的）</p>\n</li>\n<li><p>UITableViewCell 即将出现在视野里的时候，UIViewController 根据该 Cell 的 indexPath.row，从 NSMutableDictionary 中读取相应的值去设置该 Cell 上的 UICollectionView 的 contentOffset；</p>\n</li>\n</ul>\n<p>UIViewController 是 UITableView 的 Delegate，UITableViewCell 的出现和消失事件可以在以下2个代理方法中捕捉到。<br><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</code><br>和<br><code>- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;</code></p>\n<p>那么，UIViewController 中的代码应该类似这样。</p>\n<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    if ([cell isKindOfClass:[QLONAListCell class]])\n    {\n        QLONAListCell *listCell = (QLONAListCell *)cell;\n        NSInteger row = indexPath.row;\n        CGFloat horizontalOffset;\n        horizontalOffset = [self.contentOffsetDict[[@(row) stringValue]] floatValue];\n        [listCell.horizontalScrollView setContentOffset:CGPointMake(horizontalOffset, 0)];\n    }\n}\n\n- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    if ([cell isKindOfClass:[QLONAListCell class]])\n    {\n        QLONAListCell *listCell = (QLONAListCell *)cell;\n        NSInteger row = indexPath.row;\n        CGFloat horizontalOffset = listCell.horizontalScrollView.contentOffset.x;\n        self.contentOffsetDict[[@(row) stringValue]] = @(horizontalOffset);\n    }\n}\n</code></pre><p>其中 QLONAListCell 是 UITableViewCell 的子类，它有一个 UICollectionView 类型的属性 horizontalScrollView。<br>contentOffsetDict 是 UIViewController 的实例变量，它是一个 NSMutableDictionary。</p>\n<p>哦，还有一个注意点。当对 UITableView 进行下拉刷新的时候，新数据可能与老数据不一样（比如多了某个 Cell 或少了某个 Cell），那么这种情况下，contentOffsetDict 的记录就不再正确，所以每次在数据请求回来的时候，最好清空一下 contentOffsetDict。这样做的后果就是每次下拉刷新就会清空横滑列表的 contentOffset，不过看起来也似乎合情合理。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/\" target=\"_blank\" rel=\"noopener\">Putting a UICollectionView in a UITableViewCell</a></p>\n"},{"title":"iOS 技能树","date":"2016-02-17T16:00:00.000Z","description":"iOSの修行 技能树","photos":["images/girl2.jpg"],"keywords":null,"_content":"\n# Objective-C\n\tRunLoop\n\tRuntime\n\t多线程\n\t\tNSThread\n\t\tNSOperation\n\t\tGCD\n\t\t\t线程同步\n\t\t\t线程间通信\n\tProperty\n\n# iOS\n\tUI\n\t\tUILabel\n\t网络通信\n\t\tASIHTTPRequest\n\t\tAFNETworking\n\t\tNSURLConnection\n\t存储\n\t\tCore Data\n\t推送\n\t\tRemoteNotification(APNS)\n\t\tUILocalNotification\n\t动画\n\t3D Touch\n\tSwift\n\n# 工具\n\tCocoaPods\n\n# 发布\n\t苹果证书\n\n# 函数式响应编程\n\tReactive Cocoa\n\n# 架构\n\tMVC\n\tMVVM\n\n# 版本控制\n\tGit\n\tSVN\n\n# 设计模式\n\t\n# 资源\n\t[WWDC](https://developer.apple.com/videos/wwdc2015/)\n\t[Objc中国](http://objccn.io/)\n\t开源框架\n\t\tMBProcessHUD\n\t\tSDWebImage\n\t开放平台\n\t\t分享（微信，QQ，微博）\n\t\t支付（微信，支付宝）\n","source":"_posts/iOS技能树.md","raw":"---\ntitle: iOS 技能树\ndate: 2016-2-18\ndescription: iOSの修行 技能树\ncategories:\n- Others\nphotos: images/girl2.jpg\nkeywords:\n---\n\n# Objective-C\n\tRunLoop\n\tRuntime\n\t多线程\n\t\tNSThread\n\t\tNSOperation\n\t\tGCD\n\t\t\t线程同步\n\t\t\t线程间通信\n\tProperty\n\n# iOS\n\tUI\n\t\tUILabel\n\t网络通信\n\t\tASIHTTPRequest\n\t\tAFNETworking\n\t\tNSURLConnection\n\t存储\n\t\tCore Data\n\t推送\n\t\tRemoteNotification(APNS)\n\t\tUILocalNotification\n\t动画\n\t3D Touch\n\tSwift\n\n# 工具\n\tCocoaPods\n\n# 发布\n\t苹果证书\n\n# 函数式响应编程\n\tReactive Cocoa\n\n# 架构\n\tMVC\n\tMVVM\n\n# 版本控制\n\tGit\n\tSVN\n\n# 设计模式\n\t\n# 资源\n\t[WWDC](https://developer.apple.com/videos/wwdc2015/)\n\t[Objc中国](http://objccn.io/)\n\t开源框架\n\t\tMBProcessHUD\n\t\tSDWebImage\n\t开放平台\n\t\t分享（微信，QQ，微博）\n\t\t支付（微信，支付宝）\n","slug":"iOS技能树","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","link":"","_id":"cjp2opl3d000eu3qw7djtpb9v","content":"<h1 id=\"Objective-C\"><a href=\"#Objective-C\" class=\"headerlink\" title=\"Objective-C\"></a>Objective-C</h1><pre><code>RunLoop\nRuntime\n多线程\n    NSThread\n    NSOperation\n    GCD\n        线程同步\n        线程间通信\nProperty\n</code></pre><h1 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h1><pre><code>UI\n    UILabel\n网络通信\n    ASIHTTPRequest\n    AFNETworking\n    NSURLConnection\n存储\n    Core Data\n推送\n    RemoteNotification(APNS)\n    UILocalNotification\n动画\n3D Touch\nSwift\n</code></pre><h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><pre><code>CocoaPods\n</code></pre><h1 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h1><pre><code>苹果证书\n</code></pre><h1 id=\"函数式响应编程\"><a href=\"#函数式响应编程\" class=\"headerlink\" title=\"函数式响应编程\"></a>函数式响应编程</h1><pre><code>Reactive Cocoa\n</code></pre><h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><pre><code>MVC\nMVVM\n</code></pre><h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><pre><code>Git\nSVN\n</code></pre><h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><pre><code>[WWDC](https://developer.apple.com/videos/wwdc2015/)\n[Objc中国](http://objccn.io/)\n开源框架\n    MBProcessHUD\n    SDWebImage\n开放平台\n    分享（微信，QQ，微博）\n    支付（微信，支付宝）\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objective-C\"><a href=\"#Objective-C\" class=\"headerlink\" title=\"Objective-C\"></a>Objective-C</h1><pre><code>RunLoop\nRuntime\n多线程\n    NSThread\n    NSOperation\n    GCD\n        线程同步\n        线程间通信\nProperty\n</code></pre><h1 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h1><pre><code>UI\n    UILabel\n网络通信\n    ASIHTTPRequest\n    AFNETworking\n    NSURLConnection\n存储\n    Core Data\n推送\n    RemoteNotification(APNS)\n    UILocalNotification\n动画\n3D Touch\nSwift\n</code></pre><h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><pre><code>CocoaPods\n</code></pre><h1 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h1><pre><code>苹果证书\n</code></pre><h1 id=\"函数式响应编程\"><a href=\"#函数式响应编程\" class=\"headerlink\" title=\"函数式响应编程\"></a>函数式响应编程</h1><pre><code>Reactive Cocoa\n</code></pre><h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><pre><code>MVC\nMVVM\n</code></pre><h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><pre><code>Git\nSVN\n</code></pre><h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><pre><code>[WWDC](https://developer.apple.com/videos/wwdc2015/)\n[Objc中国](http://objccn.io/)\n开源框架\n    MBProcessHUD\n    SDWebImage\n开放平台\n    分享（微信，QQ，微博）\n    支付（微信，支付宝）\n</code></pre>"},{"title":"iOS的单例模式与多线程安全","date":"2017-04-04T16:00:00.000Z","photos":[],"keywords":"iOS;单例模式;多线程安全;dispatch_once;","_content":"\n# 版本1\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        sharedInstance = [[self alloc] init];\n    }\n    return sharedInstance;\n}\n```\n\n版本1采用 static 变量方法，先判断实例是否已初始化，如果已初始化则直接返回，否则创建实例\n\n缺点是多线程下不安全。如果多个线程同时访问 sharedInstance，可能会有多个线程同时通过`(sharedInstance == nil)`的条件检查，于是，多个实例就创建出来\n\n# 版本2\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        @synchronized (self) \n        {\n            sharedInstance = [[self alloc] init];\n        }\n    }\n    return sharedInstance;\n}\n```\n\n为了线程互斥，那么版本2在版本1的基础上添加 @synchronized\n\n多线程的安全问题得到解决了吗？没有。依然可能有多个线程同时通过非空检查，现在它们变成按顺序地创建了多个实例\n\n# 版本3\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    @synchronized (self)\n    {\n        if (sharedInstance == nil)\n        {\n            sharedInstance = [[self alloc] init];\n        }\n    }\n    return sharedInstance;\n}\n```\n\n在版本2的基础上，只要把非空检查也放到 @synchronized 里面，那么就不会出现多个线程同时通过非空检查了，所以多线程的安全问题就得到解决了。\n\n但是现在每次访问 sharedInstance，无论单例是否已经初始化完毕，都要对 self 加锁，是非常浪费的\n\n# 版本4\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        @synchronized (self)\n        {\n            if (sharedInstance == nil)\n            {\n                sharedInstance = [[self alloc] init];\n            }\n        }\n    }\n    return sharedInstance;\n}\n```\n\n版本4是版本3的升级版本，称为“Double Check”。\n\n1. 如果单例已创建，则直接返回，不需要加锁；\n2. 如果单例没创建，则加锁\n3. 加锁后，只能有一个线程通过非空检查，创建单例\n\n很完美，但是写起来有点复杂\n\n# 终极版本\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n```\n\n使用 dispatch_once，秒杀以上方案，更快更安全\n\nTips：把上述代码保存到代码片段，直接丢到任何类里面都适用\n\n# 由单例模式引发的多线程安全的思考\n## static bool 的判断在多线程下不安全\n\n```objc\nstatic bool hasDone = NO;\nif (!hasDone)\n{\n    // do something\n    hasDone = YES;\n}\n// do something\n```\n\n以上写法不安全，有可能多个线程同时通过非空检查，导致 if 体内的代码执行多次\n\n如果一段代码是在 App 声明周期内只执行一次，则推荐使用 `dispatch_once`；其他的情况要具体分析\n\n## 懒加载在多线程下不安全\n\n```objc\n- (NSArray *)myArray\n{\n    if (_myArray)\n    {\n        _myArray = [[NSArray alloc] init];\n    }\n    return _myArray;\n}\n```\n\n这种判断在多线程下不安全的。所以多线程下尽量别使用懒加载，即使使用，也要加相应的保护，比如在 `_myArray` 不会被重新置为 nil 的前提下可以使用 `dispatch_once`","source":"_posts/iOS的单例模式与多线程安全.md","raw":"---\ntitle: iOS的单例模式与多线程安全\ndate: 2017-04-05\ncategories:\n- iOS\nphotos: \nkeywords: iOS;单例模式;多线程安全;dispatch_once;\n---\n\n# 版本1\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        sharedInstance = [[self alloc] init];\n    }\n    return sharedInstance;\n}\n```\n\n版本1采用 static 变量方法，先判断实例是否已初始化，如果已初始化则直接返回，否则创建实例\n\n缺点是多线程下不安全。如果多个线程同时访问 sharedInstance，可能会有多个线程同时通过`(sharedInstance == nil)`的条件检查，于是，多个实例就创建出来\n\n# 版本2\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        @synchronized (self) \n        {\n            sharedInstance = [[self alloc] init];\n        }\n    }\n    return sharedInstance;\n}\n```\n\n为了线程互斥，那么版本2在版本1的基础上添加 @synchronized\n\n多线程的安全问题得到解决了吗？没有。依然可能有多个线程同时通过非空检查，现在它们变成按顺序地创建了多个实例\n\n# 版本3\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    @synchronized (self)\n    {\n        if (sharedInstance == nil)\n        {\n            sharedInstance = [[self alloc] init];\n        }\n    }\n    return sharedInstance;\n}\n```\n\n在版本2的基础上，只要把非空检查也放到 @synchronized 里面，那么就不会出现多个线程同时通过非空检查了，所以多线程的安全问题就得到解决了。\n\n但是现在每次访问 sharedInstance，无论单例是否已经初始化完毕，都要对 self 加锁，是非常浪费的\n\n# 版本4\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        @synchronized (self)\n        {\n            if (sharedInstance == nil)\n            {\n                sharedInstance = [[self alloc] init];\n            }\n        }\n    }\n    return sharedInstance;\n}\n```\n\n版本4是版本3的升级版本，称为“Double Check”。\n\n1. 如果单例已创建，则直接返回，不需要加锁；\n2. 如果单例没创建，则加锁\n3. 加锁后，只能有一个线程通过非空检查，创建单例\n\n很完美，但是写起来有点复杂\n\n# 终极版本\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n```\n\n使用 dispatch_once，秒杀以上方案，更快更安全\n\nTips：把上述代码保存到代码片段，直接丢到任何类里面都适用\n\n# 由单例模式引发的多线程安全的思考\n## static bool 的判断在多线程下不安全\n\n```objc\nstatic bool hasDone = NO;\nif (!hasDone)\n{\n    // do something\n    hasDone = YES;\n}\n// do something\n```\n\n以上写法不安全，有可能多个线程同时通过非空检查，导致 if 体内的代码执行多次\n\n如果一段代码是在 App 声明周期内只执行一次，则推荐使用 `dispatch_once`；其他的情况要具体分析\n\n## 懒加载在多线程下不安全\n\n```objc\n- (NSArray *)myArray\n{\n    if (_myArray)\n    {\n        _myArray = [[NSArray alloc] init];\n    }\n    return _myArray;\n}\n```\n\n这种判断在多线程下不安全的。所以多线程下尽量别使用懒加载，即使使用，也要加相应的保护，比如在 `_myArray` 不会被重新置为 nil 的前提下可以使用 `dispatch_once`","slug":"iOS的单例模式与多线程安全","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","link":"","_id":"cjp2opl3e000fu3qwg2xhjklt","content":"<h1 id=\"版本1\"><a href=\"#版本1\" class=\"headerlink\" title=\"版本1\"></a>版本1</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>版本1采用 static 变量方法，先判断实例是否已初始化，如果已初始化则直接返回，否则创建实例</p>\n<p>缺点是多线程下不安全。如果多个线程同时访问 sharedInstance，可能会有多个线程同时通过<code>(sharedInstance == nil)</code>的条件检查，于是，多个实例就创建出来</p>\n<h1 id=\"版本2\"><a href=\"#版本2\" class=\"headerlink\" title=\"版本2\"></a>版本2</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了线程互斥，那么版本2在版本1的基础上添加 @synchronized</p>\n<p>多线程的安全问题得到解决了吗？没有。依然可能有多个线程同时通过非空检查，现在它们变成按顺序地创建了多个实例</p>\n<h1 id=\"版本3\"><a href=\"#版本3\" class=\"headerlink\" title=\"版本3\"></a>版本3</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在版本2的基础上，只要把非空检查也放到 @synchronized 里面，那么就不会出现多个线程同时通过非空检查了，所以多线程的安全问题就得到解决了。</p>\n<p>但是现在每次访问 sharedInstance，无论单例是否已经初始化完毕，都要对 self 加锁，是非常浪费的</p>\n<h1 id=\"版本4\"><a href=\"#版本4\" class=\"headerlink\" title=\"版本4\"></a>版本4</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>版本4是版本3的升级版本，称为“Double Check”。</p>\n<ol>\n<li>如果单例已创建，则直接返回，不需要加锁；</li>\n<li>如果单例没创建，则加锁</li>\n<li>加锁后，只能有一个线程通过非空检查，创建单例</li>\n</ol>\n<p>很完美，但是写起来有点复杂</p>\n<h1 id=\"终极版本\"><a href=\"#终极版本\" class=\"headerlink\" title=\"终极版本\"></a>终极版本</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_once，秒杀以上方案，更快更安全</p>\n<p>Tips：把上述代码保存到代码片段，直接丢到任何类里面都适用</p>\n<h1 id=\"由单例模式引发的多线程安全的思考\"><a href=\"#由单例模式引发的多线程安全的思考\" class=\"headerlink\" title=\"由单例模式引发的多线程安全的思考\"></a>由单例模式引发的多线程安全的思考</h1><h2 id=\"static-bool-的判断在多线程下不安全\"><a href=\"#static-bool-的判断在多线程下不安全\" class=\"headerlink\" title=\"static bool 的判断在多线程下不安全\"></a>static bool 的判断在多线程下不安全</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> hasDone = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!hasDone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    hasDone = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// do something</span></span><br></pre></td></tr></table></figure>\n<p>以上写法不安全，有可能多个线程同时通过非空检查，导致 if 体内的代码执行多次</p>\n<p>如果一段代码是在 App 声明周期内只执行一次，则推荐使用 <code>dispatch_once</code>；其他的情况要具体分析</p>\n<h2 id=\"懒加载在多线程下不安全\"><a href=\"#懒加载在多线程下不安全\" class=\"headerlink\" title=\"懒加载在多线程下不安全\"></a>懒加载在多线程下不安全</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)myArray</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_myArray)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _myArray = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _myArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种判断在多线程下不安全的。所以多线程下尽量别使用懒加载，即使使用，也要加相应的保护，比如在 <code>_myArray</code> 不会被重新置为 nil 的前提下可以使用 <code>dispatch_once</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"版本1\"><a href=\"#版本1\" class=\"headerlink\" title=\"版本1\"></a>版本1</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>版本1采用 static 变量方法，先判断实例是否已初始化，如果已初始化则直接返回，否则创建实例</p>\n<p>缺点是多线程下不安全。如果多个线程同时访问 sharedInstance，可能会有多个线程同时通过<code>(sharedInstance == nil)</code>的条件检查，于是，多个实例就创建出来</p>\n<h1 id=\"版本2\"><a href=\"#版本2\" class=\"headerlink\" title=\"版本2\"></a>版本2</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了线程互斥，那么版本2在版本1的基础上添加 @synchronized</p>\n<p>多线程的安全问题得到解决了吗？没有。依然可能有多个线程同时通过非空检查，现在它们变成按顺序地创建了多个实例</p>\n<h1 id=\"版本3\"><a href=\"#版本3\" class=\"headerlink\" title=\"版本3\"></a>版本3</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在版本2的基础上，只要把非空检查也放到 @synchronized 里面，那么就不会出现多个线程同时通过非空检查了，所以多线程的安全问题就得到解决了。</p>\n<p>但是现在每次访问 sharedInstance，无论单例是否已经初始化完毕，都要对 self 加锁，是非常浪费的</p>\n<h1 id=\"版本4\"><a href=\"#版本4\" class=\"headerlink\" title=\"版本4\"></a>版本4</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>版本4是版本3的升级版本，称为“Double Check”。</p>\n<ol>\n<li>如果单例已创建，则直接返回，不需要加锁；</li>\n<li>如果单例没创建，则加锁</li>\n<li>加锁后，只能有一个线程通过非空检查，创建单例</li>\n</ol>\n<p>很完美，但是写起来有点复杂</p>\n<h1 id=\"终极版本\"><a href=\"#终极版本\" class=\"headerlink\" title=\"终极版本\"></a>终极版本</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_once，秒杀以上方案，更快更安全</p>\n<p>Tips：把上述代码保存到代码片段，直接丢到任何类里面都适用</p>\n<h1 id=\"由单例模式引发的多线程安全的思考\"><a href=\"#由单例模式引发的多线程安全的思考\" class=\"headerlink\" title=\"由单例模式引发的多线程安全的思考\"></a>由单例模式引发的多线程安全的思考</h1><h2 id=\"static-bool-的判断在多线程下不安全\"><a href=\"#static-bool-的判断在多线程下不安全\" class=\"headerlink\" title=\"static bool 的判断在多线程下不安全\"></a>static bool 的判断在多线程下不安全</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> hasDone = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!hasDone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    hasDone = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// do something</span></span><br></pre></td></tr></table></figure>\n<p>以上写法不安全，有可能多个线程同时通过非空检查，导致 if 体内的代码执行多次</p>\n<p>如果一段代码是在 App 声明周期内只执行一次，则推荐使用 <code>dispatch_once</code>；其他的情况要具体分析</p>\n<h2 id=\"懒加载在多线程下不安全\"><a href=\"#懒加载在多线程下不安全\" class=\"headerlink\" title=\"懒加载在多线程下不安全\"></a>懒加载在多线程下不安全</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)myArray</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_myArray)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _myArray = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _myArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种判断在多线程下不安全的。所以多线程下尽量别使用懒加载，即使使用，也要加相应的保护，比如在 <code>_myArray</code> 不会被重新置为 nil 的前提下可以使用 <code>dispatch_once</code></p>\n"},{"title":"《活着》","date":"2018-06-08T16:00:00.000Z","_content":"\n昨晚看到深夜，早上起床后继续看完，不到2个小时。\n\n那是悲惨的时代，打仗，土改，大跃进，文革。但是每个时代又都有每个时代的不幸，每个人亦有每个人的痛苦。\n\n第一遍翻开这本书，如同与作者一般，在一个充满阳光的下午，闲来无事，坐在乡间茂盛的老树下，听一个老人，慢慢将他的人生娓娓道来，这种心情是放松的，好奇的。等读完这本书，再从头翻起，这次的感觉却截然不同，仿佛自己如同福贵一样，经历了命运的折磨之后，一时兴起，与一个陌生人分享个中滋味，这种心情是说不出的沉重，道不来的苦涩。\n\n1. 福贵的一生的衰落，从赌博输光家产导致家道中落开始，此时只是身外之物的失去，我的心仍波澜不惊。\n2. 爹间接被气死，从粪坑掉下来，虽然有点凄凉，但至少是正常剧情的发展。\n3. 家珍被接走，只是生离并非死别。\n4. 娘开始生病，又苦于没钱医治，让我心底有点触动，毕竟这种情况太贴近现实生活。\n5. 请郎中过程被抓去充军，我开始担忧他母亲的病是否被拖延，家珍久久没见到丈夫回家怎么办？没想到书中略去不写，从离家到回家，一别两年，视角一直停留在福贵身上，让我有点难受…我渐渐发现，我不是在看小说，其实真实的人生不应该就是这样吗？\n6. 回家，凤霞聋哑了，母亲走了，人生到这里，应该够惨了吧…幸亏还有家珍，还有健康成长的有庆。接下来珍惜家人，好好过日子就行了。\n7. 家里拮据潦倒，为了有庆能上学，将凤霞送给给五十多岁的老男人，这种情况在旧中国不是比比皆是吗？心疼凤霞。\n8. 凤霞最终回来了，紧接着遇到人民公社化运动。打仗可以，治国无能。最终家里穷到喝个粥都得偷偷摸摸，这个不是小说，是历史赤裸裸的写照。\n9. 家珍生病，感觉这个家庭好不容易完整，又时刻在风雨中摇摇欲坠，好不心酸。\n10. 万万没想到的是家珍活了过来，心底有点慰藉的时候有庆却在献血的时候被无良医生给弄死了。读到这里我反复确认了，真的是死了，我以为还会有更多的故事，怎么这么突然呢？可是现实不正应该是这样的吗？生活不是小说连续剧，没有剧情反转；也不是游戏，无法读取存档重新来过。此时我已经无法代入福贵的角色，我不敢想象。读到这里是最痛苦的。像是刺刀开始刺进心脏，后面的不幸不过是将刺刀再捅得很深，更准\n11. 生活总是打你一巴掌，然后给你一颗糖，再狠狠打你一巴掌…凤霞嫁给能够善待他们一家人的二喜，算是一种正能量。生了苦根，自己却离开了。所谓家，摇摇欲坠，七零八落。\n12. 家珍终归也走了，剩下福贵，二喜，苦根。好惨啊，如果家珍没走就好了，可是家珍走之前，我也觉得好惨…等到失去了才知其可贵。还有比他的人生更可怜的吗？\n13. 当二喜也出意外的时候，我发现还真有…同时又有上面的想法，没出意外该多好啊…\n14. 最后苦根也逃脱不了这个命运，我的心似乎已经波澜不惊了。剩下福贵，不知道为了什么意义而活着。\n\n可是，活着本身，就是一种意义。\n\n听一个比自己不幸的人讲述他的不幸，然后更加懂得活着的意义。\n\n月光照在路上，像是洒满了盐。\n","source":"_posts/《活着》.md","raw":"---\ntitle: 《活着》\ndate: 2018-06-09\ncategories:\n- 精神角落 \n---\n\n昨晚看到深夜，早上起床后继续看完，不到2个小时。\n\n那是悲惨的时代，打仗，土改，大跃进，文革。但是每个时代又都有每个时代的不幸，每个人亦有每个人的痛苦。\n\n第一遍翻开这本书，如同与作者一般，在一个充满阳光的下午，闲来无事，坐在乡间茂盛的老树下，听一个老人，慢慢将他的人生娓娓道来，这种心情是放松的，好奇的。等读完这本书，再从头翻起，这次的感觉却截然不同，仿佛自己如同福贵一样，经历了命运的折磨之后，一时兴起，与一个陌生人分享个中滋味，这种心情是说不出的沉重，道不来的苦涩。\n\n1. 福贵的一生的衰落，从赌博输光家产导致家道中落开始，此时只是身外之物的失去，我的心仍波澜不惊。\n2. 爹间接被气死，从粪坑掉下来，虽然有点凄凉，但至少是正常剧情的发展。\n3. 家珍被接走，只是生离并非死别。\n4. 娘开始生病，又苦于没钱医治，让我心底有点触动，毕竟这种情况太贴近现实生活。\n5. 请郎中过程被抓去充军，我开始担忧他母亲的病是否被拖延，家珍久久没见到丈夫回家怎么办？没想到书中略去不写，从离家到回家，一别两年，视角一直停留在福贵身上，让我有点难受…我渐渐发现，我不是在看小说，其实真实的人生不应该就是这样吗？\n6. 回家，凤霞聋哑了，母亲走了，人生到这里，应该够惨了吧…幸亏还有家珍，还有健康成长的有庆。接下来珍惜家人，好好过日子就行了。\n7. 家里拮据潦倒，为了有庆能上学，将凤霞送给给五十多岁的老男人，这种情况在旧中国不是比比皆是吗？心疼凤霞。\n8. 凤霞最终回来了，紧接着遇到人民公社化运动。打仗可以，治国无能。最终家里穷到喝个粥都得偷偷摸摸，这个不是小说，是历史赤裸裸的写照。\n9. 家珍生病，感觉这个家庭好不容易完整，又时刻在风雨中摇摇欲坠，好不心酸。\n10. 万万没想到的是家珍活了过来，心底有点慰藉的时候有庆却在献血的时候被无良医生给弄死了。读到这里我反复确认了，真的是死了，我以为还会有更多的故事，怎么这么突然呢？可是现实不正应该是这样的吗？生活不是小说连续剧，没有剧情反转；也不是游戏，无法读取存档重新来过。此时我已经无法代入福贵的角色，我不敢想象。读到这里是最痛苦的。像是刺刀开始刺进心脏，后面的不幸不过是将刺刀再捅得很深，更准\n11. 生活总是打你一巴掌，然后给你一颗糖，再狠狠打你一巴掌…凤霞嫁给能够善待他们一家人的二喜，算是一种正能量。生了苦根，自己却离开了。所谓家，摇摇欲坠，七零八落。\n12. 家珍终归也走了，剩下福贵，二喜，苦根。好惨啊，如果家珍没走就好了，可是家珍走之前，我也觉得好惨…等到失去了才知其可贵。还有比他的人生更可怜的吗？\n13. 当二喜也出意外的时候，我发现还真有…同时又有上面的想法，没出意外该多好啊…\n14. 最后苦根也逃脱不了这个命运，我的心似乎已经波澜不惊了。剩下福贵，不知道为了什么意义而活着。\n\n可是，活着本身，就是一种意义。\n\n听一个比自己不幸的人讲述他的不幸，然后更加懂得活着的意义。\n\n月光照在路上，像是洒满了盐。\n","slug":"《活着》","published":1,"updated":"2018-11-02T02:22:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp2opl3f000iu3qwan6ahp26","content":"<p>昨晚看到深夜，早上起床后继续看完，不到2个小时。</p>\n<p>那是悲惨的时代，打仗，土改，大跃进，文革。但是每个时代又都有每个时代的不幸，每个人亦有每个人的痛苦。</p>\n<p>第一遍翻开这本书，如同与作者一般，在一个充满阳光的下午，闲来无事，坐在乡间茂盛的老树下，听一个老人，慢慢将他的人生娓娓道来，这种心情是放松的，好奇的。等读完这本书，再从头翻起，这次的感觉却截然不同，仿佛自己如同福贵一样，经历了命运的折磨之后，一时兴起，与一个陌生人分享个中滋味，这种心情是说不出的沉重，道不来的苦涩。</p>\n<ol>\n<li>福贵的一生的衰落，从赌博输光家产导致家道中落开始，此时只是身外之物的失去，我的心仍波澜不惊。</li>\n<li>爹间接被气死，从粪坑掉下来，虽然有点凄凉，但至少是正常剧情的发展。</li>\n<li>家珍被接走，只是生离并非死别。</li>\n<li>娘开始生病，又苦于没钱医治，让我心底有点触动，毕竟这种情况太贴近现实生活。</li>\n<li>请郎中过程被抓去充军，我开始担忧他母亲的病是否被拖延，家珍久久没见到丈夫回家怎么办？没想到书中略去不写，从离家到回家，一别两年，视角一直停留在福贵身上，让我有点难受…我渐渐发现，我不是在看小说，其实真实的人生不应该就是这样吗？</li>\n<li>回家，凤霞聋哑了，母亲走了，人生到这里，应该够惨了吧…幸亏还有家珍，还有健康成长的有庆。接下来珍惜家人，好好过日子就行了。</li>\n<li>家里拮据潦倒，为了有庆能上学，将凤霞送给给五十多岁的老男人，这种情况在旧中国不是比比皆是吗？心疼凤霞。</li>\n<li>凤霞最终回来了，紧接着遇到人民公社化运动。打仗可以，治国无能。最终家里穷到喝个粥都得偷偷摸摸，这个不是小说，是历史赤裸裸的写照。</li>\n<li>家珍生病，感觉这个家庭好不容易完整，又时刻在风雨中摇摇欲坠，好不心酸。</li>\n<li>万万没想到的是家珍活了过来，心底有点慰藉的时候有庆却在献血的时候被无良医生给弄死了。读到这里我反复确认了，真的是死了，我以为还会有更多的故事，怎么这么突然呢？可是现实不正应该是这样的吗？生活不是小说连续剧，没有剧情反转；也不是游戏，无法读取存档重新来过。此时我已经无法代入福贵的角色，我不敢想象。读到这里是最痛苦的。像是刺刀开始刺进心脏，后面的不幸不过是将刺刀再捅得很深，更准</li>\n<li>生活总是打你一巴掌，然后给你一颗糖，再狠狠打你一巴掌…凤霞嫁给能够善待他们一家人的二喜，算是一种正能量。生了苦根，自己却离开了。所谓家，摇摇欲坠，七零八落。</li>\n<li>家珍终归也走了，剩下福贵，二喜，苦根。好惨啊，如果家珍没走就好了，可是家珍走之前，我也觉得好惨…等到失去了才知其可贵。还有比他的人生更可怜的吗？</li>\n<li>当二喜也出意外的时候，我发现还真有…同时又有上面的想法，没出意外该多好啊…</li>\n<li>最后苦根也逃脱不了这个命运，我的心似乎已经波澜不惊了。剩下福贵，不知道为了什么意义而活着。</li>\n</ol>\n<p>可是，活着本身，就是一种意义。</p>\n<p>听一个比自己不幸的人讲述他的不幸，然后更加懂得活着的意义。</p>\n<p>月光照在路上，像是洒满了盐。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨晚看到深夜，早上起床后继续看完，不到2个小时。</p>\n<p>那是悲惨的时代，打仗，土改，大跃进，文革。但是每个时代又都有每个时代的不幸，每个人亦有每个人的痛苦。</p>\n<p>第一遍翻开这本书，如同与作者一般，在一个充满阳光的下午，闲来无事，坐在乡间茂盛的老树下，听一个老人，慢慢将他的人生娓娓道来，这种心情是放松的，好奇的。等读完这本书，再从头翻起，这次的感觉却截然不同，仿佛自己如同福贵一样，经历了命运的折磨之后，一时兴起，与一个陌生人分享个中滋味，这种心情是说不出的沉重，道不来的苦涩。</p>\n<ol>\n<li>福贵的一生的衰落，从赌博输光家产导致家道中落开始，此时只是身外之物的失去，我的心仍波澜不惊。</li>\n<li>爹间接被气死，从粪坑掉下来，虽然有点凄凉，但至少是正常剧情的发展。</li>\n<li>家珍被接走，只是生离并非死别。</li>\n<li>娘开始生病，又苦于没钱医治，让我心底有点触动，毕竟这种情况太贴近现实生活。</li>\n<li>请郎中过程被抓去充军，我开始担忧他母亲的病是否被拖延，家珍久久没见到丈夫回家怎么办？没想到书中略去不写，从离家到回家，一别两年，视角一直停留在福贵身上，让我有点难受…我渐渐发现，我不是在看小说，其实真实的人生不应该就是这样吗？</li>\n<li>回家，凤霞聋哑了，母亲走了，人生到这里，应该够惨了吧…幸亏还有家珍，还有健康成长的有庆。接下来珍惜家人，好好过日子就行了。</li>\n<li>家里拮据潦倒，为了有庆能上学，将凤霞送给给五十多岁的老男人，这种情况在旧中国不是比比皆是吗？心疼凤霞。</li>\n<li>凤霞最终回来了，紧接着遇到人民公社化运动。打仗可以，治国无能。最终家里穷到喝个粥都得偷偷摸摸，这个不是小说，是历史赤裸裸的写照。</li>\n<li>家珍生病，感觉这个家庭好不容易完整，又时刻在风雨中摇摇欲坠，好不心酸。</li>\n<li>万万没想到的是家珍活了过来，心底有点慰藉的时候有庆却在献血的时候被无良医生给弄死了。读到这里我反复确认了，真的是死了，我以为还会有更多的故事，怎么这么突然呢？可是现实不正应该是这样的吗？生活不是小说连续剧，没有剧情反转；也不是游戏，无法读取存档重新来过。此时我已经无法代入福贵的角色，我不敢想象。读到这里是最痛苦的。像是刺刀开始刺进心脏，后面的不幸不过是将刺刀再捅得很深，更准</li>\n<li>生活总是打你一巴掌，然后给你一颗糖，再狠狠打你一巴掌…凤霞嫁给能够善待他们一家人的二喜，算是一种正能量。生了苦根，自己却离开了。所谓家，摇摇欲坠，七零八落。</li>\n<li>家珍终归也走了，剩下福贵，二喜，苦根。好惨啊，如果家珍没走就好了，可是家珍走之前，我也觉得好惨…等到失去了才知其可贵。还有比他的人生更可怜的吗？</li>\n<li>当二喜也出意外的时候，我发现还真有…同时又有上面的想法，没出意外该多好啊…</li>\n<li>最后苦根也逃脱不了这个命运，我的心似乎已经波澜不惊了。剩下福贵，不知道为了什么意义而活着。</li>\n</ol>\n<p>可是，活着本身，就是一种意义。</p>\n<p>听一个比自己不幸的人讲述他的不幸，然后更加懂得活着的意义。</p>\n<p>月光照在路上，像是洒满了盐。</p>\n"},{"title":"关于Objective-C中的BOOL你所要知道的","date":"2016-05-31T16:00:00.000Z","keywords":"BOOL","_content":"\n# 问题\n曾经同事遇到一个关于 BOOL 的坑，这里分享下\n\n```objectivec\n- (BOOL)isPreloadingViewShowing\n{\n    return self.mainCtl.preLoadingView.superview;\n}\n```\n当 preLoadingView 明明有 superview 的时候，该函数居然有可能返回 NO\n\n通过进一步的测试，发现在64位机器上没有这个问题，而在32位机器上有可能出现\n\nWhy?!先写个 Demo 测试下\n\n---\n\n# Demo\n```objectivec\nstatic BOOL dif(int a, int b)\n{\n    return a-b;\n}\n\nif (dif(11, 10))\n{\n    NSLog(@\"11 != 10\");\n}\n\nif (dif(10, 11))\n{\n    NSLog(@\"10 != 11\");\n}\n\nif (dif(512, 256))\n{\n    NSLog(@\"512 != 256\");\n}\n```\n\n# Demo 运行结果\n+ 64位机器上\n\n```objectivec\n11 != 10\n10 != 11\n512 != 256\n```\n+ 32位机器上\n\n```objectivec\n11 != 10\n10 != 11\n```\n\n唯一的问题是为什么32位机器上最后一个的结果不对？！\n\n# Objective-C 中的 BOOL 到底是什么\n第一个要搞清楚的问题是，Obj-C 中的 BOOL 到底是什么？打开 objc.h，查看 BOOL 的定义\n\n```objectivec\n// objc.h\n\n#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH\ntypedef bool BOOL;\n#else\ntypedef signed char BOOL; \n#endif\n```\n意思是，在64位机器上，BOOL 是 bool，bool 的取值只有 true or false；在32位机器上，BOOL 是 signed char，长度8 bits\n\n所以，没有多余的机器可以测试的时候，我们可以把`static BOOL dif(int a, int b)`改为`static bool dif(int a, int b)`或`static signed char dif(int a, int b)`来模拟64位机器或32位机器的情况\n\n\n# Demo 结果分析\nDemo 中，a-b的结果是 int 类型，\n> int 作为返回值的时候会被强转为 BOOL，32位机器上 int 强转为 BOOL 的时候，其实是转为 signed char，只取了最低的8位，而64位机器上，BOOL 就是 bool，什么问题都没有，0即 false，非0即 true，可以像 C/C++ 语言那样放心使用\n\n+ 64位机器上\n\n```objectivec\n11-10=1 -> 0x0000000000000001 -> true\n10-11=-1 -> 0xffffffffffffffff -> true\n512-256=256 -> 0x0000000000000100 -> true\n```\n+ 32位机器上\n\n```objectivec\n11-10=1 -> 0x00000001 -> 00000001 -> true\n10-11=-1 -> 0xffffffff -> 11111111 -> true\n512-256=256 -> 0x00000100 -> 00000000 -> false\n```\n\n关于32位机器与64位机器数据类型长度类型，可以参见[32位机器与64位机器数据类型长度][1]\n\n---\n\n# 解决方法\n理清了 Demo，最上面的问题就迎刃而解了，superview 是一个指针（指针在 32/64 位机器上的位数是不同的），32位机器上，如果指针地址刚好最后8位都是0，那么即使指针不是空的，也会导致返回结果为空\n\n正确的做法应该为\n\n```objectivec\n- (BOOL)isPreloadingViewShowing\n{\n    if (self.mainCtl.preLoadingView.superview) \n        return YES;\n    else\n        return NO;\n}\n```\n\n# 结论\n> 取 int 或指针等类型作为 BOOL 的返回值时要注意，强转的时候可能会只取最低8位作为结果，尽量避免这种情况\n\n# 参考\n+ [重新认识一下OC 中的 BOOL 值](http://www.jianshu.com/p/2b97f18918b3?utm_campaign=hugo&utm_medium=reader_share&utm_content=note)\n+ [32位机器与64位机器数据类型长度][1]\n[1]: https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html","source":"_posts/关于Objective-C中的BOOL你所要知道的.md","raw":"---\ntitle: 关于Objective-C中的BOOL你所要知道的\ndate: 2016-06-01\ncategories:\n- iOS\nkeywords: BOOL\n---\n\n# 问题\n曾经同事遇到一个关于 BOOL 的坑，这里分享下\n\n```objectivec\n- (BOOL)isPreloadingViewShowing\n{\n    return self.mainCtl.preLoadingView.superview;\n}\n```\n当 preLoadingView 明明有 superview 的时候，该函数居然有可能返回 NO\n\n通过进一步的测试，发现在64位机器上没有这个问题，而在32位机器上有可能出现\n\nWhy?!先写个 Demo 测试下\n\n---\n\n# Demo\n```objectivec\nstatic BOOL dif(int a, int b)\n{\n    return a-b;\n}\n\nif (dif(11, 10))\n{\n    NSLog(@\"11 != 10\");\n}\n\nif (dif(10, 11))\n{\n    NSLog(@\"10 != 11\");\n}\n\nif (dif(512, 256))\n{\n    NSLog(@\"512 != 256\");\n}\n```\n\n# Demo 运行结果\n+ 64位机器上\n\n```objectivec\n11 != 10\n10 != 11\n512 != 256\n```\n+ 32位机器上\n\n```objectivec\n11 != 10\n10 != 11\n```\n\n唯一的问题是为什么32位机器上最后一个的结果不对？！\n\n# Objective-C 中的 BOOL 到底是什么\n第一个要搞清楚的问题是，Obj-C 中的 BOOL 到底是什么？打开 objc.h，查看 BOOL 的定义\n\n```objectivec\n// objc.h\n\n#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH\ntypedef bool BOOL;\n#else\ntypedef signed char BOOL; \n#endif\n```\n意思是，在64位机器上，BOOL 是 bool，bool 的取值只有 true or false；在32位机器上，BOOL 是 signed char，长度8 bits\n\n所以，没有多余的机器可以测试的时候，我们可以把`static BOOL dif(int a, int b)`改为`static bool dif(int a, int b)`或`static signed char dif(int a, int b)`来模拟64位机器或32位机器的情况\n\n\n# Demo 结果分析\nDemo 中，a-b的结果是 int 类型，\n> int 作为返回值的时候会被强转为 BOOL，32位机器上 int 强转为 BOOL 的时候，其实是转为 signed char，只取了最低的8位，而64位机器上，BOOL 就是 bool，什么问题都没有，0即 false，非0即 true，可以像 C/C++ 语言那样放心使用\n\n+ 64位机器上\n\n```objectivec\n11-10=1 -> 0x0000000000000001 -> true\n10-11=-1 -> 0xffffffffffffffff -> true\n512-256=256 -> 0x0000000000000100 -> true\n```\n+ 32位机器上\n\n```objectivec\n11-10=1 -> 0x00000001 -> 00000001 -> true\n10-11=-1 -> 0xffffffff -> 11111111 -> true\n512-256=256 -> 0x00000100 -> 00000000 -> false\n```\n\n关于32位机器与64位机器数据类型长度类型，可以参见[32位机器与64位机器数据类型长度][1]\n\n---\n\n# 解决方法\n理清了 Demo，最上面的问题就迎刃而解了，superview 是一个指针（指针在 32/64 位机器上的位数是不同的），32位机器上，如果指针地址刚好最后8位都是0，那么即使指针不是空的，也会导致返回结果为空\n\n正确的做法应该为\n\n```objectivec\n- (BOOL)isPreloadingViewShowing\n{\n    if (self.mainCtl.preLoadingView.superview) \n        return YES;\n    else\n        return NO;\n}\n```\n\n# 结论\n> 取 int 或指针等类型作为 BOOL 的返回值时要注意，强转的时候可能会只取最低8位作为结果，尽量避免这种情况\n\n# 参考\n+ [重新认识一下OC 中的 BOOL 值](http://www.jianshu.com/p/2b97f18918b3?utm_campaign=hugo&utm_medium=reader_share&utm_content=note)\n+ [32位机器与64位机器数据类型长度][1]\n[1]: https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html","slug":"关于Objective-C中的BOOL你所要知道的","published":1,"updated":"2018-11-02T02:22:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp2opl3g000ku3qwaq9hva23","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>曾经同事遇到一个关于 BOOL 的坑，这里分享下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPreloadingViewShowing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.mainCtl.preLoadingView.superview;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 preLoadingView 明明有 superview 的时候，该函数居然有可能返回 NO</p>\n<p>通过进一步的测试，发现在64位机器上没有这个问题，而在32位机器上有可能出现</p>\n<p>Why?!先写个 Demo 测试下</p>\n<hr>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">BOOL</span> dif(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a-b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">11</span>, <span class=\"number\">10</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"11 != 10\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">10</span>, <span class=\"number\">11</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"10 != 11\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">512</span>, <span class=\"number\">256</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"512 != 256\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Demo-运行结果\"><a href=\"#Demo-运行结果\" class=\"headerlink\" title=\"Demo 运行结果\"></a>Demo 运行结果</h1><ul>\n<li>64位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> != <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span> != <span class=\"number\">11</span></span><br><span class=\"line\"><span class=\"number\">512</span> != <span class=\"number\">256</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>32位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> != <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span> != <span class=\"number\">11</span></span><br></pre></td></tr></table></figure>\n<p>唯一的问题是为什么32位机器上最后一个的结果不对？！</p>\n<h1 id=\"Objective-C-中的-BOOL-到底是什么\"><a href=\"#Objective-C-中的-BOOL-到底是什么\" class=\"headerlink\" title=\"Objective-C 中的 BOOL 到底是什么\"></a>Objective-C 中的 BOOL 到底是什么</h1><p>第一个要搞清楚的问题是，Obj-C 中的 BOOL 到底是什么？打开 objc.h，查看 BOOL 的定义</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#if (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> <span class=\"built_in\">BOOL</span>;</span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> <span class=\"built_in\">BOOL</span>; </span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>意思是，在64位机器上，BOOL 是 bool，bool 的取值只有 true or false；在32位机器上，BOOL 是 signed char，长度8 bits</p>\n<p>所以，没有多余的机器可以测试的时候，我们可以把<code>static BOOL dif(int a, int b)</code>改为<code>static bool dif(int a, int b)</code>或<code>static signed char dif(int a, int b)</code>来模拟64位机器或32位机器的情况</p>\n<h1 id=\"Demo-结果分析\"><a href=\"#Demo-结果分析\" class=\"headerlink\" title=\"Demo 结果分析\"></a>Demo 结果分析</h1><p>Demo 中，a-b的结果是 int 类型，</p>\n<blockquote>\n<p>int 作为返回值的时候会被强转为 BOOL，32位机器上 int 强转为 BOOL 的时候，其实是转为 signed char，只取了最低的8位，而64位机器上，BOOL 就是 bool，什么问题都没有，0即 false，非0即 true，可以像 C/C++ 语言那样放心使用</p>\n</blockquote>\n<ul>\n<li>64位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span><span class=\"number\">-10</span>=<span class=\"number\">1</span> -&gt; <span class=\"number\">0x0000000000000001</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">10</span><span class=\"number\">-11</span>=<span class=\"number\">-1</span> -&gt; <span class=\"number\">0xffffffffffffffff</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">512</span><span class=\"number\">-256</span>=<span class=\"number\">256</span> -&gt; <span class=\"number\">0x0000000000000100</span> -&gt; <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>32位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span><span class=\"number\">-10</span>=<span class=\"number\">1</span> -&gt; <span class=\"number\">0x00000001</span> -&gt; <span class=\"number\">00000001</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">10</span><span class=\"number\">-11</span>=<span class=\"number\">-1</span> -&gt; <span class=\"number\">0xffffffff</span> -&gt; <span class=\"number\">11111111</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">512</span><span class=\"number\">-256</span>=<span class=\"number\">256</span> -&gt; <span class=\"number\">0x00000100</span> -&gt; <span class=\"number\">00000000</span> -&gt; <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>关于32位机器与64位机器数据类型长度类型，可以参见<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html\" target=\"_blank\" rel=\"noopener\">32位机器与64位机器数据类型长度</a></p>\n<hr>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>理清了 Demo，最上面的问题就迎刃而解了，superview 是一个指针（指针在 32/64 位机器上的位数是不同的），32位机器上，如果指针地址刚好最后8位都是0，那么即使指针不是空的，也会导致返回结果为空</p>\n<p>正确的做法应该为</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPreloadingViewShowing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.mainCtl.preLoadingView.superview) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><blockquote>\n<p>取 int 或指针等类型作为 BOOL 的返回值时要注意，强转的时候可能会只取最低8位作为结果，尽量避免这种情况</p>\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://www.jianshu.com/p/2b97f18918b3?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note\" target=\"_blank\" rel=\"noopener\">重新认识一下OC 中的 BOOL 值</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html\" target=\"_blank\" rel=\"noopener\">32位机器与64位机器数据类型长度</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>曾经同事遇到一个关于 BOOL 的坑，这里分享下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPreloadingViewShowing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.mainCtl.preLoadingView.superview;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 preLoadingView 明明有 superview 的时候，该函数居然有可能返回 NO</p>\n<p>通过进一步的测试，发现在64位机器上没有这个问题，而在32位机器上有可能出现</p>\n<p>Why?!先写个 Demo 测试下</p>\n<hr>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">BOOL</span> dif(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a-b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">11</span>, <span class=\"number\">10</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"11 != 10\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">10</span>, <span class=\"number\">11</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"10 != 11\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">512</span>, <span class=\"number\">256</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"512 != 256\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Demo-运行结果\"><a href=\"#Demo-运行结果\" class=\"headerlink\" title=\"Demo 运行结果\"></a>Demo 运行结果</h1><ul>\n<li>64位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> != <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span> != <span class=\"number\">11</span></span><br><span class=\"line\"><span class=\"number\">512</span> != <span class=\"number\">256</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>32位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> != <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span> != <span class=\"number\">11</span></span><br></pre></td></tr></table></figure>\n<p>唯一的问题是为什么32位机器上最后一个的结果不对？！</p>\n<h1 id=\"Objective-C-中的-BOOL-到底是什么\"><a href=\"#Objective-C-中的-BOOL-到底是什么\" class=\"headerlink\" title=\"Objective-C 中的 BOOL 到底是什么\"></a>Objective-C 中的 BOOL 到底是什么</h1><p>第一个要搞清楚的问题是，Obj-C 中的 BOOL 到底是什么？打开 objc.h，查看 BOOL 的定义</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#if (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> <span class=\"built_in\">BOOL</span>;</span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> <span class=\"built_in\">BOOL</span>; </span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>意思是，在64位机器上，BOOL 是 bool，bool 的取值只有 true or false；在32位机器上，BOOL 是 signed char，长度8 bits</p>\n<p>所以，没有多余的机器可以测试的时候，我们可以把<code>static BOOL dif(int a, int b)</code>改为<code>static bool dif(int a, int b)</code>或<code>static signed char dif(int a, int b)</code>来模拟64位机器或32位机器的情况</p>\n<h1 id=\"Demo-结果分析\"><a href=\"#Demo-结果分析\" class=\"headerlink\" title=\"Demo 结果分析\"></a>Demo 结果分析</h1><p>Demo 中，a-b的结果是 int 类型，</p>\n<blockquote>\n<p>int 作为返回值的时候会被强转为 BOOL，32位机器上 int 强转为 BOOL 的时候，其实是转为 signed char，只取了最低的8位，而64位机器上，BOOL 就是 bool，什么问题都没有，0即 false，非0即 true，可以像 C/C++ 语言那样放心使用</p>\n</blockquote>\n<ul>\n<li>64位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span><span class=\"number\">-10</span>=<span class=\"number\">1</span> -&gt; <span class=\"number\">0x0000000000000001</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">10</span><span class=\"number\">-11</span>=<span class=\"number\">-1</span> -&gt; <span class=\"number\">0xffffffffffffffff</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">512</span><span class=\"number\">-256</span>=<span class=\"number\">256</span> -&gt; <span class=\"number\">0x0000000000000100</span> -&gt; <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>32位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span><span class=\"number\">-10</span>=<span class=\"number\">1</span> -&gt; <span class=\"number\">0x00000001</span> -&gt; <span class=\"number\">00000001</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">10</span><span class=\"number\">-11</span>=<span class=\"number\">-1</span> -&gt; <span class=\"number\">0xffffffff</span> -&gt; <span class=\"number\">11111111</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">512</span><span class=\"number\">-256</span>=<span class=\"number\">256</span> -&gt; <span class=\"number\">0x00000100</span> -&gt; <span class=\"number\">00000000</span> -&gt; <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>关于32位机器与64位机器数据类型长度类型，可以参见<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html\" target=\"_blank\" rel=\"noopener\">32位机器与64位机器数据类型长度</a></p>\n<hr>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>理清了 Demo，最上面的问题就迎刃而解了，superview 是一个指针（指针在 32/64 位机器上的位数是不同的），32位机器上，如果指针地址刚好最后8位都是0，那么即使指针不是空的，也会导致返回结果为空</p>\n<p>正确的做法应该为</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPreloadingViewShowing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.mainCtl.preLoadingView.superview) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><blockquote>\n<p>取 int 或指针等类型作为 BOOL 的返回值时要注意，强转的时候可能会只取最低8位作为结果，尽量避免这种情况</p>\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://www.jianshu.com/p/2b97f18918b3?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note\" target=\"_blank\" rel=\"noopener\">重新认识一下OC 中的 BOOL 值</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html\" target=\"_blank\" rel=\"noopener\">32位机器与64位机器数据类型长度</a></li>\n</ul>\n"},{"title":"同步、异步、阻塞、非阻塞的简单理解","date":"2016-08-23T16:00:00.000Z","keywords":"同步;异步;阻塞;非阻塞","_content":"\n>    \n    同步和异步, 是消息的通知机制，描述的是两个对象之间的关系\n>\n    阻塞和非阻塞, 是程序在等待消息(无所谓同步或者异步)时的状态，描述的是单个对象的状态\n    \n# 同步\n同步，就是调用一个函数时，在没有得到结果之前，该函数就不返回\n\n# 异步\n异步，就是就是调用一个函数时，该函数直接返回，等到有结果后，再通过`状态`、`通知`或`回调函数`告诉调用者\n\n# 阻塞\n阻塞是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后线程才继续工作\n\n# 非阻塞\n非阻塞指调用结果返回之前，该函数不会阻塞当前线程\n\n# 例子\n你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下\"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）\n\n而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调\n\n你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先做其他事，比如看电视\n\n# 同步阻塞\n同步阻塞是指你不挂电话，你无法做其他事\n\n效率最低\n\n“你”可以理解为一个程序，而打电话和做其他事分别是2个操作，打电话的操作没有返回，整个程序还被挂起\n\n# 同步非阻塞\n同步非阻塞是指你不挂电话，你可以做其他事\n\n效率低下，你需要边做其他事，边观察老板有没有告诉你结果\n\n虽然打电话的操作没有返回，但是程序可以先执行其他操作（不是执行打电话之后的操作，而是跟打电话行为平行的操作），程序需要在2个函数之间频繁切换\n\n# 异步阻塞\n异步阻塞是指你挂了电话，但你无法做其他事，等老板打电话过来\n\n效率低下\n\n虽然挂了电话，但是程序无法执行其他操作。程序不是被调用函数阻塞，而是被等待函数结果阻塞\n\n# 异步非阻塞\n异步非阻塞是指你挂了电话，你可以做其他事，等老板打电话过来\n\n效率最高\n\n程序没有在两种不同的操作中来回切换\n\n# 参考文章\n1. [IO中同步、异步与阻塞、非阻塞的区别](http://blog.chinaunix.net/uid-26000296-id-3754118.html)\n2. [怎样理解阻塞非阻塞与同步异步的区别？](http://www.linuxidc.com/Linux/2015-07/120338.htm)\n3. [IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）](http://m.blog.csdn.net/article/details?id=5778378)","source":"_posts/同步、异步、阻塞、非阻塞的简单理解.md","raw":"---\ntitle: 同步、异步、阻塞、非阻塞的简单理解\ndate: 2016-08-24\ncategories:\n- Others\nkeywords: 同步;异步;阻塞;非阻塞\n---\n\n>    \n    同步和异步, 是消息的通知机制，描述的是两个对象之间的关系\n>\n    阻塞和非阻塞, 是程序在等待消息(无所谓同步或者异步)时的状态，描述的是单个对象的状态\n    \n# 同步\n同步，就是调用一个函数时，在没有得到结果之前，该函数就不返回\n\n# 异步\n异步，就是就是调用一个函数时，该函数直接返回，等到有结果后，再通过`状态`、`通知`或`回调函数`告诉调用者\n\n# 阻塞\n阻塞是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后线程才继续工作\n\n# 非阻塞\n非阻塞指调用结果返回之前，该函数不会阻塞当前线程\n\n# 例子\n你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下\"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）\n\n而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调\n\n你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先做其他事，比如看电视\n\n# 同步阻塞\n同步阻塞是指你不挂电话，你无法做其他事\n\n效率最低\n\n“你”可以理解为一个程序，而打电话和做其他事分别是2个操作，打电话的操作没有返回，整个程序还被挂起\n\n# 同步非阻塞\n同步非阻塞是指你不挂电话，你可以做其他事\n\n效率低下，你需要边做其他事，边观察老板有没有告诉你结果\n\n虽然打电话的操作没有返回，但是程序可以先执行其他操作（不是执行打电话之后的操作，而是跟打电话行为平行的操作），程序需要在2个函数之间频繁切换\n\n# 异步阻塞\n异步阻塞是指你挂了电话，但你无法做其他事，等老板打电话过来\n\n效率低下\n\n虽然挂了电话，但是程序无法执行其他操作。程序不是被调用函数阻塞，而是被等待函数结果阻塞\n\n# 异步非阻塞\n异步非阻塞是指你挂了电话，你可以做其他事，等老板打电话过来\n\n效率最高\n\n程序没有在两种不同的操作中来回切换\n\n# 参考文章\n1. [IO中同步、异步与阻塞、非阻塞的区别](http://blog.chinaunix.net/uid-26000296-id-3754118.html)\n2. [怎样理解阻塞非阻塞与同步异步的区别？](http://www.linuxidc.com/Linux/2015-07/120338.htm)\n3. [IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）](http://m.blog.csdn.net/article/details?id=5778378)","slug":"同步、异步、阻塞、非阻塞的简单理解","published":1,"updated":"2018-11-02T02:22:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp2opl3h000nu3qwadpeh32v","content":"<blockquote>\n<pre><code>同步和异步, 是消息的通知机制，描述的是两个对象之间的关系\n</code></pre></blockquote>\n<pre><code>阻塞和非阻塞, 是程序在等待消息(无所谓同步或者异步)时的状态，描述的是单个对象的状态\n</code></pre><h1 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h1><p>同步，就是调用一个函数时，在没有得到结果之前，该函数就不返回</p>\n<h1 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h1><p>异步，就是就是调用一个函数时，该函数直接返回，等到有结果后，再通过<code>状态</code>、<code>通知</code>或<code>回调函数</code>告诉调用者</p>\n<h1 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h1><p>阻塞是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后线程才继续工作</p>\n<h1 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a>非阻塞</h1><p>非阻塞指调用结果返回之前，该函数不会阻塞当前线程</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）</p>\n<p>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调</p>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先做其他事，比如看电视</p>\n<h1 id=\"同步阻塞\"><a href=\"#同步阻塞\" class=\"headerlink\" title=\"同步阻塞\"></a>同步阻塞</h1><p>同步阻塞是指你不挂电话，你无法做其他事</p>\n<p>效率最低</p>\n<p>“你”可以理解为一个程序，而打电话和做其他事分别是2个操作，打电话的操作没有返回，整个程序还被挂起</p>\n<h1 id=\"同步非阻塞\"><a href=\"#同步非阻塞\" class=\"headerlink\" title=\"同步非阻塞\"></a>同步非阻塞</h1><p>同步非阻塞是指你不挂电话，你可以做其他事</p>\n<p>效率低下，你需要边做其他事，边观察老板有没有告诉你结果</p>\n<p>虽然打电话的操作没有返回，但是程序可以先执行其他操作（不是执行打电话之后的操作，而是跟打电话行为平行的操作），程序需要在2个函数之间频繁切换</p>\n<h1 id=\"异步阻塞\"><a href=\"#异步阻塞\" class=\"headerlink\" title=\"异步阻塞\"></a>异步阻塞</h1><p>异步阻塞是指你挂了电话，但你无法做其他事，等老板打电话过来</p>\n<p>效率低下</p>\n<p>虽然挂了电话，但是程序无法执行其他操作。程序不是被调用函数阻塞，而是被等待函数结果阻塞</p>\n<h1 id=\"异步非阻塞\"><a href=\"#异步非阻塞\" class=\"headerlink\" title=\"异步非阻塞\"></a>异步非阻塞</h1><p>异步非阻塞是指你挂了电话，你可以做其他事，等老板打电话过来</p>\n<p>效率最高</p>\n<p>程序没有在两种不同的操作中来回切换</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ol>\n<li><a href=\"http://blog.chinaunix.net/uid-26000296-id-3754118.html\" target=\"_blank\" rel=\"noopener\">IO中同步、异步与阻塞、非阻塞的区别</a></li>\n<li><a href=\"http://www.linuxidc.com/Linux/2015-07/120338.htm\" target=\"_blank\" rel=\"noopener\">怎样理解阻塞非阻塞与同步异步的区别？</a></li>\n<li><a href=\"http://m.blog.csdn.net/article/details?id=5778378\" target=\"_blank\" rel=\"noopener\">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<pre><code>同步和异步, 是消息的通知机制，描述的是两个对象之间的关系\n</code></pre></blockquote>\n<pre><code>阻塞和非阻塞, 是程序在等待消息(无所谓同步或者异步)时的状态，描述的是单个对象的状态\n</code></pre><h1 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h1><p>同步，就是调用一个函数时，在没有得到结果之前，该函数就不返回</p>\n<h1 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h1><p>异步，就是就是调用一个函数时，该函数直接返回，等到有结果后，再通过<code>状态</code>、<code>通知</code>或<code>回调函数</code>告诉调用者</p>\n<h1 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h1><p>阻塞是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后线程才继续工作</p>\n<h1 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a>非阻塞</h1><p>非阻塞指调用结果返回之前，该函数不会阻塞当前线程</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）</p>\n<p>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调</p>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先做其他事，比如看电视</p>\n<h1 id=\"同步阻塞\"><a href=\"#同步阻塞\" class=\"headerlink\" title=\"同步阻塞\"></a>同步阻塞</h1><p>同步阻塞是指你不挂电话，你无法做其他事</p>\n<p>效率最低</p>\n<p>“你”可以理解为一个程序，而打电话和做其他事分别是2个操作，打电话的操作没有返回，整个程序还被挂起</p>\n<h1 id=\"同步非阻塞\"><a href=\"#同步非阻塞\" class=\"headerlink\" title=\"同步非阻塞\"></a>同步非阻塞</h1><p>同步非阻塞是指你不挂电话，你可以做其他事</p>\n<p>效率低下，你需要边做其他事，边观察老板有没有告诉你结果</p>\n<p>虽然打电话的操作没有返回，但是程序可以先执行其他操作（不是执行打电话之后的操作，而是跟打电话行为平行的操作），程序需要在2个函数之间频繁切换</p>\n<h1 id=\"异步阻塞\"><a href=\"#异步阻塞\" class=\"headerlink\" title=\"异步阻塞\"></a>异步阻塞</h1><p>异步阻塞是指你挂了电话，但你无法做其他事，等老板打电话过来</p>\n<p>效率低下</p>\n<p>虽然挂了电话，但是程序无法执行其他操作。程序不是被调用函数阻塞，而是被等待函数结果阻塞</p>\n<h1 id=\"异步非阻塞\"><a href=\"#异步非阻塞\" class=\"headerlink\" title=\"异步非阻塞\"></a>异步非阻塞</h1><p>异步非阻塞是指你挂了电话，你可以做其他事，等老板打电话过来</p>\n<p>效率最高</p>\n<p>程序没有在两种不同的操作中来回切换</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ol>\n<li><a href=\"http://blog.chinaunix.net/uid-26000296-id-3754118.html\" target=\"_blank\" rel=\"noopener\">IO中同步、异步与阻塞、非阻塞的区别</a></li>\n<li><a href=\"http://www.linuxidc.com/Linux/2015-07/120338.htm\" target=\"_blank\" rel=\"noopener\">怎样理解阻塞非阻塞与同步异步的区别？</a></li>\n<li><a href=\"http://m.blog.csdn.net/article/details?id=5778378\" target=\"_blank\" rel=\"noopener\">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a></li>\n</ol>\n"},{"title":"如何优雅地记录已阅书籍和电影","date":"2018-05-06T16:00:00.000Z","keywords":"书单;记录;整理;公众号","_content":"\n# 背景需求\n2014 年，那时候我还在读大三，某一天突然萌发了一个想法，要将自己看过的书和电影记录下来。我隐隐约约感受到，沉淀自己的精神生活，竟然让我觉得人生充满意义。记录的瞬间让我觉得会有成就感；等哪天，拿起这份清单，我可以清楚回顾某段时间内看过了哪些书籍和电影，也从侧面知晓当时精神生活的丰富程度\n\n# 方案演进\n那么如何记录我的电影/书籍清单呢？这个方法还是经历了挺多版本迭代的\n\n## 方案1：豆瓣\n在中国，如果有跟我一样沉淀精神生活想法的人，可能大多数会使用豆瓣。他们看完书或电影之后，到豆瓣点一下已看，顺便评分，写上观后感\n\n豆瓣是文青的精神角落，但是对我来说，它不是一个好方案，因为它：\n\n+ 不够纯粹：对于我的需求，豆瓣整个页面的元素太过复杂，入口太深\n+ 不够简洁：看完一部电影，先打开浏览器进入豆瓣（或者豆瓣 App），可能需要登录，搜索电影，点击已阅，评分，写点影评，这个流程对于懒人来说是多么可怕\n+ 不够优雅：把自己的数据给别人，终归心里不自在，哪天想拿这些数据做统计或者迁移都是个问题\n\n## 方案2：Markdown\n与其寄人篱下，不如自立门户。最简单的方法，用一个 txt 纯文本来记录就行了吗？同时作为程序员我们得更有追求，使用 markdown 格式可以更好更方便地排版\n\n[点这里可以看下界面效果](http://norcy.GitHub.io/2013/03/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84/)，对我来说简洁大方即可，因此后续方案的改进也只是改进了记录方法\n\n但是只有一个文本是不够的，因为没有同步到网上，多设备共享就成了问题\t\n## 方案3：Markdown + GitHub + Jekyll\n[Jekyll](http://jekyllcn.com/docs/home/) 是我接触的第一个静态网页生成框架，它与 GitHub Page 的配合使用，使一个博客的搭建变得异常轻松。于是，搭建一个 Jekyll 博客，清单作为博客文章，让 GitHub 托管就成了一个不错的方案。这样就解决了多设备共享的问题\n\n## 方案4：Markdown + GitHub + Hexo\nJekyll 博客只有我这篇清单，而我真正的个人博客是在博客园。[2016 年年初，我开始搭建个人博客](http://www.cnblogs.com/chenyg32/p/5195601.html)，废弃了 Jekyll，使用了更为优雅简洁的 [Hexo](https://hexo.io/)\n\n电影/书籍清单也顺带迁移到[这里](http://norcy.GitHub.io/2013/03/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84/)\n\n至此，阅读完一本书，或者看完一部电影，只要在我的电脑上，更新 .md 文件，使用 Hexo 生成好静态网页文件，然后上传到 GitHub\n\n## 方案5：Markdown + GitHub + Hexo + Travis CI\n2017 年年末，认识了 Travis CI，于是[使用 Travis CI 来简化 Hexo](https://www.jianshu.com/p/5e74046e7a0f)\n\n引入了 Travis CI，更新清单就省略了一个使用 Hexo 生成静态网页的步骤\n\n\n## 终极方案：Markdown + GitHub + Hexo + Travis CI + 公众号 + 腾讯云\n以上看似完美的方案，其实实践下来还是挺麻烦的。每次电影院看完电影，还要等回家之后打开电脑，更新博客，这个流程还是不够懒惰。于是我想到了公众号，毕竟移动互联网浪潮下，真正几乎不离身的不是电脑，而是手机\n\n一个可行的想法是：使用公众号连接自己的服务器，然后利用服务器更新清单文件，上传到 GitHub，剩下的交给 Travis CI 去更新博客。这个想法大概在我脑里徘徊了一年，今日终于克服拖延症得以实现\n\n最终的效果就是，阅读完一本书，或者看完一部电影，只要打开我的公众号，回复如下格式的命令，一会之后我的博客就自动更新完毕啦\n\n>\n\tadd/del name [m/b/s]\n\n其中 add/del 表示增加或删除，必填；name 必填，表示名字；类型选填，m/b/s 表示电影/书籍/连续剧，默认是电影\n\n\n# 技术实现\n我是专职 iOS 开发，对后台开发的知识处在青铜级别，所以这里记录下服务器端关键代码的实现。如何打通公众号和自己的服务器，以及如何配置服务器在这里就不赘述\n\n这个项目使用的语言是 php + python，主要涉及以下几个文件：\n\n+ index.php：负责与公众号接口对接，对用户发送的消息进行验证解析，并提取电影/书籍名称，以及类型，传递给 blogUpdater.php 处理，并返回博客链接给用户\n+ blogUpdater.php：负责调用 isee.py，传递名称、类型、年月日等\n+ ReadList.txt : 轻量级数据库，维护所有阅读数据，数据示例如下，其中 m 表示 movie，b 表示 book\n\n> \n\t2018 04 23 m 起跑线\n\t2018 02 01 m 唐人街探案2\n\t2018 02 01 b 活着本来单纯\n\t2018 01 01 m 神秘巨星\n\t2018 01 01 m 无问西东\n\t2018 01 01 m 奇门遁甲\n\t2017 12 01 m 解忧杂货店\n\t2017 12 01 b 少有人走的路\n\t2017 11 01 m 缝纫机乐队\n\n+ isee.py : 关键文件，主要负责更新 ReadList.txt，并输出 markdown 文件，最后执行 git 操作。其主要逻辑如下\n\n>\n\t1. 按行读取文件 ReadList.txt，每一行的数据包括名字、类型、年月日以及链接，如果是 del 命令则比对名称和类型，如果匹配说明该数据是要删除的，不添加到 list，否则默认添加到 list\n\t2. 如果是 add 命令则将新数据添加到 list\n\t3. 对 list 的内容进行去重\n\t4. 将 list 的内容输出到 tmpReadList.txt，输出结束之后删除 ReadList.txt，重命名其为新的 ReadList.txt\n\t5. 将 list 的内容输出到 markdown 文件，为了优化可读性，将最近的记录放在前面，排序算法如下：年倒序，月正序（即201801、201802...201701、201702...）\n\t6. 最后执行 git 操作，上传 markdown 文件\n\n\n# 踩坑记录\n以下部分是开发过程中踩到的坑，记录一下以备忘\n\n## 公众号接口调试\n可以使用微信公众号的[在线接口调试工具](https://mp.weixin.qq.com/debug)来测试服务器接口是否正常\n\n## php 调用 Shell 接口以执行 Python\n关键代码：\n\n```php\n$cmd = \"python3 /var/www/html/Norcy.github.io/isee.py \".$objectName.\" \".$type.\" \".$year.\" \".$mouth.\" \".$date.\" >/dev/null  &\";\nshell_exec($cmd);\n```\n\n注意以下几个点：\n\n1. 使用 `shell_exec` 来调用 shell 命令\n2. `&` 的作用是 python 脚本会在后台执行\n3. 如果是调试模式，可以使用 `2>&1` 和 `var_dump` 来查看输出\n\n\t```php\n\t$cmd = \"python3 /var/www/html/Norcy.github.io/isee.py \".$objectName.\" \".$type.\" \".$year.\" \".$mouth.\" \".$date.\" 2>&1 &\";\n\tvar_dump(shell_exec($cmd));\n\t```\n\n4. `>/dev/null` 和 `2>&1` 是什么呢？\n\n>\n\t/dev/null ：代表空设备文件\n\t>  ：代表重定向到哪里\n\t0 : 表示 stdin 标准输入\n\t1 : 表示 stdout 标准输出，系统默认值是1，所以\">/dev/null\"等同于\"1>/dev/null\"\n\t2 : 表示 stderr 标准错误\n\t& : 表示等同于的意思，2>&1，表示2的输出重定向等同于1\n>\n\t1 > /dev/null 2>&1 : 标准输出输出到空文件，标准错误也输出到空文件\n>\n\tcmd >a 2>a 和 cmd >a 2>&1 为什么不同？\n\tcmd >a 2>a ：stdout 和 stderr 都直接送往文件 a，a文件会被打开两遍，由此导致 stdout 和 stderr 互相覆盖\n\tcmd >a 2>&1 ：stdout 直接送往文件 a，stderr 是继承了 FD1 的管道之后，再被送往文件 a。a 文件只被打开一遍，就是 FD1 将其打开\n\n\n## 公众号超时逻辑\n直接访问 php 执行代码的时候没有任何问题，但是通过公众号访问，返回的数据却是空的，没任何提示。找了许久，最终原因是 php 的处理时间太长，公众号接口超时\n\n其实主要的耗时操作是 isee.py 的执行，因此只需要在执行 python 的时候，命令后面添加 `&`，让其后台执行，就可以解决超时逻辑\n\n\n## Python 调用 Shell 以执行 Git\n\n由于 blogUpdater.php 和 isee.py 所在的目录不一样，因此这里是一个大坑，执行 Shell 的时候需要先将当前目录切换到 isee.py 所在的目录\n\n```python\nos.chdir(sys.path[0]);\nos.system(\"/usr/bin/git pull origin HexoBackup\");\nos.system(\"/usr/bin/git add .\");\nos.system(\"/usr/bin/git commit -m 'Update From PublicAccount'\");\nos.system(\"/usr/bin/git push origin HexoBackup\");    \n```\n\n## 代码中文乱码问题\n+ python 文件页首添加 `#coding=utf-8`\n+ php 文件页首添加\n\n```\n$locale='en_US.UTF-8';  \nsetlocale(LC_ALL,$locale);  \nputenv('LC_ALL='.$locale);\n```\n\n## 终端中文乱码问题\n直接修改当前用户目录下的 .bashrc 文件，在最后添加如下：\n\n```shell\nexport LC_ALL=C\nexport LANG=\"zh_CN.utf8\"\nexport LC_ALL=\"zh_CN.utf8\"\nexport LC_CTYPE=\"zh_CN.utf8\"\n```\n\n## 用户读写权限问题和文件所有者权限问题\nApache 运行时用户是 www-data，而不是我 ssh 登录时的 ubuntu 用户，因此会遇到一个又一个的文件权限问题。我的方法是 ssh 登录之后，切到 www-data 用户来执行所有操作，并更改相关的文件权限和所属群组\n\n相关命令有 `sudo -i`，`su - www-data`，`chmod -R 777 ./`，`chown -R www-data:www-data ./`，`whoami`\n\n## 使用 ssh 而不是 https 的方式来配置 GitHub\n1. 使用 `git remote -v` or `cat .git/config` 来查看当前的 git 配置\n2. 编辑 `.git/config` 文件 或者执行 `git remote set-url origin git@github.com:username/username.github.io.git` 来更改配置\n3. 其他的按照[官方文档](https://help.github.com/articles/connecting-to-github-with-ssh/)即可\n\n# 未来改进\n1. json 代替 txt，通用性更高\n2. 抓取豆瓣链接，将每行数据变成一个超链接，方便随时跳转到豆瓣\n3. 抓取豆瓣海报，可以做成海报墙的形式\n4. 对数据进行统计，画出各种统计图\n\n> 至此，虽然是简简单单的功能，但是，it makes my world better.\n","source":"_posts/如何优雅地记录已阅书籍和电影.md","raw":"---\ntitle: 如何优雅地记录已阅书籍和电影\ndate: 2018-05-07\ncategories:\n- 技术改变生活\nkeywords: 书单;记录;整理;公众号\n---\n\n# 背景需求\n2014 年，那时候我还在读大三，某一天突然萌发了一个想法，要将自己看过的书和电影记录下来。我隐隐约约感受到，沉淀自己的精神生活，竟然让我觉得人生充满意义。记录的瞬间让我觉得会有成就感；等哪天，拿起这份清单，我可以清楚回顾某段时间内看过了哪些书籍和电影，也从侧面知晓当时精神生活的丰富程度\n\n# 方案演进\n那么如何记录我的电影/书籍清单呢？这个方法还是经历了挺多版本迭代的\n\n## 方案1：豆瓣\n在中国，如果有跟我一样沉淀精神生活想法的人，可能大多数会使用豆瓣。他们看完书或电影之后，到豆瓣点一下已看，顺便评分，写上观后感\n\n豆瓣是文青的精神角落，但是对我来说，它不是一个好方案，因为它：\n\n+ 不够纯粹：对于我的需求，豆瓣整个页面的元素太过复杂，入口太深\n+ 不够简洁：看完一部电影，先打开浏览器进入豆瓣（或者豆瓣 App），可能需要登录，搜索电影，点击已阅，评分，写点影评，这个流程对于懒人来说是多么可怕\n+ 不够优雅：把自己的数据给别人，终归心里不自在，哪天想拿这些数据做统计或者迁移都是个问题\n\n## 方案2：Markdown\n与其寄人篱下，不如自立门户。最简单的方法，用一个 txt 纯文本来记录就行了吗？同时作为程序员我们得更有追求，使用 markdown 格式可以更好更方便地排版\n\n[点这里可以看下界面效果](http://norcy.GitHub.io/2013/03/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84/)，对我来说简洁大方即可，因此后续方案的改进也只是改进了记录方法\n\n但是只有一个文本是不够的，因为没有同步到网上，多设备共享就成了问题\t\n## 方案3：Markdown + GitHub + Jekyll\n[Jekyll](http://jekyllcn.com/docs/home/) 是我接触的第一个静态网页生成框架，它与 GitHub Page 的配合使用，使一个博客的搭建变得异常轻松。于是，搭建一个 Jekyll 博客，清单作为博客文章，让 GitHub 托管就成了一个不错的方案。这样就解决了多设备共享的问题\n\n## 方案4：Markdown + GitHub + Hexo\nJekyll 博客只有我这篇清单，而我真正的个人博客是在博客园。[2016 年年初，我开始搭建个人博客](http://www.cnblogs.com/chenyg32/p/5195601.html)，废弃了 Jekyll，使用了更为优雅简洁的 [Hexo](https://hexo.io/)\n\n电影/书籍清单也顺带迁移到[这里](http://norcy.GitHub.io/2013/03/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84/)\n\n至此，阅读完一本书，或者看完一部电影，只要在我的电脑上，更新 .md 文件，使用 Hexo 生成好静态网页文件，然后上传到 GitHub\n\n## 方案5：Markdown + GitHub + Hexo + Travis CI\n2017 年年末，认识了 Travis CI，于是[使用 Travis CI 来简化 Hexo](https://www.jianshu.com/p/5e74046e7a0f)\n\n引入了 Travis CI，更新清单就省略了一个使用 Hexo 生成静态网页的步骤\n\n\n## 终极方案：Markdown + GitHub + Hexo + Travis CI + 公众号 + 腾讯云\n以上看似完美的方案，其实实践下来还是挺麻烦的。每次电影院看完电影，还要等回家之后打开电脑，更新博客，这个流程还是不够懒惰。于是我想到了公众号，毕竟移动互联网浪潮下，真正几乎不离身的不是电脑，而是手机\n\n一个可行的想法是：使用公众号连接自己的服务器，然后利用服务器更新清单文件，上传到 GitHub，剩下的交给 Travis CI 去更新博客。这个想法大概在我脑里徘徊了一年，今日终于克服拖延症得以实现\n\n最终的效果就是，阅读完一本书，或者看完一部电影，只要打开我的公众号，回复如下格式的命令，一会之后我的博客就自动更新完毕啦\n\n>\n\tadd/del name [m/b/s]\n\n其中 add/del 表示增加或删除，必填；name 必填，表示名字；类型选填，m/b/s 表示电影/书籍/连续剧，默认是电影\n\n\n# 技术实现\n我是专职 iOS 开发，对后台开发的知识处在青铜级别，所以这里记录下服务器端关键代码的实现。如何打通公众号和自己的服务器，以及如何配置服务器在这里就不赘述\n\n这个项目使用的语言是 php + python，主要涉及以下几个文件：\n\n+ index.php：负责与公众号接口对接，对用户发送的消息进行验证解析，并提取电影/书籍名称，以及类型，传递给 blogUpdater.php 处理，并返回博客链接给用户\n+ blogUpdater.php：负责调用 isee.py，传递名称、类型、年月日等\n+ ReadList.txt : 轻量级数据库，维护所有阅读数据，数据示例如下，其中 m 表示 movie，b 表示 book\n\n> \n\t2018 04 23 m 起跑线\n\t2018 02 01 m 唐人街探案2\n\t2018 02 01 b 活着本来单纯\n\t2018 01 01 m 神秘巨星\n\t2018 01 01 m 无问西东\n\t2018 01 01 m 奇门遁甲\n\t2017 12 01 m 解忧杂货店\n\t2017 12 01 b 少有人走的路\n\t2017 11 01 m 缝纫机乐队\n\n+ isee.py : 关键文件，主要负责更新 ReadList.txt，并输出 markdown 文件，最后执行 git 操作。其主要逻辑如下\n\n>\n\t1. 按行读取文件 ReadList.txt，每一行的数据包括名字、类型、年月日以及链接，如果是 del 命令则比对名称和类型，如果匹配说明该数据是要删除的，不添加到 list，否则默认添加到 list\n\t2. 如果是 add 命令则将新数据添加到 list\n\t3. 对 list 的内容进行去重\n\t4. 将 list 的内容输出到 tmpReadList.txt，输出结束之后删除 ReadList.txt，重命名其为新的 ReadList.txt\n\t5. 将 list 的内容输出到 markdown 文件，为了优化可读性，将最近的记录放在前面，排序算法如下：年倒序，月正序（即201801、201802...201701、201702...）\n\t6. 最后执行 git 操作，上传 markdown 文件\n\n\n# 踩坑记录\n以下部分是开发过程中踩到的坑，记录一下以备忘\n\n## 公众号接口调试\n可以使用微信公众号的[在线接口调试工具](https://mp.weixin.qq.com/debug)来测试服务器接口是否正常\n\n## php 调用 Shell 接口以执行 Python\n关键代码：\n\n```php\n$cmd = \"python3 /var/www/html/Norcy.github.io/isee.py \".$objectName.\" \".$type.\" \".$year.\" \".$mouth.\" \".$date.\" >/dev/null  &\";\nshell_exec($cmd);\n```\n\n注意以下几个点：\n\n1. 使用 `shell_exec` 来调用 shell 命令\n2. `&` 的作用是 python 脚本会在后台执行\n3. 如果是调试模式，可以使用 `2>&1` 和 `var_dump` 来查看输出\n\n\t```php\n\t$cmd = \"python3 /var/www/html/Norcy.github.io/isee.py \".$objectName.\" \".$type.\" \".$year.\" \".$mouth.\" \".$date.\" 2>&1 &\";\n\tvar_dump(shell_exec($cmd));\n\t```\n\n4. `>/dev/null` 和 `2>&1` 是什么呢？\n\n>\n\t/dev/null ：代表空设备文件\n\t>  ：代表重定向到哪里\n\t0 : 表示 stdin 标准输入\n\t1 : 表示 stdout 标准输出，系统默认值是1，所以\">/dev/null\"等同于\"1>/dev/null\"\n\t2 : 表示 stderr 标准错误\n\t& : 表示等同于的意思，2>&1，表示2的输出重定向等同于1\n>\n\t1 > /dev/null 2>&1 : 标准输出输出到空文件，标准错误也输出到空文件\n>\n\tcmd >a 2>a 和 cmd >a 2>&1 为什么不同？\n\tcmd >a 2>a ：stdout 和 stderr 都直接送往文件 a，a文件会被打开两遍，由此导致 stdout 和 stderr 互相覆盖\n\tcmd >a 2>&1 ：stdout 直接送往文件 a，stderr 是继承了 FD1 的管道之后，再被送往文件 a。a 文件只被打开一遍，就是 FD1 将其打开\n\n\n## 公众号超时逻辑\n直接访问 php 执行代码的时候没有任何问题，但是通过公众号访问，返回的数据却是空的，没任何提示。找了许久，最终原因是 php 的处理时间太长，公众号接口超时\n\n其实主要的耗时操作是 isee.py 的执行，因此只需要在执行 python 的时候，命令后面添加 `&`，让其后台执行，就可以解决超时逻辑\n\n\n## Python 调用 Shell 以执行 Git\n\n由于 blogUpdater.php 和 isee.py 所在的目录不一样，因此这里是一个大坑，执行 Shell 的时候需要先将当前目录切换到 isee.py 所在的目录\n\n```python\nos.chdir(sys.path[0]);\nos.system(\"/usr/bin/git pull origin HexoBackup\");\nos.system(\"/usr/bin/git add .\");\nos.system(\"/usr/bin/git commit -m 'Update From PublicAccount'\");\nos.system(\"/usr/bin/git push origin HexoBackup\");    \n```\n\n## 代码中文乱码问题\n+ python 文件页首添加 `#coding=utf-8`\n+ php 文件页首添加\n\n```\n$locale='en_US.UTF-8';  \nsetlocale(LC_ALL,$locale);  \nputenv('LC_ALL='.$locale);\n```\n\n## 终端中文乱码问题\n直接修改当前用户目录下的 .bashrc 文件，在最后添加如下：\n\n```shell\nexport LC_ALL=C\nexport LANG=\"zh_CN.utf8\"\nexport LC_ALL=\"zh_CN.utf8\"\nexport LC_CTYPE=\"zh_CN.utf8\"\n```\n\n## 用户读写权限问题和文件所有者权限问题\nApache 运行时用户是 www-data，而不是我 ssh 登录时的 ubuntu 用户，因此会遇到一个又一个的文件权限问题。我的方法是 ssh 登录之后，切到 www-data 用户来执行所有操作，并更改相关的文件权限和所属群组\n\n相关命令有 `sudo -i`，`su - www-data`，`chmod -R 777 ./`，`chown -R www-data:www-data ./`，`whoami`\n\n## 使用 ssh 而不是 https 的方式来配置 GitHub\n1. 使用 `git remote -v` or `cat .git/config` 来查看当前的 git 配置\n2. 编辑 `.git/config` 文件 或者执行 `git remote set-url origin git@github.com:username/username.github.io.git` 来更改配置\n3. 其他的按照[官方文档](https://help.github.com/articles/connecting-to-github-with-ssh/)即可\n\n# 未来改进\n1. json 代替 txt，通用性更高\n2. 抓取豆瓣链接，将每行数据变成一个超链接，方便随时跳转到豆瓣\n3. 抓取豆瓣海报，可以做成海报墙的形式\n4. 对数据进行统计，画出各种统计图\n\n> 至此，虽然是简简单单的功能，但是，it makes my world better.\n","slug":"如何优雅地记录已阅书籍和电影","published":1,"updated":"2018-11-02T02:22:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp2opl3i000pu3qwyydmvas3","content":"<h1 id=\"背景需求\"><a href=\"#背景需求\" class=\"headerlink\" title=\"背景需求\"></a>背景需求</h1><p>2014 年，那时候我还在读大三，某一天突然萌发了一个想法，要将自己看过的书和电影记录下来。我隐隐约约感受到，沉淀自己的精神生活，竟然让我觉得人生充满意义。记录的瞬间让我觉得会有成就感；等哪天，拿起这份清单，我可以清楚回顾某段时间内看过了哪些书籍和电影，也从侧面知晓当时精神生活的丰富程度</p>\n<h1 id=\"方案演进\"><a href=\"#方案演进\" class=\"headerlink\" title=\"方案演进\"></a>方案演进</h1><p>那么如何记录我的电影/书籍清单呢？这个方法还是经历了挺多版本迭代的</p>\n<h2 id=\"方案1：豆瓣\"><a href=\"#方案1：豆瓣\" class=\"headerlink\" title=\"方案1：豆瓣\"></a>方案1：豆瓣</h2><p>在中国，如果有跟我一样沉淀精神生活想法的人，可能大多数会使用豆瓣。他们看完书或电影之后，到豆瓣点一下已看，顺便评分，写上观后感</p>\n<p>豆瓣是文青的精神角落，但是对我来说，它不是一个好方案，因为它：</p>\n<ul>\n<li>不够纯粹：对于我的需求，豆瓣整个页面的元素太过复杂，入口太深</li>\n<li>不够简洁：看完一部电影，先打开浏览器进入豆瓣（或者豆瓣 App），可能需要登录，搜索电影，点击已阅，评分，写点影评，这个流程对于懒人来说是多么可怕</li>\n<li>不够优雅：把自己的数据给别人，终归心里不自在，哪天想拿这些数据做统计或者迁移都是个问题</li>\n</ul>\n<h2 id=\"方案2：Markdown\"><a href=\"#方案2：Markdown\" class=\"headerlink\" title=\"方案2：Markdown\"></a>方案2：Markdown</h2><p>与其寄人篱下，不如自立门户。最简单的方法，用一个 txt 纯文本来记录就行了吗？同时作为程序员我们得更有追求，使用 markdown 格式可以更好更方便地排版</p>\n<p><a href=\"http://norcy.GitHub.io/2013/03/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84/\">点这里可以看下界面效果</a>，对我来说简洁大方即可，因此后续方案的改进也只是改进了记录方法</p>\n<p>但是只有一个文本是不够的，因为没有同步到网上，多设备共享就成了问题    </p>\n<h2 id=\"方案3：Markdown-GitHub-Jekyll\"><a href=\"#方案3：Markdown-GitHub-Jekyll\" class=\"headerlink\" title=\"方案3：Markdown + GitHub + Jekyll\"></a>方案3：Markdown + GitHub + Jekyll</h2><p><a href=\"http://jekyllcn.com/docs/home/\" target=\"_blank\" rel=\"noopener\">Jekyll</a> 是我接触的第一个静态网页生成框架，它与 GitHub Page 的配合使用，使一个博客的搭建变得异常轻松。于是，搭建一个 Jekyll 博客，清单作为博客文章，让 GitHub 托管就成了一个不错的方案。这样就解决了多设备共享的问题</p>\n<h2 id=\"方案4：Markdown-GitHub-Hexo\"><a href=\"#方案4：Markdown-GitHub-Hexo\" class=\"headerlink\" title=\"方案4：Markdown + GitHub + Hexo\"></a>方案4：Markdown + GitHub + Hexo</h2><p>Jekyll 博客只有我这篇清单，而我真正的个人博客是在博客园。<a href=\"http://www.cnblogs.com/chenyg32/p/5195601.html\" target=\"_blank\" rel=\"noopener\">2016 年年初，我开始搭建个人博客</a>，废弃了 Jekyll，使用了更为优雅简洁的 <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a></p>\n<p>电影/书籍清单也顺带迁移到<a href=\"http://norcy.GitHub.io/2013/03/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84/\">这里</a></p>\n<p>至此，阅读完一本书，或者看完一部电影，只要在我的电脑上，更新 .md 文件，使用 Hexo 生成好静态网页文件，然后上传到 GitHub</p>\n<h2 id=\"方案5：Markdown-GitHub-Hexo-Travis-CI\"><a href=\"#方案5：Markdown-GitHub-Hexo-Travis-CI\" class=\"headerlink\" title=\"方案5：Markdown + GitHub + Hexo + Travis CI\"></a>方案5：Markdown + GitHub + Hexo + Travis CI</h2><p>2017 年年末，认识了 Travis CI，于是<a href=\"https://www.jianshu.com/p/5e74046e7a0f\" target=\"_blank\" rel=\"noopener\">使用 Travis CI 来简化 Hexo</a></p>\n<p>引入了 Travis CI，更新清单就省略了一个使用 Hexo 生成静态网页的步骤</p>\n<h2 id=\"终极方案：Markdown-GitHub-Hexo-Travis-CI-公众号-腾讯云\"><a href=\"#终极方案：Markdown-GitHub-Hexo-Travis-CI-公众号-腾讯云\" class=\"headerlink\" title=\"终极方案：Markdown + GitHub + Hexo + Travis CI + 公众号 + 腾讯云\"></a>终极方案：Markdown + GitHub + Hexo + Travis CI + 公众号 + 腾讯云</h2><p>以上看似完美的方案，其实实践下来还是挺麻烦的。每次电影院看完电影，还要等回家之后打开电脑，更新博客，这个流程还是不够懒惰。于是我想到了公众号，毕竟移动互联网浪潮下，真正几乎不离身的不是电脑，而是手机</p>\n<p>一个可行的想法是：使用公众号连接自己的服务器，然后利用服务器更新清单文件，上传到 GitHub，剩下的交给 Travis CI 去更新博客。这个想法大概在我脑里徘徊了一年，今日终于克服拖延症得以实现</p>\n<p>最终的效果就是，阅读完一本书，或者看完一部电影，只要打开我的公众号，回复如下格式的命令，一会之后我的博客就自动更新完毕啦</p>\n<blockquote>\n</blockquote>\n<pre><code>add/del name [m/b/s]\n</code></pre><p>其中 add/del 表示增加或删除，必填；name 必填，表示名字；类型选填，m/b/s 表示电影/书籍/连续剧，默认是电影</p>\n<h1 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h1><p>我是专职 iOS 开发，对后台开发的知识处在青铜级别，所以这里记录下服务器端关键代码的实现。如何打通公众号和自己的服务器，以及如何配置服务器在这里就不赘述</p>\n<p>这个项目使用的语言是 php + python，主要涉及以下几个文件：</p>\n<ul>\n<li>index.php：负责与公众号接口对接，对用户发送的消息进行验证解析，并提取电影/书籍名称，以及类型，传递给 blogUpdater.php 处理，并返回博客链接给用户</li>\n<li>blogUpdater.php：负责调用 isee.py，传递名称、类型、年月日等</li>\n<li>ReadList.txt : 轻量级数据库，维护所有阅读数据，数据示例如下，其中 m 表示 movie，b 表示 book</li>\n</ul>\n<blockquote>\n</blockquote>\n<pre><code>2018 04 23 m 起跑线\n2018 02 01 m 唐人街探案2\n2018 02 01 b 活着本来单纯\n2018 01 01 m 神秘巨星\n2018 01 01 m 无问西东\n2018 01 01 m 奇门遁甲\n2017 12 01 m 解忧杂货店\n2017 12 01 b 少有人走的路\n2017 11 01 m 缝纫机乐队\n</code></pre><ul>\n<li>isee.py : 关键文件，主要负责更新 ReadList.txt，并输出 markdown 文件，最后执行 git 操作。其主要逻辑如下</li>\n</ul>\n<blockquote>\n</blockquote>\n<pre><code>1. 按行读取文件 ReadList.txt，每一行的数据包括名字、类型、年月日以及链接，如果是 del 命令则比对名称和类型，如果匹配说明该数据是要删除的，不添加到 list，否则默认添加到 list\n2. 如果是 add 命令则将新数据添加到 list\n3. 对 list 的内容进行去重\n4. 将 list 的内容输出到 tmpReadList.txt，输出结束之后删除 ReadList.txt，重命名其为新的 ReadList.txt\n5. 将 list 的内容输出到 markdown 文件，为了优化可读性，将最近的记录放在前面，排序算法如下：年倒序，月正序（即201801、201802...201701、201702...）\n6. 最后执行 git 操作，上传 markdown 文件\n</code></pre><h1 id=\"踩坑记录\"><a href=\"#踩坑记录\" class=\"headerlink\" title=\"踩坑记录\"></a>踩坑记录</h1><p>以下部分是开发过程中踩到的坑，记录一下以备忘</p>\n<h2 id=\"公众号接口调试\"><a href=\"#公众号接口调试\" class=\"headerlink\" title=\"公众号接口调试\"></a>公众号接口调试</h2><p>可以使用微信公众号的<a href=\"https://mp.weixin.qq.com/debug\" target=\"_blank\" rel=\"noopener\">在线接口调试工具</a>来测试服务器接口是否正常</p>\n<h2 id=\"php-调用-Shell-接口以执行-Python\"><a href=\"#php-调用-Shell-接口以执行-Python\" class=\"headerlink\" title=\"php 调用 Shell 接口以执行 Python\"></a>php 调用 Shell 接口以执行 Python</h2><p>关键代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cmd = <span class=\"string\">\"python3 /var/www/html/Norcy.github.io/isee.py \"</span>.$objectName.<span class=\"string\">\" \"</span>.$type.<span class=\"string\">\" \"</span>.$year.<span class=\"string\">\" \"</span>.$mouth.<span class=\"string\">\" \"</span>.$date.<span class=\"string\">\" &gt;/dev/null  &amp;\"</span>;</span><br><span class=\"line\">shell_exec($cmd);</span><br></pre></td></tr></table></figure>\n<p>注意以下几个点：</p>\n<ol>\n<li>使用 <code>shell_exec</code> 来调用 shell 命令</li>\n<li><code>&amp;</code> 的作用是 python 脚本会在后台执行</li>\n<li><p>如果是调试模式，可以使用 <code>2&gt;&amp;1</code> 和 <code>var_dump</code> 来查看输出</p>\n <figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cmd = <span class=\"string\">\"python3 /var/www/html/Norcy.github.io/isee.py \"</span>.$objectName.<span class=\"string\">\" \"</span>.$type.<span class=\"string\">\" \"</span>.$year.<span class=\"string\">\" \"</span>.$mouth.<span class=\"string\">\" \"</span>.$date.<span class=\"string\">\" 2&gt;&amp;1 &amp;\"</span>;</span><br><span class=\"line\">var_dump(shell_exec($cmd));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>&gt;/dev/null</code> 和 <code>2&gt;&amp;1</code> 是什么呢？</p>\n</li>\n</ol>\n<blockquote>\n</blockquote>\n<pre><code>/dev/null ：代表空设备文件\n&gt;  ：代表重定向到哪里\n0 : 表示 stdin 标准输入\n1 : 表示 stdout 标准输出，系统默认值是1，所以&quot;&gt;/dev/null&quot;等同于&quot;1&gt;/dev/null&quot;\n2 : 表示 stderr 标准错误\n&amp; : 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1\n</code></pre><blockquote>\n</blockquote>\n<pre><code>1 &gt; /dev/null 2&gt;&amp;1 : 标准输出输出到空文件，标准错误也输出到空文件\n</code></pre><blockquote>\n</blockquote>\n<pre><code>cmd &gt;a 2&gt;a 和 cmd &gt;a 2&gt;&amp;1 为什么不同？\ncmd &gt;a 2&gt;a ：stdout 和 stderr 都直接送往文件 a，a文件会被打开两遍，由此导致 stdout 和 stderr 互相覆盖\ncmd &gt;a 2&gt;&amp;1 ：stdout 直接送往文件 a，stderr 是继承了 FD1 的管道之后，再被送往文件 a。a 文件只被打开一遍，就是 FD1 将其打开\n</code></pre><h2 id=\"公众号超时逻辑\"><a href=\"#公众号超时逻辑\" class=\"headerlink\" title=\"公众号超时逻辑\"></a>公众号超时逻辑</h2><p>直接访问 php 执行代码的时候没有任何问题，但是通过公众号访问，返回的数据却是空的，没任何提示。找了许久，最终原因是 php 的处理时间太长，公众号接口超时</p>\n<p>其实主要的耗时操作是 isee.py 的执行，因此只需要在执行 python 的时候，命令后面添加 <code>&amp;</code>，让其后台执行，就可以解决超时逻辑</p>\n<h2 id=\"Python-调用-Shell-以执行-Git\"><a href=\"#Python-调用-Shell-以执行-Git\" class=\"headerlink\" title=\"Python 调用 Shell 以执行 Git\"></a>Python 调用 Shell 以执行 Git</h2><p>由于 blogUpdater.php 和 isee.py 所在的目录不一样，因此这里是一个大坑，执行 Shell 的时候需要先将当前目录切换到 isee.py 所在的目录</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.chdir(sys.path[<span class=\"number\">0</span>]);</span><br><span class=\"line\">os.system(<span class=\"string\">\"/usr/bin/git pull origin HexoBackup\"</span>);</span><br><span class=\"line\">os.system(<span class=\"string\">\"/usr/bin/git add .\"</span>);</span><br><span class=\"line\">os.system(<span class=\"string\">\"/usr/bin/git commit -m 'Update From PublicAccount'\"</span>);</span><br><span class=\"line\">os.system(<span class=\"string\">\"/usr/bin/git push origin HexoBackup\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码中文乱码问题\"><a href=\"#代码中文乱码问题\" class=\"headerlink\" title=\"代码中文乱码问题\"></a>代码中文乱码问题</h2><ul>\n<li>python 文件页首添加 <code>#coding=utf-8</code></li>\n<li>php 文件页首添加</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$locale=&apos;en_US.UTF-8&apos;;  </span><br><span class=\"line\">setlocale(LC_ALL,$locale);  </span><br><span class=\"line\">putenv(&apos;LC_ALL=&apos;.$locale);</span><br></pre></td></tr></table></figure>\n<h2 id=\"终端中文乱码问题\"><a href=\"#终端中文乱码问题\" class=\"headerlink\" title=\"终端中文乱码问题\"></a>终端中文乱码问题</h2><p>直接修改当前用户目录下的 .bashrc 文件，在最后添加如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export LC_ALL=C</span><br><span class=\"line\">export LANG=\"zh_CN.utf8\"</span><br><span class=\"line\">export LC_ALL=\"zh_CN.utf8\"</span><br><span class=\"line\">export LC_CTYPE=\"zh_CN.utf8\"</span><br></pre></td></tr></table></figure>\n<h2 id=\"用户读写权限问题和文件所有者权限问题\"><a href=\"#用户读写权限问题和文件所有者权限问题\" class=\"headerlink\" title=\"用户读写权限问题和文件所有者权限问题\"></a>用户读写权限问题和文件所有者权限问题</h2><p>Apache 运行时用户是 www-data，而不是我 ssh 登录时的 ubuntu 用户，因此会遇到一个又一个的文件权限问题。我的方法是 ssh 登录之后，切到 www-data 用户来执行所有操作，并更改相关的文件权限和所属群组</p>\n<p>相关命令有 <code>sudo -i</code>，<code>su - www-data</code>，<code>chmod -R 777 ./</code>，<code>chown -R www-data:www-data ./</code>，<code>whoami</code></p>\n<h2 id=\"使用-ssh-而不是-https-的方式来配置-GitHub\"><a href=\"#使用-ssh-而不是-https-的方式来配置-GitHub\" class=\"headerlink\" title=\"使用 ssh 而不是 https 的方式来配置 GitHub\"></a>使用 ssh 而不是 https 的方式来配置 GitHub</h2><ol>\n<li>使用 <code>git remote -v</code> or <code>cat .git/config</code> 来查看当前的 git 配置</li>\n<li>编辑 <code>.git/config</code> 文件 或者执行 <code>git remote set-url origin git@github.com:username/username.github.io.git</code> 来更改配置</li>\n<li>其他的按照<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"noopener\">官方文档</a>即可</li>\n</ol>\n<h1 id=\"未来改进\"><a href=\"#未来改进\" class=\"headerlink\" title=\"未来改进\"></a>未来改进</h1><ol>\n<li>json 代替 txt，通用性更高</li>\n<li>抓取豆瓣链接，将每行数据变成一个超链接，方便随时跳转到豆瓣</li>\n<li>抓取豆瓣海报，可以做成海报墙的形式</li>\n<li>对数据进行统计，画出各种统计图</li>\n</ol>\n<blockquote>\n<p>至此，虽然是简简单单的功能，但是，it makes my world better.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景需求\"><a href=\"#背景需求\" class=\"headerlink\" title=\"背景需求\"></a>背景需求</h1><p>2014 年，那时候我还在读大三，某一天突然萌发了一个想法，要将自己看过的书和电影记录下来。我隐隐约约感受到，沉淀自己的精神生活，竟然让我觉得人生充满意义。记录的瞬间让我觉得会有成就感；等哪天，拿起这份清单，我可以清楚回顾某段时间内看过了哪些书籍和电影，也从侧面知晓当时精神生活的丰富程度</p>\n<h1 id=\"方案演进\"><a href=\"#方案演进\" class=\"headerlink\" title=\"方案演进\"></a>方案演进</h1><p>那么如何记录我的电影/书籍清单呢？这个方法还是经历了挺多版本迭代的</p>\n<h2 id=\"方案1：豆瓣\"><a href=\"#方案1：豆瓣\" class=\"headerlink\" title=\"方案1：豆瓣\"></a>方案1：豆瓣</h2><p>在中国，如果有跟我一样沉淀精神生活想法的人，可能大多数会使用豆瓣。他们看完书或电影之后，到豆瓣点一下已看，顺便评分，写上观后感</p>\n<p>豆瓣是文青的精神角落，但是对我来说，它不是一个好方案，因为它：</p>\n<ul>\n<li>不够纯粹：对于我的需求，豆瓣整个页面的元素太过复杂，入口太深</li>\n<li>不够简洁：看完一部电影，先打开浏览器进入豆瓣（或者豆瓣 App），可能需要登录，搜索电影，点击已阅，评分，写点影评，这个流程对于懒人来说是多么可怕</li>\n<li>不够优雅：把自己的数据给别人，终归心里不自在，哪天想拿这些数据做统计或者迁移都是个问题</li>\n</ul>\n<h2 id=\"方案2：Markdown\"><a href=\"#方案2：Markdown\" class=\"headerlink\" title=\"方案2：Markdown\"></a>方案2：Markdown</h2><p>与其寄人篱下，不如自立门户。最简单的方法，用一个 txt 纯文本来记录就行了吗？同时作为程序员我们得更有追求，使用 markdown 格式可以更好更方便地排版</p>\n<p><a href=\"http://norcy.GitHub.io/2013/03/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84/\">点这里可以看下界面效果</a>，对我来说简洁大方即可，因此后续方案的改进也只是改进了记录方法</p>\n<p>但是只有一个文本是不够的，因为没有同步到网上，多设备共享就成了问题    </p>\n<h2 id=\"方案3：Markdown-GitHub-Jekyll\"><a href=\"#方案3：Markdown-GitHub-Jekyll\" class=\"headerlink\" title=\"方案3：Markdown + GitHub + Jekyll\"></a>方案3：Markdown + GitHub + Jekyll</h2><p><a href=\"http://jekyllcn.com/docs/home/\" target=\"_blank\" rel=\"noopener\">Jekyll</a> 是我接触的第一个静态网页生成框架，它与 GitHub Page 的配合使用，使一个博客的搭建变得异常轻松。于是，搭建一个 Jekyll 博客，清单作为博客文章，让 GitHub 托管就成了一个不错的方案。这样就解决了多设备共享的问题</p>\n<h2 id=\"方案4：Markdown-GitHub-Hexo\"><a href=\"#方案4：Markdown-GitHub-Hexo\" class=\"headerlink\" title=\"方案4：Markdown + GitHub + Hexo\"></a>方案4：Markdown + GitHub + Hexo</h2><p>Jekyll 博客只有我这篇清单，而我真正的个人博客是在博客园。<a href=\"http://www.cnblogs.com/chenyg32/p/5195601.html\" target=\"_blank\" rel=\"noopener\">2016 年年初，我开始搭建个人博客</a>，废弃了 Jekyll，使用了更为优雅简洁的 <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a></p>\n<p>电影/书籍清单也顺带迁移到<a href=\"http://norcy.GitHub.io/2013/03/01/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84/\">这里</a></p>\n<p>至此，阅读完一本书，或者看完一部电影，只要在我的电脑上，更新 .md 文件，使用 Hexo 生成好静态网页文件，然后上传到 GitHub</p>\n<h2 id=\"方案5：Markdown-GitHub-Hexo-Travis-CI\"><a href=\"#方案5：Markdown-GitHub-Hexo-Travis-CI\" class=\"headerlink\" title=\"方案5：Markdown + GitHub + Hexo + Travis CI\"></a>方案5：Markdown + GitHub + Hexo + Travis CI</h2><p>2017 年年末，认识了 Travis CI，于是<a href=\"https://www.jianshu.com/p/5e74046e7a0f\" target=\"_blank\" rel=\"noopener\">使用 Travis CI 来简化 Hexo</a></p>\n<p>引入了 Travis CI，更新清单就省略了一个使用 Hexo 生成静态网页的步骤</p>\n<h2 id=\"终极方案：Markdown-GitHub-Hexo-Travis-CI-公众号-腾讯云\"><a href=\"#终极方案：Markdown-GitHub-Hexo-Travis-CI-公众号-腾讯云\" class=\"headerlink\" title=\"终极方案：Markdown + GitHub + Hexo + Travis CI + 公众号 + 腾讯云\"></a>终极方案：Markdown + GitHub + Hexo + Travis CI + 公众号 + 腾讯云</h2><p>以上看似完美的方案，其实实践下来还是挺麻烦的。每次电影院看完电影，还要等回家之后打开电脑，更新博客，这个流程还是不够懒惰。于是我想到了公众号，毕竟移动互联网浪潮下，真正几乎不离身的不是电脑，而是手机</p>\n<p>一个可行的想法是：使用公众号连接自己的服务器，然后利用服务器更新清单文件，上传到 GitHub，剩下的交给 Travis CI 去更新博客。这个想法大概在我脑里徘徊了一年，今日终于克服拖延症得以实现</p>\n<p>最终的效果就是，阅读完一本书，或者看完一部电影，只要打开我的公众号，回复如下格式的命令，一会之后我的博客就自动更新完毕啦</p>\n<blockquote>\n</blockquote>\n<pre><code>add/del name [m/b/s]\n</code></pre><p>其中 add/del 表示增加或删除，必填；name 必填，表示名字；类型选填，m/b/s 表示电影/书籍/连续剧，默认是电影</p>\n<h1 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h1><p>我是专职 iOS 开发，对后台开发的知识处在青铜级别，所以这里记录下服务器端关键代码的实现。如何打通公众号和自己的服务器，以及如何配置服务器在这里就不赘述</p>\n<p>这个项目使用的语言是 php + python，主要涉及以下几个文件：</p>\n<ul>\n<li>index.php：负责与公众号接口对接，对用户发送的消息进行验证解析，并提取电影/书籍名称，以及类型，传递给 blogUpdater.php 处理，并返回博客链接给用户</li>\n<li>blogUpdater.php：负责调用 isee.py，传递名称、类型、年月日等</li>\n<li>ReadList.txt : 轻量级数据库，维护所有阅读数据，数据示例如下，其中 m 表示 movie，b 表示 book</li>\n</ul>\n<blockquote>\n</blockquote>\n<pre><code>2018 04 23 m 起跑线\n2018 02 01 m 唐人街探案2\n2018 02 01 b 活着本来单纯\n2018 01 01 m 神秘巨星\n2018 01 01 m 无问西东\n2018 01 01 m 奇门遁甲\n2017 12 01 m 解忧杂货店\n2017 12 01 b 少有人走的路\n2017 11 01 m 缝纫机乐队\n</code></pre><ul>\n<li>isee.py : 关键文件，主要负责更新 ReadList.txt，并输出 markdown 文件，最后执行 git 操作。其主要逻辑如下</li>\n</ul>\n<blockquote>\n</blockquote>\n<pre><code>1. 按行读取文件 ReadList.txt，每一行的数据包括名字、类型、年月日以及链接，如果是 del 命令则比对名称和类型，如果匹配说明该数据是要删除的，不添加到 list，否则默认添加到 list\n2. 如果是 add 命令则将新数据添加到 list\n3. 对 list 的内容进行去重\n4. 将 list 的内容输出到 tmpReadList.txt，输出结束之后删除 ReadList.txt，重命名其为新的 ReadList.txt\n5. 将 list 的内容输出到 markdown 文件，为了优化可读性，将最近的记录放在前面，排序算法如下：年倒序，月正序（即201801、201802...201701、201702...）\n6. 最后执行 git 操作，上传 markdown 文件\n</code></pre><h1 id=\"踩坑记录\"><a href=\"#踩坑记录\" class=\"headerlink\" title=\"踩坑记录\"></a>踩坑记录</h1><p>以下部分是开发过程中踩到的坑，记录一下以备忘</p>\n<h2 id=\"公众号接口调试\"><a href=\"#公众号接口调试\" class=\"headerlink\" title=\"公众号接口调试\"></a>公众号接口调试</h2><p>可以使用微信公众号的<a href=\"https://mp.weixin.qq.com/debug\" target=\"_blank\" rel=\"noopener\">在线接口调试工具</a>来测试服务器接口是否正常</p>\n<h2 id=\"php-调用-Shell-接口以执行-Python\"><a href=\"#php-调用-Shell-接口以执行-Python\" class=\"headerlink\" title=\"php 调用 Shell 接口以执行 Python\"></a>php 调用 Shell 接口以执行 Python</h2><p>关键代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cmd = <span class=\"string\">\"python3 /var/www/html/Norcy.github.io/isee.py \"</span>.$objectName.<span class=\"string\">\" \"</span>.$type.<span class=\"string\">\" \"</span>.$year.<span class=\"string\">\" \"</span>.$mouth.<span class=\"string\">\" \"</span>.$date.<span class=\"string\">\" &gt;/dev/null  &amp;\"</span>;</span><br><span class=\"line\">shell_exec($cmd);</span><br></pre></td></tr></table></figure>\n<p>注意以下几个点：</p>\n<ol>\n<li>使用 <code>shell_exec</code> 来调用 shell 命令</li>\n<li><code>&amp;</code> 的作用是 python 脚本会在后台执行</li>\n<li><p>如果是调试模式，可以使用 <code>2&gt;&amp;1</code> 和 <code>var_dump</code> 来查看输出</p>\n <figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cmd = <span class=\"string\">\"python3 /var/www/html/Norcy.github.io/isee.py \"</span>.$objectName.<span class=\"string\">\" \"</span>.$type.<span class=\"string\">\" \"</span>.$year.<span class=\"string\">\" \"</span>.$mouth.<span class=\"string\">\" \"</span>.$date.<span class=\"string\">\" 2&gt;&amp;1 &amp;\"</span>;</span><br><span class=\"line\">var_dump(shell_exec($cmd));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>&gt;/dev/null</code> 和 <code>2&gt;&amp;1</code> 是什么呢？</p>\n</li>\n</ol>\n<blockquote>\n</blockquote>\n<pre><code>/dev/null ：代表空设备文件\n&gt;  ：代表重定向到哪里\n0 : 表示 stdin 标准输入\n1 : 表示 stdout 标准输出，系统默认值是1，所以&quot;&gt;/dev/null&quot;等同于&quot;1&gt;/dev/null&quot;\n2 : 表示 stderr 标准错误\n&amp; : 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1\n</code></pre><blockquote>\n</blockquote>\n<pre><code>1 &gt; /dev/null 2&gt;&amp;1 : 标准输出输出到空文件，标准错误也输出到空文件\n</code></pre><blockquote>\n</blockquote>\n<pre><code>cmd &gt;a 2&gt;a 和 cmd &gt;a 2&gt;&amp;1 为什么不同？\ncmd &gt;a 2&gt;a ：stdout 和 stderr 都直接送往文件 a，a文件会被打开两遍，由此导致 stdout 和 stderr 互相覆盖\ncmd &gt;a 2&gt;&amp;1 ：stdout 直接送往文件 a，stderr 是继承了 FD1 的管道之后，再被送往文件 a。a 文件只被打开一遍，就是 FD1 将其打开\n</code></pre><h2 id=\"公众号超时逻辑\"><a href=\"#公众号超时逻辑\" class=\"headerlink\" title=\"公众号超时逻辑\"></a>公众号超时逻辑</h2><p>直接访问 php 执行代码的时候没有任何问题，但是通过公众号访问，返回的数据却是空的，没任何提示。找了许久，最终原因是 php 的处理时间太长，公众号接口超时</p>\n<p>其实主要的耗时操作是 isee.py 的执行，因此只需要在执行 python 的时候，命令后面添加 <code>&amp;</code>，让其后台执行，就可以解决超时逻辑</p>\n<h2 id=\"Python-调用-Shell-以执行-Git\"><a href=\"#Python-调用-Shell-以执行-Git\" class=\"headerlink\" title=\"Python 调用 Shell 以执行 Git\"></a>Python 调用 Shell 以执行 Git</h2><p>由于 blogUpdater.php 和 isee.py 所在的目录不一样，因此这里是一个大坑，执行 Shell 的时候需要先将当前目录切换到 isee.py 所在的目录</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.chdir(sys.path[<span class=\"number\">0</span>]);</span><br><span class=\"line\">os.system(<span class=\"string\">\"/usr/bin/git pull origin HexoBackup\"</span>);</span><br><span class=\"line\">os.system(<span class=\"string\">\"/usr/bin/git add .\"</span>);</span><br><span class=\"line\">os.system(<span class=\"string\">\"/usr/bin/git commit -m 'Update From PublicAccount'\"</span>);</span><br><span class=\"line\">os.system(<span class=\"string\">\"/usr/bin/git push origin HexoBackup\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码中文乱码问题\"><a href=\"#代码中文乱码问题\" class=\"headerlink\" title=\"代码中文乱码问题\"></a>代码中文乱码问题</h2><ul>\n<li>python 文件页首添加 <code>#coding=utf-8</code></li>\n<li>php 文件页首添加</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$locale=&apos;en_US.UTF-8&apos;;  </span><br><span class=\"line\">setlocale(LC_ALL,$locale);  </span><br><span class=\"line\">putenv(&apos;LC_ALL=&apos;.$locale);</span><br></pre></td></tr></table></figure>\n<h2 id=\"终端中文乱码问题\"><a href=\"#终端中文乱码问题\" class=\"headerlink\" title=\"终端中文乱码问题\"></a>终端中文乱码问题</h2><p>直接修改当前用户目录下的 .bashrc 文件，在最后添加如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export LC_ALL=C</span><br><span class=\"line\">export LANG=\"zh_CN.utf8\"</span><br><span class=\"line\">export LC_ALL=\"zh_CN.utf8\"</span><br><span class=\"line\">export LC_CTYPE=\"zh_CN.utf8\"</span><br></pre></td></tr></table></figure>\n<h2 id=\"用户读写权限问题和文件所有者权限问题\"><a href=\"#用户读写权限问题和文件所有者权限问题\" class=\"headerlink\" title=\"用户读写权限问题和文件所有者权限问题\"></a>用户读写权限问题和文件所有者权限问题</h2><p>Apache 运行时用户是 www-data，而不是我 ssh 登录时的 ubuntu 用户，因此会遇到一个又一个的文件权限问题。我的方法是 ssh 登录之后，切到 www-data 用户来执行所有操作，并更改相关的文件权限和所属群组</p>\n<p>相关命令有 <code>sudo -i</code>，<code>su - www-data</code>，<code>chmod -R 777 ./</code>，<code>chown -R www-data:www-data ./</code>，<code>whoami</code></p>\n<h2 id=\"使用-ssh-而不是-https-的方式来配置-GitHub\"><a href=\"#使用-ssh-而不是-https-的方式来配置-GitHub\" class=\"headerlink\" title=\"使用 ssh 而不是 https 的方式来配置 GitHub\"></a>使用 ssh 而不是 https 的方式来配置 GitHub</h2><ol>\n<li>使用 <code>git remote -v</code> or <code>cat .git/config</code> 来查看当前的 git 配置</li>\n<li>编辑 <code>.git/config</code> 文件 或者执行 <code>git remote set-url origin git@github.com:username/username.github.io.git</code> 来更改配置</li>\n<li>其他的按照<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"noopener\">官方文档</a>即可</li>\n</ol>\n<h1 id=\"未来改进\"><a href=\"#未来改进\" class=\"headerlink\" title=\"未来改进\"></a>未来改进</h1><ol>\n<li>json 代替 txt，通用性更高</li>\n<li>抓取豆瓣链接，将每行数据变成一个超链接，方便随时跳转到豆瓣</li>\n<li>抓取豆瓣海报，可以做成海报墙的形式</li>\n<li>对数据进行统计，画出各种统计图</li>\n</ol>\n<blockquote>\n<p>至此，虽然是简简单单的功能，但是，it makes my world better.</p>\n</blockquote>\n"},{"title":"如何用iPad在床上优雅的看大片","date":"2016-08-03T16:00:00.000Z","photos":["images/girl.jpg"],"keywords":"iPad;局域网;视频","_content":"\n# 背景\n家里躺床上的想用 iPad 看电影，普通人会怎么做？\n\n+ 在线观看。那么网络卡怎么办？在线视频网站或 app 没有你要的视频怎么办？\n+ 直接下载到 iPad？iPad 内存不够用，看一部删一部？\n+ 下载到 PC，再从 PC 导入到 iPad。导入过程很蛋疼怎么办？\n\n我是多么愚蠢，现在才意识到要解决这个问题，第一反应当然是利用局域网共享，于是找到以下方法\n\n# 方法\n相比普通人的普通方法，更优雅的解决方法是，视频提前下载到 PC 上，然后保证 iPad 和 PC 处于同一局域网，这样就能利用局域网来共享视频，不影响其他人的网速！\n\n原理是利用 DLNA 解决，PC 部署成服务器，iPad 来访问\n\n啊，DLNA 是什么？你不用管，我也不知道，专注问题本身，学会利用工具就行了\n\n# 工具\n硬件：\n\n+ 首先你要有一台 iPad，当然其他支持 DLNA 的设备也行\n+ 一台 PC，Mac 或 Windows 都行\n+ 一个路由\n\n软件：\n\n+ Twonky Server\n+ nPlayer\n\n## Twonky Server\n+ PC 上安装 Twonky Server\n+ 打开配置页面，指定共享文件夹\n+ 设置开机运行\n\n## nPlayer\n+ iPad 上安装 nPlayer\n+ AppStore 有免费版本，但是底部有广告，不过功能是齐全的\n+ 下载后扫描网络即可发现 PC 上的服务器\n\n# 效果\n成功播放，非常流畅，与播放本地视频无异，支持滑动快进快退，嘿嘿嘿，你懂的，就是时不时蹦出个小广告，挺烦的\n\n# 注意点\n最后记得，手动配置电脑的 IP 地址，以防止 IP 地址更改时客户端链接失效\n\n从萌生想法，查阅资料，解决问题，到写下这篇博客，前前后后花了不到2个小时，但却为我以后省下了很多很多的时间。这个问题很难解决吗？不难，能不能发现问题才是关键\n\n所以，多留心，看看生活中有什么让你不爽的地方，想办法，解决它。这是一种生活态度，也是一种学习态度。正如之前的文章[《手机控制电脑定时关机，重启WiFi》](http://www.cnblogs.com/chenyg32/p/4391727.html)和[《房间WIFI信号不好怎么办？——无线路由桥接（WDS）》](http://www.cnblogs.com/chenyg32/p/4782645.html)说的一样：\n\n> 至此，虽然是简简单单的功能，但是，it makes my world better.\n\n# 参考文章\n[iPad 直接播放 PC / Mac端或移动硬盘内的视频，目前最好的解决方案是？](https://www.zhihu.com/question/20581392)\n","source":"_posts/如何用iPad在床上优雅的看大片.md","raw":"---\ntitle: 如何用iPad在床上优雅的看大片\ndate: 2016-08-04\ncategories:\n- 技术改变生活\nphotos: images/girl.jpg\nkeywords: iPad;局域网;视频\n---\n\n# 背景\n家里躺床上的想用 iPad 看电影，普通人会怎么做？\n\n+ 在线观看。那么网络卡怎么办？在线视频网站或 app 没有你要的视频怎么办？\n+ 直接下载到 iPad？iPad 内存不够用，看一部删一部？\n+ 下载到 PC，再从 PC 导入到 iPad。导入过程很蛋疼怎么办？\n\n我是多么愚蠢，现在才意识到要解决这个问题，第一反应当然是利用局域网共享，于是找到以下方法\n\n# 方法\n相比普通人的普通方法，更优雅的解决方法是，视频提前下载到 PC 上，然后保证 iPad 和 PC 处于同一局域网，这样就能利用局域网来共享视频，不影响其他人的网速！\n\n原理是利用 DLNA 解决，PC 部署成服务器，iPad 来访问\n\n啊，DLNA 是什么？你不用管，我也不知道，专注问题本身，学会利用工具就行了\n\n# 工具\n硬件：\n\n+ 首先你要有一台 iPad，当然其他支持 DLNA 的设备也行\n+ 一台 PC，Mac 或 Windows 都行\n+ 一个路由\n\n软件：\n\n+ Twonky Server\n+ nPlayer\n\n## Twonky Server\n+ PC 上安装 Twonky Server\n+ 打开配置页面，指定共享文件夹\n+ 设置开机运行\n\n## nPlayer\n+ iPad 上安装 nPlayer\n+ AppStore 有免费版本，但是底部有广告，不过功能是齐全的\n+ 下载后扫描网络即可发现 PC 上的服务器\n\n# 效果\n成功播放，非常流畅，与播放本地视频无异，支持滑动快进快退，嘿嘿嘿，你懂的，就是时不时蹦出个小广告，挺烦的\n\n# 注意点\n最后记得，手动配置电脑的 IP 地址，以防止 IP 地址更改时客户端链接失效\n\n从萌生想法，查阅资料，解决问题，到写下这篇博客，前前后后花了不到2个小时，但却为我以后省下了很多很多的时间。这个问题很难解决吗？不难，能不能发现问题才是关键\n\n所以，多留心，看看生活中有什么让你不爽的地方，想办法，解决它。这是一种生活态度，也是一种学习态度。正如之前的文章[《手机控制电脑定时关机，重启WiFi》](http://www.cnblogs.com/chenyg32/p/4391727.html)和[《房间WIFI信号不好怎么办？——无线路由桥接（WDS）》](http://www.cnblogs.com/chenyg32/p/4782645.html)说的一样：\n\n> 至此，虽然是简简单单的功能，但是，it makes my world better.\n\n# 参考文章\n[iPad 直接播放 PC / Mac端或移动硬盘内的视频，目前最好的解决方案是？](https://www.zhihu.com/question/20581392)\n","slug":"如何用iPad在床上优雅的看大片","published":1,"updated":"2018-11-02T02:22:31.000Z","comments":1,"layout":"post","link":"","_id":"cjp2opl3j000su3qwy4q02ctg","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>家里躺床上的想用 iPad 看电影，普通人会怎么做？</p>\n<ul>\n<li>在线观看。那么网络卡怎么办？在线视频网站或 app 没有你要的视频怎么办？</li>\n<li>直接下载到 iPad？iPad 内存不够用，看一部删一部？</li>\n<li>下载到 PC，再从 PC 导入到 iPad。导入过程很蛋疼怎么办？</li>\n</ul>\n<p>我是多么愚蠢，现在才意识到要解决这个问题，第一反应当然是利用局域网共享，于是找到以下方法</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>相比普通人的普通方法，更优雅的解决方法是，视频提前下载到 PC 上，然后保证 iPad 和 PC 处于同一局域网，这样就能利用局域网来共享视频，不影响其他人的网速！</p>\n<p>原理是利用 DLNA 解决，PC 部署成服务器，iPad 来访问</p>\n<p>啊，DLNA 是什么？你不用管，我也不知道，专注问题本身，学会利用工具就行了</p>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><p>硬件：</p>\n<ul>\n<li>首先你要有一台 iPad，当然其他支持 DLNA 的设备也行</li>\n<li>一台 PC，Mac 或 Windows 都行</li>\n<li>一个路由</li>\n</ul>\n<p>软件：</p>\n<ul>\n<li>Twonky Server</li>\n<li>nPlayer</li>\n</ul>\n<h2 id=\"Twonky-Server\"><a href=\"#Twonky-Server\" class=\"headerlink\" title=\"Twonky Server\"></a>Twonky Server</h2><ul>\n<li>PC 上安装 Twonky Server</li>\n<li>打开配置页面，指定共享文件夹</li>\n<li>设置开机运行</li>\n</ul>\n<h2 id=\"nPlayer\"><a href=\"#nPlayer\" class=\"headerlink\" title=\"nPlayer\"></a>nPlayer</h2><ul>\n<li>iPad 上安装 nPlayer</li>\n<li>AppStore 有免费版本，但是底部有广告，不过功能是齐全的</li>\n<li>下载后扫描网络即可发现 PC 上的服务器</li>\n</ul>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>成功播放，非常流畅，与播放本地视频无异，支持滑动快进快退，嘿嘿嘿，你懂的，就是时不时蹦出个小广告，挺烦的</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>最后记得，手动配置电脑的 IP 地址，以防止 IP 地址更改时客户端链接失效</p>\n<p>从萌生想法，查阅资料，解决问题，到写下这篇博客，前前后后花了不到2个小时，但却为我以后省下了很多很多的时间。这个问题很难解决吗？不难，能不能发现问题才是关键</p>\n<p>所以，多留心，看看生活中有什么让你不爽的地方，想办法，解决它。这是一种生活态度，也是一种学习态度。正如之前的文章<a href=\"http://www.cnblogs.com/chenyg32/p/4391727.html\" target=\"_blank\" rel=\"noopener\">《手机控制电脑定时关机，重启WiFi》</a>和<a href=\"http://www.cnblogs.com/chenyg32/p/4782645.html\" target=\"_blank\" rel=\"noopener\">《房间WIFI信号不好怎么办？——无线路由桥接（WDS）》</a>说的一样：</p>\n<blockquote>\n<p>至此，虽然是简简单单的功能，但是，it makes my world better.</p>\n</blockquote>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p><a href=\"https://www.zhihu.com/question/20581392\" target=\"_blank\" rel=\"noopener\">iPad 直接播放 PC / Mac端或移动硬盘内的视频，目前最好的解决方案是？</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>家里躺床上的想用 iPad 看电影，普通人会怎么做？</p>\n<ul>\n<li>在线观看。那么网络卡怎么办？在线视频网站或 app 没有你要的视频怎么办？</li>\n<li>直接下载到 iPad？iPad 内存不够用，看一部删一部？</li>\n<li>下载到 PC，再从 PC 导入到 iPad。导入过程很蛋疼怎么办？</li>\n</ul>\n<p>我是多么愚蠢，现在才意识到要解决这个问题，第一反应当然是利用局域网共享，于是找到以下方法</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>相比普通人的普通方法，更优雅的解决方法是，视频提前下载到 PC 上，然后保证 iPad 和 PC 处于同一局域网，这样就能利用局域网来共享视频，不影响其他人的网速！</p>\n<p>原理是利用 DLNA 解决，PC 部署成服务器，iPad 来访问</p>\n<p>啊，DLNA 是什么？你不用管，我也不知道，专注问题本身，学会利用工具就行了</p>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><p>硬件：</p>\n<ul>\n<li>首先你要有一台 iPad，当然其他支持 DLNA 的设备也行</li>\n<li>一台 PC，Mac 或 Windows 都行</li>\n<li>一个路由</li>\n</ul>\n<p>软件：</p>\n<ul>\n<li>Twonky Server</li>\n<li>nPlayer</li>\n</ul>\n<h2 id=\"Twonky-Server\"><a href=\"#Twonky-Server\" class=\"headerlink\" title=\"Twonky Server\"></a>Twonky Server</h2><ul>\n<li>PC 上安装 Twonky Server</li>\n<li>打开配置页面，指定共享文件夹</li>\n<li>设置开机运行</li>\n</ul>\n<h2 id=\"nPlayer\"><a href=\"#nPlayer\" class=\"headerlink\" title=\"nPlayer\"></a>nPlayer</h2><ul>\n<li>iPad 上安装 nPlayer</li>\n<li>AppStore 有免费版本，但是底部有广告，不过功能是齐全的</li>\n<li>下载后扫描网络即可发现 PC 上的服务器</li>\n</ul>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>成功播放，非常流畅，与播放本地视频无异，支持滑动快进快退，嘿嘿嘿，你懂的，就是时不时蹦出个小广告，挺烦的</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>最后记得，手动配置电脑的 IP 地址，以防止 IP 地址更改时客户端链接失效</p>\n<p>从萌生想法，查阅资料，解决问题，到写下这篇博客，前前后后花了不到2个小时，但却为我以后省下了很多很多的时间。这个问题很难解决吗？不难，能不能发现问题才是关键</p>\n<p>所以，多留心，看看生活中有什么让你不爽的地方，想办法，解决它。这是一种生活态度，也是一种学习态度。正如之前的文章<a href=\"http://www.cnblogs.com/chenyg32/p/4391727.html\" target=\"_blank\" rel=\"noopener\">《手机控制电脑定时关机，重启WiFi》</a>和<a href=\"http://www.cnblogs.com/chenyg32/p/4782645.html\" target=\"_blank\" rel=\"noopener\">《房间WIFI信号不好怎么办？——无线路由桥接（WDS）》</a>说的一样：</p>\n<blockquote>\n<p>至此，虽然是简简单单的功能，但是，it makes my world better.</p>\n</blockquote>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p><a href=\"https://www.zhihu.com/question/20581392\" target=\"_blank\" rel=\"noopener\">iPad 直接播放 PC / Mac端或移动硬盘内的视频，目前最好的解决方案是？</a></p>\n"},{"title":"神在细节之中","date":"2016-07-24T16:00:00.000Z","photos":["images/view.jpg"],"keywords":"代码整洁之道;","_content":"\n# 碎碎念\n这其实是《代码整洁之道》的学习笔记，起了一个看起来很厉害的名字。\n\n之前读过《如何阅读一本书》，但是读完之后还是没什么收获，只懂读，不懂消化。前几天看了这篇文章[《一年读100本书的技能，你1分钟就能学得会》](http://www.jianshu.com/p/b780ba99abd6)，有恍然大悟状。怪不得我一直读书很慢，很少，读了一点就不想读，原来我是一直用的学生考试时代的`基础阅读`，这种是最低级的阅读方式，一个字一个字读，漫无目的地读。现在我改用了`检视阅读`和`分析阅读`，不求甚解，跳过了一些无用章节，比如 Java 相关的，测试相关的，所以一个下午就把大半本书给啃下来了，效率十分高。另外，书的配图很棒\n\n我只挑自己仍需注意的点记录下来，并结合自己的经验谈谈。而一些最基本的，SRP、DRY 等是老生常谈的问题，就不赘述。特别是 DRY，懂的人很多，敲代码的时候能想到的人就少了，想到并且做好的人就更少。工程里面经常看到这段代码复制过来，那段代码复制过去，是最恶心的。这个原则值得用一生去践行、体会并提高\n\n# 前言\n> 阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。\n\n我是第二种。希望有一天，我写的代码，能成为一种艺术\n\n> 衡量代码质量的唯一有效标准： WTF/min\n\n![](http://images.cnitblog.com/blog/435441/201301/29202423-4786f70c83254e0f88aa1c31110e1bd5.jpg)\n\n《代码整洁之道》最有道理的一句话，即代码阅读者每一分钟爆出的\"What The Fuck\"数量，哈哈哈\n\n# 使用可搜索的名称\n> 名称长短应与其作用域大小相对应\n\n比如，在一个简单的 for 循环里，使用简单的 i 来命名下标就很足够了；而如果一个变量的作用域很大，那么其命名应该易于搜索（名称长是为了易于搜索）\n\n# 不要写多余的注释，别让你写的注释比看代码还累\n> 与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那段糟糕的代码\n\n确实，这点我做得不够，有时候为函数的声明写的注释太多，需要改进\n\n# 如果可以，尽量别注释代码\n> 其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除\n\n一方面，我看到注释掉的代码真的很讨厌，因为我是极简主义，能少写一行代码甚至一个空格就少写，一坨被注释的代码放在那里会影响阅读体验\n\n但是另一方面我又不完全同意这个观点，作者说现在已经有版本管理，所以没必要保留注释的代码，但是谁修改代码的时候没事会去查看之前的版本呢？比如，上次我想为频道列表页添加缓存逻辑，但是发现之前有人加过了，但是被注释了，询问之后才发现直接为这个页面添加缓存是有坑的，于是这次添加缓存就顺利绕过了这个坑。那么如果没有这段注释的代码，我可能就会直接跳进这个坑了，因为我修改之前并不可能漫无目的去查看 SVN\n\n# 不要刻意去水平对齐\n刻意的水平像是在强调不重要的东西，分散读者注意力\n\n```objc\n@property (nonatomic, assign) int                   leftNum;\n@property (nonatomic, copy)   NSString              *dataKey;\n@property (nonatomic, retain) QLJCEShareItem        *shareItem;\n@property (nonatomic, retain) QLJCEONAPosterTitle   *tips;\n```\n\n下面这段代码更好，因为注意力能更集中在变量的类型上\n\n```objc\n@property (nonatomic, assign) int leftNum;\n@property (nonatomic, copy) NSString *dataKey;\n@property (nonatomic, retain) QLJCEShareItem *shareItem;\n@property (nonatomic, retain) QLJCEONAPosterTitle *tips;\n```\n\n# 要编写简洁的代码，必须先写肮脏的代码，然后再清理它\n问题是写完了肮脏的可运行的代码之后，别着急开始下一个任务而忘记改进它\n\n# 使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\n先看一个例子\n\n```objc\n- (void)pay:(BOOL)isVip\n{\n    // 通用代码\n\n    if (isVip)\n    {\n        // VIP处理代码\n    }\n    else\n    {\n        // 普通成员处理代码\n    }\n}\n```\n首先作者认为这种代码不好，因为调用的时候应该去记住传递的 BOOL 代表什么意思，应该改为以下这种\n\n```objc\n- (void)pay\n{\n    // 通用代码\n\n    if ([self isVip])\n    {\n        // Vip处理代码\n    }\n    else\n    {\n        // 普通成员处理代码\n    }\n}\n```\n或这种\n\n```objc\n- (void)vipPay\n{\n    // 通用代码\n\n    // VIP处理代码\n}\n\n- (void)commonPay\n{\n    // 通用代码\n\n    // 普通成员处理代码\n}\n```\n首先方法1并不是处处可行，因为对于 Vip 的判断是否合适放在本类要根据具体情况讨论，合适则方法1可行\n\n而方法2我不敢苟同，因为这首先违背了一种重要的原则——DRY，通用代码在2处地方重复，维护起来十分恶心\n\n同时，在 IDE 日益强大的今天，多写一个参数并不对程序员的记忆有所挑战，即使有，也比重复代码好\n\n# 代码要尽可能具有表达力\n\n```objc\nif (curTime >= startTime && curTime <= endTime && !hasShown)    // 是否应该展示\n{\n\n}\n```\n应该处理为下面这种，这比写注释好\n\n```objc\n- (BOOL)shouldShow\n{\n    return (curTime >= startTime && curTime <= endTime && !hasShown);\n}\n\nif ([self shouldShow])\n{\n\n}\n```\n\n# 得墨忒耳定律（最少了解原理）\nA 有一个属性叫 B，B 有一个属性叫 C，C 有一个 doSomething 的函数。现在需要在 A 里面调用 C 的函数。有以下2种写法\n\n方法1，B 把属性 C 暴露在头文件，让 A 可以直接读取\n\n```objc\n// A.m\n[self.b.c doSomething];\n\n// B.h\n@property (nonatomic, strong) C *c;\n\n// C.h\n- (void)doSomething;\n\n// C.m\n- (void)doSomething\n{\n    NSLog(@\"Hello World!\");\n}\n```\n\n方法2，B 把 C 中的函数封装成接口提供给外部使用\n\n```objc\n// A.m\n[self.b doSomething];\n\n// B.h\n- (void)doSomething;\n\n// B.m\n- (void)doSomething\n{\n    [self.c doSomething];\n}\n\n// C.h\n- (void)doSomething;\n\n// C.m\n- (void)doSomething\n{\n    NSLog(@\"Hello World!\");\n}\n```\n\n曾经，我不知道方法1和方法2孰优孰劣，甚至更倾向于方法1，因为代码量更少，但读了这本书后，我明白了，方法2更好，为什么？\n\n+ 方法1违背了`得墨忒耳定律`，C 不是 A 的属性，而 A 居然要去了解 C 里面的函数\n+ 假如不止A，还有A1,A2,A3...直接调用了 C 的函数，那么有一天，当 C 修改 doSomething 这个函数名，或者想在 B 和 C 之间再添加一个类 D 的时候，此时方法1就需要修改很多地方，而方法2只需要修改 B 文件","source":"_posts/神在细节之中.md","raw":"---\ntitle: 神在细节之中\ndate: 2016-07-25\ncategories:\n- 读书笔记\nphotos: images/view.jpg\nkeywords: 代码整洁之道;\n---\n\n# 碎碎念\n这其实是《代码整洁之道》的学习笔记，起了一个看起来很厉害的名字。\n\n之前读过《如何阅读一本书》，但是读完之后还是没什么收获，只懂读，不懂消化。前几天看了这篇文章[《一年读100本书的技能，你1分钟就能学得会》](http://www.jianshu.com/p/b780ba99abd6)，有恍然大悟状。怪不得我一直读书很慢，很少，读了一点就不想读，原来我是一直用的学生考试时代的`基础阅读`，这种是最低级的阅读方式，一个字一个字读，漫无目的地读。现在我改用了`检视阅读`和`分析阅读`，不求甚解，跳过了一些无用章节，比如 Java 相关的，测试相关的，所以一个下午就把大半本书给啃下来了，效率十分高。另外，书的配图很棒\n\n我只挑自己仍需注意的点记录下来，并结合自己的经验谈谈。而一些最基本的，SRP、DRY 等是老生常谈的问题，就不赘述。特别是 DRY，懂的人很多，敲代码的时候能想到的人就少了，想到并且做好的人就更少。工程里面经常看到这段代码复制过来，那段代码复制过去，是最恶心的。这个原则值得用一生去践行、体会并提高\n\n# 前言\n> 阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。\n\n我是第二种。希望有一天，我写的代码，能成为一种艺术\n\n> 衡量代码质量的唯一有效标准： WTF/min\n\n![](http://images.cnitblog.com/blog/435441/201301/29202423-4786f70c83254e0f88aa1c31110e1bd5.jpg)\n\n《代码整洁之道》最有道理的一句话，即代码阅读者每一分钟爆出的\"What The Fuck\"数量，哈哈哈\n\n# 使用可搜索的名称\n> 名称长短应与其作用域大小相对应\n\n比如，在一个简单的 for 循环里，使用简单的 i 来命名下标就很足够了；而如果一个变量的作用域很大，那么其命名应该易于搜索（名称长是为了易于搜索）\n\n# 不要写多余的注释，别让你写的注释比看代码还累\n> 与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那段糟糕的代码\n\n确实，这点我做得不够，有时候为函数的声明写的注释太多，需要改进\n\n# 如果可以，尽量别注释代码\n> 其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除\n\n一方面，我看到注释掉的代码真的很讨厌，因为我是极简主义，能少写一行代码甚至一个空格就少写，一坨被注释的代码放在那里会影响阅读体验\n\n但是另一方面我又不完全同意这个观点，作者说现在已经有版本管理，所以没必要保留注释的代码，但是谁修改代码的时候没事会去查看之前的版本呢？比如，上次我想为频道列表页添加缓存逻辑，但是发现之前有人加过了，但是被注释了，询问之后才发现直接为这个页面添加缓存是有坑的，于是这次添加缓存就顺利绕过了这个坑。那么如果没有这段注释的代码，我可能就会直接跳进这个坑了，因为我修改之前并不可能漫无目的去查看 SVN\n\n# 不要刻意去水平对齐\n刻意的水平像是在强调不重要的东西，分散读者注意力\n\n```objc\n@property (nonatomic, assign) int                   leftNum;\n@property (nonatomic, copy)   NSString              *dataKey;\n@property (nonatomic, retain) QLJCEShareItem        *shareItem;\n@property (nonatomic, retain) QLJCEONAPosterTitle   *tips;\n```\n\n下面这段代码更好，因为注意力能更集中在变量的类型上\n\n```objc\n@property (nonatomic, assign) int leftNum;\n@property (nonatomic, copy) NSString *dataKey;\n@property (nonatomic, retain) QLJCEShareItem *shareItem;\n@property (nonatomic, retain) QLJCEONAPosterTitle *tips;\n```\n\n# 要编写简洁的代码，必须先写肮脏的代码，然后再清理它\n问题是写完了肮脏的可运行的代码之后，别着急开始下一个任务而忘记改进它\n\n# 使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\n先看一个例子\n\n```objc\n- (void)pay:(BOOL)isVip\n{\n    // 通用代码\n\n    if (isVip)\n    {\n        // VIP处理代码\n    }\n    else\n    {\n        // 普通成员处理代码\n    }\n}\n```\n首先作者认为这种代码不好，因为调用的时候应该去记住传递的 BOOL 代表什么意思，应该改为以下这种\n\n```objc\n- (void)pay\n{\n    // 通用代码\n\n    if ([self isVip])\n    {\n        // Vip处理代码\n    }\n    else\n    {\n        // 普通成员处理代码\n    }\n}\n```\n或这种\n\n```objc\n- (void)vipPay\n{\n    // 通用代码\n\n    // VIP处理代码\n}\n\n- (void)commonPay\n{\n    // 通用代码\n\n    // 普通成员处理代码\n}\n```\n首先方法1并不是处处可行，因为对于 Vip 的判断是否合适放在本类要根据具体情况讨论，合适则方法1可行\n\n而方法2我不敢苟同，因为这首先违背了一种重要的原则——DRY，通用代码在2处地方重复，维护起来十分恶心\n\n同时，在 IDE 日益强大的今天，多写一个参数并不对程序员的记忆有所挑战，即使有，也比重复代码好\n\n# 代码要尽可能具有表达力\n\n```objc\nif (curTime >= startTime && curTime <= endTime && !hasShown)    // 是否应该展示\n{\n\n}\n```\n应该处理为下面这种，这比写注释好\n\n```objc\n- (BOOL)shouldShow\n{\n    return (curTime >= startTime && curTime <= endTime && !hasShown);\n}\n\nif ([self shouldShow])\n{\n\n}\n```\n\n# 得墨忒耳定律（最少了解原理）\nA 有一个属性叫 B，B 有一个属性叫 C，C 有一个 doSomething 的函数。现在需要在 A 里面调用 C 的函数。有以下2种写法\n\n方法1，B 把属性 C 暴露在头文件，让 A 可以直接读取\n\n```objc\n// A.m\n[self.b.c doSomething];\n\n// B.h\n@property (nonatomic, strong) C *c;\n\n// C.h\n- (void)doSomething;\n\n// C.m\n- (void)doSomething\n{\n    NSLog(@\"Hello World!\");\n}\n```\n\n方法2，B 把 C 中的函数封装成接口提供给外部使用\n\n```objc\n// A.m\n[self.b doSomething];\n\n// B.h\n- (void)doSomething;\n\n// B.m\n- (void)doSomething\n{\n    [self.c doSomething];\n}\n\n// C.h\n- (void)doSomething;\n\n// C.m\n- (void)doSomething\n{\n    NSLog(@\"Hello World!\");\n}\n```\n\n曾经，我不知道方法1和方法2孰优孰劣，甚至更倾向于方法1，因为代码量更少，但读了这本书后，我明白了，方法2更好，为什么？\n\n+ 方法1违背了`得墨忒耳定律`，C 不是 A 的属性，而 A 居然要去了解 C 里面的函数\n+ 假如不止A，还有A1,A2,A3...直接调用了 C 的函数，那么有一天，当 C 修改 doSomething 这个函数名，或者想在 B 和 C 之间再添加一个类 D 的时候，此时方法1就需要修改很多地方，而方法2只需要修改 B 文件","slug":"神在细节之中","published":1,"updated":"2018-11-02T02:22:31.000Z","comments":1,"layout":"post","link":"","_id":"cjp2opl3k000uu3qwelimv166","content":"<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>这其实是《代码整洁之道》的学习笔记，起了一个看起来很厉害的名字。</p>\n<p>之前读过《如何阅读一本书》，但是读完之后还是没什么收获，只懂读，不懂消化。前几天看了这篇文章<a href=\"http://www.jianshu.com/p/b780ba99abd6\" target=\"_blank\" rel=\"noopener\">《一年读100本书的技能，你1分钟就能学得会》</a>，有恍然大悟状。怪不得我一直读书很慢，很少，读了一点就不想读，原来我是一直用的学生考试时代的<code>基础阅读</code>，这种是最低级的阅读方式，一个字一个字读，漫无目的地读。现在我改用了<code>检视阅读</code>和<code>分析阅读</code>，不求甚解，跳过了一些无用章节，比如 Java 相关的，测试相关的，所以一个下午就把大半本书给啃下来了，效率十分高。另外，书的配图很棒</p>\n<p>我只挑自己仍需注意的点记录下来，并结合自己的经验谈谈。而一些最基本的，SRP、DRY 等是老生常谈的问题，就不赘述。特别是 DRY，懂的人很多，敲代码的时候能想到的人就少了，想到并且做好的人就更少。工程里面经常看到这段代码复制过来，那段代码复制过去，是最恶心的。这个原则值得用一生去践行、体会并提高</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。</p>\n</blockquote>\n<p>我是第二种。希望有一天，我写的代码，能成为一种艺术</p>\n<blockquote>\n<p>衡量代码质量的唯一有效标准： WTF/min</p>\n</blockquote>\n<p><img src=\"http://images.cnitblog.com/blog/435441/201301/29202423-4786f70c83254e0f88aa1c31110e1bd5.jpg\" alt=\"\"></p>\n<p>《代码整洁之道》最有道理的一句话，即代码阅读者每一分钟爆出的”What The Fuck”数量，哈哈哈</p>\n<h1 id=\"使用可搜索的名称\"><a href=\"#使用可搜索的名称\" class=\"headerlink\" title=\"使用可搜索的名称\"></a>使用可搜索的名称</h1><blockquote>\n<p>名称长短应与其作用域大小相对应</p>\n</blockquote>\n<p>比如，在一个简单的 for 循环里，使用简单的 i 来命名下标就很足够了；而如果一个变量的作用域很大，那么其命名应该易于搜索（名称长是为了易于搜索）</p>\n<h1 id=\"不要写多余的注释，别让你写的注释比看代码还累\"><a href=\"#不要写多余的注释，别让你写的注释比看代码还累\" class=\"headerlink\" title=\"不要写多余的注释，别让你写的注释比看代码还累\"></a>不要写多余的注释，别让你写的注释比看代码还累</h1><blockquote>\n<p>与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那段糟糕的代码</p>\n</blockquote>\n<p>确实，这点我做得不够，有时候为函数的声明写的注释太多，需要改进</p>\n<h1 id=\"如果可以，尽量别注释代码\"><a href=\"#如果可以，尽量别注释代码\" class=\"headerlink\" title=\"如果可以，尽量别注释代码\"></a>如果可以，尽量别注释代码</h1><blockquote>\n<p>其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除</p>\n</blockquote>\n<p>一方面，我看到注释掉的代码真的很讨厌，因为我是极简主义，能少写一行代码甚至一个空格就少写，一坨被注释的代码放在那里会影响阅读体验</p>\n<p>但是另一方面我又不完全同意这个观点，作者说现在已经有版本管理，所以没必要保留注释的代码，但是谁修改代码的时候没事会去查看之前的版本呢？比如，上次我想为频道列表页添加缓存逻辑，但是发现之前有人加过了，但是被注释了，询问之后才发现直接为这个页面添加缓存是有坑的，于是这次添加缓存就顺利绕过了这个坑。那么如果没有这段注释的代码，我可能就会直接跳进这个坑了，因为我修改之前并不可能漫无目的去查看 SVN</p>\n<h1 id=\"不要刻意去水平对齐\"><a href=\"#不要刻意去水平对齐\" class=\"headerlink\" title=\"不要刻意去水平对齐\"></a>不要刻意去水平对齐</h1><p>刻意的水平像是在强调不重要的东西，分散读者注意力</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span>                   leftNum;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>)   <span class=\"built_in\">NSString</span>              *dataKey;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEShareItem        *shareItem;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEONAPosterTitle   *tips;</span><br></pre></td></tr></table></figure>\n<p>下面这段代码更好，因为注意力能更集中在变量的类型上</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span> leftNum;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *dataKey;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEShareItem *shareItem;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEONAPosterTitle *tips;</span><br></pre></td></tr></table></figure>\n<h1 id=\"要编写简洁的代码，必须先写肮脏的代码，然后再清理它\"><a href=\"#要编写简洁的代码，必须先写肮脏的代码，然后再清理它\" class=\"headerlink\" title=\"要编写简洁的代码，必须先写肮脏的代码，然后再清理它\"></a>要编写简洁的代码，必须先写肮脏的代码，然后再清理它</h1><p>问题是写完了肮脏的可运行的代码之后，别着急开始下一个任务而忘记改进它</p>\n<h1 id=\"使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\"><a href=\"#使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\" class=\"headerlink\" title=\"使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\"></a>使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</h1><p>先看一个例子</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pay:(<span class=\"built_in\">BOOL</span>)isVip</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isVip)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// VIP处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先作者认为这种代码不好，因为调用的时候应该去记住传递的 BOOL 代表什么意思，应该改为以下这种</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isVip])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Vip处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或这种</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)vipPay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// VIP处理代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)commonPay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先方法1并不是处处可行，因为对于 Vip 的判断是否合适放在本类要根据具体情况讨论，合适则方法1可行</p>\n<p>而方法2我不敢苟同，因为这首先违背了一种重要的原则——DRY，通用代码在2处地方重复，维护起来十分恶心</p>\n<p>同时，在 IDE 日益强大的今天，多写一个参数并不对程序员的记忆有所挑战，即使有，也比重复代码好</p>\n<h1 id=\"代码要尽可能具有表达力\"><a href=\"#代码要尽可能具有表达力\" class=\"headerlink\" title=\"代码要尽可能具有表达力\"></a>代码要尽可能具有表达力</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (curTime &gt;= startTime &amp;&amp; curTime &lt;= endTime &amp;&amp; !hasShown)    <span class=\"comment\">// 是否应该展示</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>应该处理为下面这种，这比写注释好</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)shouldShow</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (curTime &gt;= startTime &amp;&amp; curTime &lt;= endTime &amp;&amp; !hasShown);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> shouldShow])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"得墨忒耳定律（最少了解原理）\"><a href=\"#得墨忒耳定律（最少了解原理）\" class=\"headerlink\" title=\"得墨忒耳定律（最少了解原理）\"></a>得墨忒耳定律（最少了解原理）</h1><p>A 有一个属性叫 B，B 有一个属性叫 C，C 有一个 doSomething 的函数。现在需要在 A 里面调用 C 的函数。有以下2种写法</p>\n<p>方法1，B 把属性 C 暴露在头文件，让 A 可以直接读取</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.m</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.b.c doSomething];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) C *c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello World!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法2，B 把 C 中的函数封装成接口提供给外部使用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.m</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.b doSomething];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.c doSomething];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello World!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>曾经，我不知道方法1和方法2孰优孰劣，甚至更倾向于方法1，因为代码量更少，但读了这本书后，我明白了，方法2更好，为什么？</p>\n<ul>\n<li>方法1违背了<code>得墨忒耳定律</code>，C 不是 A 的属性，而 A 居然要去了解 C 里面的函数</li>\n<li>假如不止A，还有A1,A2,A3…直接调用了 C 的函数，那么有一天，当 C 修改 doSomething 这个函数名，或者想在 B 和 C 之间再添加一个类 D 的时候，此时方法1就需要修改很多地方，而方法2只需要修改 B 文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>这其实是《代码整洁之道》的学习笔记，起了一个看起来很厉害的名字。</p>\n<p>之前读过《如何阅读一本书》，但是读完之后还是没什么收获，只懂读，不懂消化。前几天看了这篇文章<a href=\"http://www.jianshu.com/p/b780ba99abd6\" target=\"_blank\" rel=\"noopener\">《一年读100本书的技能，你1分钟就能学得会》</a>，有恍然大悟状。怪不得我一直读书很慢，很少，读了一点就不想读，原来我是一直用的学生考试时代的<code>基础阅读</code>，这种是最低级的阅读方式，一个字一个字读，漫无目的地读。现在我改用了<code>检视阅读</code>和<code>分析阅读</code>，不求甚解，跳过了一些无用章节，比如 Java 相关的，测试相关的，所以一个下午就把大半本书给啃下来了，效率十分高。另外，书的配图很棒</p>\n<p>我只挑自己仍需注意的点记录下来，并结合自己的经验谈谈。而一些最基本的，SRP、DRY 等是老生常谈的问题，就不赘述。特别是 DRY，懂的人很多，敲代码的时候能想到的人就少了，想到并且做好的人就更少。工程里面经常看到这段代码复制过来，那段代码复制过去，是最恶心的。这个原则值得用一生去践行、体会并提高</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。</p>\n</blockquote>\n<p>我是第二种。希望有一天，我写的代码，能成为一种艺术</p>\n<blockquote>\n<p>衡量代码质量的唯一有效标准： WTF/min</p>\n</blockquote>\n<p><img src=\"http://images.cnitblog.com/blog/435441/201301/29202423-4786f70c83254e0f88aa1c31110e1bd5.jpg\" alt=\"\"></p>\n<p>《代码整洁之道》最有道理的一句话，即代码阅读者每一分钟爆出的”What The Fuck”数量，哈哈哈</p>\n<h1 id=\"使用可搜索的名称\"><a href=\"#使用可搜索的名称\" class=\"headerlink\" title=\"使用可搜索的名称\"></a>使用可搜索的名称</h1><blockquote>\n<p>名称长短应与其作用域大小相对应</p>\n</blockquote>\n<p>比如，在一个简单的 for 循环里，使用简单的 i 来命名下标就很足够了；而如果一个变量的作用域很大，那么其命名应该易于搜索（名称长是为了易于搜索）</p>\n<h1 id=\"不要写多余的注释，别让你写的注释比看代码还累\"><a href=\"#不要写多余的注释，别让你写的注释比看代码还累\" class=\"headerlink\" title=\"不要写多余的注释，别让你写的注释比看代码还累\"></a>不要写多余的注释，别让你写的注释比看代码还累</h1><blockquote>\n<p>与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那段糟糕的代码</p>\n</blockquote>\n<p>确实，这点我做得不够，有时候为函数的声明写的注释太多，需要改进</p>\n<h1 id=\"如果可以，尽量别注释代码\"><a href=\"#如果可以，尽量别注释代码\" class=\"headerlink\" title=\"如果可以，尽量别注释代码\"></a>如果可以，尽量别注释代码</h1><blockquote>\n<p>其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除</p>\n</blockquote>\n<p>一方面，我看到注释掉的代码真的很讨厌，因为我是极简主义，能少写一行代码甚至一个空格就少写，一坨被注释的代码放在那里会影响阅读体验</p>\n<p>但是另一方面我又不完全同意这个观点，作者说现在已经有版本管理，所以没必要保留注释的代码，但是谁修改代码的时候没事会去查看之前的版本呢？比如，上次我想为频道列表页添加缓存逻辑，但是发现之前有人加过了，但是被注释了，询问之后才发现直接为这个页面添加缓存是有坑的，于是这次添加缓存就顺利绕过了这个坑。那么如果没有这段注释的代码，我可能就会直接跳进这个坑了，因为我修改之前并不可能漫无目的去查看 SVN</p>\n<h1 id=\"不要刻意去水平对齐\"><a href=\"#不要刻意去水平对齐\" class=\"headerlink\" title=\"不要刻意去水平对齐\"></a>不要刻意去水平对齐</h1><p>刻意的水平像是在强调不重要的东西，分散读者注意力</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span>                   leftNum;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>)   <span class=\"built_in\">NSString</span>              *dataKey;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEShareItem        *shareItem;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEONAPosterTitle   *tips;</span><br></pre></td></tr></table></figure>\n<p>下面这段代码更好，因为注意力能更集中在变量的类型上</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span> leftNum;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *dataKey;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEShareItem *shareItem;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEONAPosterTitle *tips;</span><br></pre></td></tr></table></figure>\n<h1 id=\"要编写简洁的代码，必须先写肮脏的代码，然后再清理它\"><a href=\"#要编写简洁的代码，必须先写肮脏的代码，然后再清理它\" class=\"headerlink\" title=\"要编写简洁的代码，必须先写肮脏的代码，然后再清理它\"></a>要编写简洁的代码，必须先写肮脏的代码，然后再清理它</h1><p>问题是写完了肮脏的可运行的代码之后，别着急开始下一个任务而忘记改进它</p>\n<h1 id=\"使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\"><a href=\"#使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\" class=\"headerlink\" title=\"使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\"></a>使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</h1><p>先看一个例子</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pay:(<span class=\"built_in\">BOOL</span>)isVip</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isVip)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// VIP处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先作者认为这种代码不好，因为调用的时候应该去记住传递的 BOOL 代表什么意思，应该改为以下这种</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isVip])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Vip处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或这种</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)vipPay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// VIP处理代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)commonPay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先方法1并不是处处可行，因为对于 Vip 的判断是否合适放在本类要根据具体情况讨论，合适则方法1可行</p>\n<p>而方法2我不敢苟同，因为这首先违背了一种重要的原则——DRY，通用代码在2处地方重复，维护起来十分恶心</p>\n<p>同时，在 IDE 日益强大的今天，多写一个参数并不对程序员的记忆有所挑战，即使有，也比重复代码好</p>\n<h1 id=\"代码要尽可能具有表达力\"><a href=\"#代码要尽可能具有表达力\" class=\"headerlink\" title=\"代码要尽可能具有表达力\"></a>代码要尽可能具有表达力</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (curTime &gt;= startTime &amp;&amp; curTime &lt;= endTime &amp;&amp; !hasShown)    <span class=\"comment\">// 是否应该展示</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>应该处理为下面这种，这比写注释好</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)shouldShow</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (curTime &gt;= startTime &amp;&amp; curTime &lt;= endTime &amp;&amp; !hasShown);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> shouldShow])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"得墨忒耳定律（最少了解原理）\"><a href=\"#得墨忒耳定律（最少了解原理）\" class=\"headerlink\" title=\"得墨忒耳定律（最少了解原理）\"></a>得墨忒耳定律（最少了解原理）</h1><p>A 有一个属性叫 B，B 有一个属性叫 C，C 有一个 doSomething 的函数。现在需要在 A 里面调用 C 的函数。有以下2种写法</p>\n<p>方法1，B 把属性 C 暴露在头文件，让 A 可以直接读取</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.m</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.b.c doSomething];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) C *c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello World!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法2，B 把 C 中的函数封装成接口提供给外部使用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.m</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.b doSomething];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.c doSomething];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello World!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>曾经，我不知道方法1和方法2孰优孰劣，甚至更倾向于方法1，因为代码量更少，但读了这本书后，我明白了，方法2更好，为什么？</p>\n<ul>\n<li>方法1违背了<code>得墨忒耳定律</code>，C 不是 A 的属性，而 A 居然要去了解 C 里面的函数</li>\n<li>假如不止A，还有A1,A2,A3…直接调用了 C 的函数，那么有一天，当 C 修改 doSomething 这个函数名，或者想在 B 和 C 之间再添加一个类 D 的时候，此时方法1就需要修改很多地方，而方法2只需要修改 B 文件</li>\n</ul>\n"},{"title":"网易云音乐歌单共享","date":"2018-10-31T16:00:00.000Z","photos":["http://p1.pstatp.com/large/pgc-image/1539560119468feb70b785e"],"keywords":"网易云音乐;云音乐;共享歌单;","_content":"\n## 背景需求\n网易云音乐只支持收藏歌单，比如 A 可以收藏 B 的歌单，B 可以对歌单进行增删，A 收藏的歌单也发生相应的变化\n\n但如果想实现 A 和 B 都可以对歌单进行增删就行不通了，因为网易云音乐不支持这个功能\n\n如果 A 建一个歌单，B 建一个歌单，然后互相收藏就太蠢了\n\n所以目前已知的背景就是：\n\n1. 只能对自己创建的歌单进行增删歌曲\n2. 无法对收藏的他人的歌单进行增删歌曲\n3. 收藏的歌单被创建者更新时，收藏者可以得到相应的更新\n\n需求就是：\n\n1. 有且只有一份共享的歌单\n2. 对共享歌单的增删操作要简单\n\n## 需求分析\n动动脑筋，可以换个角度实现共享功能：\n\n1. 新申请一个帐号 C，C 创建一个歌单\n2. A 和 B 共同收藏 C 歌单\n3. A 和 B 各自新建一个歌单\n4. A 平时只对自己创建的歌单进行增删歌曲，B 亦然\n5. 利用脚本从 A 和 B 的歌单读取所有歌曲并整合，最终更新到 C 的歌单\n6. A 和 B 就能从 C 歌单中得到最全的歌曲，以此实现共享歌单的功能\n\n## 功能实现\n知道了原理之后，其实最难的是第五步\n\n其实只要网易云音乐提供了相应的 API 即可，Google 之后发现已经有轮子可以用了：[网易云音乐 API](https://github.com/Binaryify/NeteaseCloudMusicApi)\n\n然后根据 API 写脚本代码了，脚本的逻辑如下：\n\n1. 抓取 A 的歌单歌曲，抓取 B 的歌单歌曲，抓取 C 的歌单歌曲\n2. 对 A 和 B 的歌曲进行合并并去重\n3. 去重的结果与 C 对比，得到此次应该添加和删除的歌曲列表\n4. 登录 C 帐号，对 C 的歌单进行添加操作和删除操作\n\n最后，用 `crontab` 定时触发抓取的逻辑即可\n\n## Show me the code\n关键代码如下：\n\n```python\n// 抓取 A 的歌曲\nFooSongList = fetchSongList(RootUrl+FetchSongListUrl+FooSongListId)\n// 抓取 B 的歌曲\nBarSongList = fetchSongList(RootUrl+FetchSongListUrl+BarSongListId)\n// 抓取 C 的歌曲\nOurOldSongList = fetchSongList(RootUrl+FetchSongListUrl+OurSongListId)\n\n// 对 A 和 B 的歌曲进行合并并去重\nourNewSongList = list(set(FooSongList+BarSongList))\nprint(\"ourNewSongList:\")\nprint(ourNewSongList)\n\n// 去重的结果与 C 对比，得到此次应该添加的歌曲列表\nsongListToAdd = list(set(ourNewSongList)-set(OurOldSongList));\nprint(\"songListToAdd:\")\nprint(songListToAdd)\n\n// 去重的结果与 C 对比，得到此次应该删除的歌曲列表\nsongListToDel = list(set(OurOldSongList)-set(ourNewSongList));\nprint(\"songListToDel:\")\nprint(songListToDel)\n\n// 登录 C 帐号，对 C 的歌单添加此次新增的歌曲\nif len(songListToAdd):\n\tsyncSongsToOurSongList(songListToAdd, \"Add\")\n\n// 登录 C 帐号，对 C 的歌单删除此次删除的歌曲\nif len(songListToDel):\n\tsyncSongsToOurSongList(songListToDel, \"Del\")\n```\n\n[完整项目地址](https://github.com/Norcy/ShareNeteaseMusic)\n\n## 后记\n跟其他 [__技术改变生活__](https://norcy.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/) 系列的文章一样，依然是那句话\n\n> 至此，虽然是简简单单的功能，但是，it makes my world better.\n","source":"_posts/网易云音乐歌单共享.md","raw":"---\ntitle: 网易云音乐歌单共享\ndate: 2018-11-01\ncategories:\n- 技术改变生活\nphotos: http://p1.pstatp.com/large/pgc-image/1539560119468feb70b785e\nkeywords: 网易云音乐;云音乐;共享歌单;\n---\n\n## 背景需求\n网易云音乐只支持收藏歌单，比如 A 可以收藏 B 的歌单，B 可以对歌单进行增删，A 收藏的歌单也发生相应的变化\n\n但如果想实现 A 和 B 都可以对歌单进行增删就行不通了，因为网易云音乐不支持这个功能\n\n如果 A 建一个歌单，B 建一个歌单，然后互相收藏就太蠢了\n\n所以目前已知的背景就是：\n\n1. 只能对自己创建的歌单进行增删歌曲\n2. 无法对收藏的他人的歌单进行增删歌曲\n3. 收藏的歌单被创建者更新时，收藏者可以得到相应的更新\n\n需求就是：\n\n1. 有且只有一份共享的歌单\n2. 对共享歌单的增删操作要简单\n\n## 需求分析\n动动脑筋，可以换个角度实现共享功能：\n\n1. 新申请一个帐号 C，C 创建一个歌单\n2. A 和 B 共同收藏 C 歌单\n3. A 和 B 各自新建一个歌单\n4. A 平时只对自己创建的歌单进行增删歌曲，B 亦然\n5. 利用脚本从 A 和 B 的歌单读取所有歌曲并整合，最终更新到 C 的歌单\n6. A 和 B 就能从 C 歌单中得到最全的歌曲，以此实现共享歌单的功能\n\n## 功能实现\n知道了原理之后，其实最难的是第五步\n\n其实只要网易云音乐提供了相应的 API 即可，Google 之后发现已经有轮子可以用了：[网易云音乐 API](https://github.com/Binaryify/NeteaseCloudMusicApi)\n\n然后根据 API 写脚本代码了，脚本的逻辑如下：\n\n1. 抓取 A 的歌单歌曲，抓取 B 的歌单歌曲，抓取 C 的歌单歌曲\n2. 对 A 和 B 的歌曲进行合并并去重\n3. 去重的结果与 C 对比，得到此次应该添加和删除的歌曲列表\n4. 登录 C 帐号，对 C 的歌单进行添加操作和删除操作\n\n最后，用 `crontab` 定时触发抓取的逻辑即可\n\n## Show me the code\n关键代码如下：\n\n```python\n// 抓取 A 的歌曲\nFooSongList = fetchSongList(RootUrl+FetchSongListUrl+FooSongListId)\n// 抓取 B 的歌曲\nBarSongList = fetchSongList(RootUrl+FetchSongListUrl+BarSongListId)\n// 抓取 C 的歌曲\nOurOldSongList = fetchSongList(RootUrl+FetchSongListUrl+OurSongListId)\n\n// 对 A 和 B 的歌曲进行合并并去重\nourNewSongList = list(set(FooSongList+BarSongList))\nprint(\"ourNewSongList:\")\nprint(ourNewSongList)\n\n// 去重的结果与 C 对比，得到此次应该添加的歌曲列表\nsongListToAdd = list(set(ourNewSongList)-set(OurOldSongList));\nprint(\"songListToAdd:\")\nprint(songListToAdd)\n\n// 去重的结果与 C 对比，得到此次应该删除的歌曲列表\nsongListToDel = list(set(OurOldSongList)-set(ourNewSongList));\nprint(\"songListToDel:\")\nprint(songListToDel)\n\n// 登录 C 帐号，对 C 的歌单添加此次新增的歌曲\nif len(songListToAdd):\n\tsyncSongsToOurSongList(songListToAdd, \"Add\")\n\n// 登录 C 帐号，对 C 的歌单删除此次删除的歌曲\nif len(songListToDel):\n\tsyncSongsToOurSongList(songListToDel, \"Del\")\n```\n\n[完整项目地址](https://github.com/Norcy/ShareNeteaseMusic)\n\n## 后记\n跟其他 [__技术改变生活__](https://norcy.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/) 系列的文章一样，依然是那句话\n\n> 至此，虽然是简简单单的功能，但是，it makes my world better.\n","slug":"网易云音乐歌单共享","published":1,"updated":"2018-11-13T03:27:55.871Z","comments":1,"layout":"post","link":"","_id":"cjp2opl3l000xu3qwb2x4arib","content":"<h2 id=\"背景需求\"><a href=\"#背景需求\" class=\"headerlink\" title=\"背景需求\"></a>背景需求</h2><p>网易云音乐只支持收藏歌单，比如 A 可以收藏 B 的歌单，B 可以对歌单进行增删，A 收藏的歌单也发生相应的变化</p>\n<p>但如果想实现 A 和 B 都可以对歌单进行增删就行不通了，因为网易云音乐不支持这个功能</p>\n<p>如果 A 建一个歌单，B 建一个歌单，然后互相收藏就太蠢了</p>\n<p>所以目前已知的背景就是：</p>\n<ol>\n<li>只能对自己创建的歌单进行增删歌曲</li>\n<li>无法对收藏的他人的歌单进行增删歌曲</li>\n<li>收藏的歌单被创建者更新时，收藏者可以得到相应的更新</li>\n</ol>\n<p>需求就是：</p>\n<ol>\n<li>有且只有一份共享的歌单</li>\n<li>对共享歌单的增删操作要简单</li>\n</ol>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><p>动动脑筋，可以换个角度实现共享功能：</p>\n<ol>\n<li>新申请一个帐号 C，C 创建一个歌单</li>\n<li>A 和 B 共同收藏 C 歌单</li>\n<li>A 和 B 各自新建一个歌单</li>\n<li>A 平时只对自己创建的歌单进行增删歌曲，B 亦然</li>\n<li>利用脚本从 A 和 B 的歌单读取所有歌曲并整合，最终更新到 C 的歌单</li>\n<li>A 和 B 就能从 C 歌单中得到最全的歌曲，以此实现共享歌单的功能</li>\n</ol>\n<h2 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h2><p>知道了原理之后，其实最难的是第五步</p>\n<p>其实只要网易云音乐提供了相应的 API 即可，Google 之后发现已经有轮子可以用了：<a href=\"https://github.com/Binaryify/NeteaseCloudMusicApi\" target=\"_blank\" rel=\"noopener\">网易云音乐 API</a></p>\n<p>然后根据 API 写脚本代码了，脚本的逻辑如下：</p>\n<ol>\n<li>抓取 A 的歌单歌曲，抓取 B 的歌单歌曲，抓取 C 的歌单歌曲</li>\n<li>对 A 和 B 的歌曲进行合并并去重</li>\n<li>去重的结果与 C 对比，得到此次应该添加和删除的歌曲列表</li>\n<li>登录 C 帐号，对 C 的歌单进行添加操作和删除操作</li>\n</ol>\n<p>最后，用 <code>crontab</code> 定时触发抓取的逻辑即可</p>\n<h2 id=\"Show-me-the-code\"><a href=\"#Show-me-the-code\" class=\"headerlink\" title=\"Show me the code\"></a>Show me the code</h2><p>关键代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 抓取 A 的歌曲</span><br><span class=\"line\">FooSongList = fetchSongList(RootUrl+FetchSongListUrl+FooSongListId)</span><br><span class=\"line\">// 抓取 B 的歌曲</span><br><span class=\"line\">BarSongList = fetchSongList(RootUrl+FetchSongListUrl+BarSongListId)</span><br><span class=\"line\">// 抓取 C 的歌曲</span><br><span class=\"line\">OurOldSongList = fetchSongList(RootUrl+FetchSongListUrl+OurSongListId)</span><br><span class=\"line\"></span><br><span class=\"line\">// 对 A 和 B 的歌曲进行合并并去重</span><br><span class=\"line\">ourNewSongList = list(set(FooSongList+BarSongList))</span><br><span class=\"line\">print(<span class=\"string\">\"ourNewSongList:\"</span>)</span><br><span class=\"line\">print(ourNewSongList)</span><br><span class=\"line\"></span><br><span class=\"line\">// 去重的结果与 C 对比，得到此次应该添加的歌曲列表</span><br><span class=\"line\">songListToAdd = list(set(ourNewSongList)-set(OurOldSongList));</span><br><span class=\"line\">print(<span class=\"string\">\"songListToAdd:\"</span>)</span><br><span class=\"line\">print(songListToAdd)</span><br><span class=\"line\"></span><br><span class=\"line\">// 去重的结果与 C 对比，得到此次应该删除的歌曲列表</span><br><span class=\"line\">songListToDel = list(set(OurOldSongList)-set(ourNewSongList));</span><br><span class=\"line\">print(<span class=\"string\">\"songListToDel:\"</span>)</span><br><span class=\"line\">print(songListToDel)</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录 C 帐号，对 C 的歌单添加此次新增的歌曲</span><br><span class=\"line\"><span class=\"keyword\">if</span> len(songListToAdd):</span><br><span class=\"line\">\tsyncSongsToOurSongList(songListToAdd, <span class=\"string\">\"Add\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录 C 帐号，对 C 的歌单删除此次删除的歌曲</span><br><span class=\"line\"><span class=\"keyword\">if</span> len(songListToDel):</span><br><span class=\"line\">\tsyncSongsToOurSongList(songListToDel, <span class=\"string\">\"Del\"</span>)</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/Norcy/ShareNeteaseMusic\" target=\"_blank\" rel=\"noopener\">完整项目地址</a></p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>跟其他 <a href=\"https://norcy.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/\"><strong>技术改变生活</strong></a> 系列的文章一样，依然是那句话</p>\n<blockquote>\n<p>至此，虽然是简简单单的功能，但是，it makes my world better.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景需求\"><a href=\"#背景需求\" class=\"headerlink\" title=\"背景需求\"></a>背景需求</h2><p>网易云音乐只支持收藏歌单，比如 A 可以收藏 B 的歌单，B 可以对歌单进行增删，A 收藏的歌单也发生相应的变化</p>\n<p>但如果想实现 A 和 B 都可以对歌单进行增删就行不通了，因为网易云音乐不支持这个功能</p>\n<p>如果 A 建一个歌单，B 建一个歌单，然后互相收藏就太蠢了</p>\n<p>所以目前已知的背景就是：</p>\n<ol>\n<li>只能对自己创建的歌单进行增删歌曲</li>\n<li>无法对收藏的他人的歌单进行增删歌曲</li>\n<li>收藏的歌单被创建者更新时，收藏者可以得到相应的更新</li>\n</ol>\n<p>需求就是：</p>\n<ol>\n<li>有且只有一份共享的歌单</li>\n<li>对共享歌单的增删操作要简单</li>\n</ol>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><p>动动脑筋，可以换个角度实现共享功能：</p>\n<ol>\n<li>新申请一个帐号 C，C 创建一个歌单</li>\n<li>A 和 B 共同收藏 C 歌单</li>\n<li>A 和 B 各自新建一个歌单</li>\n<li>A 平时只对自己创建的歌单进行增删歌曲，B 亦然</li>\n<li>利用脚本从 A 和 B 的歌单读取所有歌曲并整合，最终更新到 C 的歌单</li>\n<li>A 和 B 就能从 C 歌单中得到最全的歌曲，以此实现共享歌单的功能</li>\n</ol>\n<h2 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h2><p>知道了原理之后，其实最难的是第五步</p>\n<p>其实只要网易云音乐提供了相应的 API 即可，Google 之后发现已经有轮子可以用了：<a href=\"https://github.com/Binaryify/NeteaseCloudMusicApi\" target=\"_blank\" rel=\"noopener\">网易云音乐 API</a></p>\n<p>然后根据 API 写脚本代码了，脚本的逻辑如下：</p>\n<ol>\n<li>抓取 A 的歌单歌曲，抓取 B 的歌单歌曲，抓取 C 的歌单歌曲</li>\n<li>对 A 和 B 的歌曲进行合并并去重</li>\n<li>去重的结果与 C 对比，得到此次应该添加和删除的歌曲列表</li>\n<li>登录 C 帐号，对 C 的歌单进行添加操作和删除操作</li>\n</ol>\n<p>最后，用 <code>crontab</code> 定时触发抓取的逻辑即可</p>\n<h2 id=\"Show-me-the-code\"><a href=\"#Show-me-the-code\" class=\"headerlink\" title=\"Show me the code\"></a>Show me the code</h2><p>关键代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 抓取 A 的歌曲</span><br><span class=\"line\">FooSongList = fetchSongList(RootUrl+FetchSongListUrl+FooSongListId)</span><br><span class=\"line\">// 抓取 B 的歌曲</span><br><span class=\"line\">BarSongList = fetchSongList(RootUrl+FetchSongListUrl+BarSongListId)</span><br><span class=\"line\">// 抓取 C 的歌曲</span><br><span class=\"line\">OurOldSongList = fetchSongList(RootUrl+FetchSongListUrl+OurSongListId)</span><br><span class=\"line\"></span><br><span class=\"line\">// 对 A 和 B 的歌曲进行合并并去重</span><br><span class=\"line\">ourNewSongList = list(set(FooSongList+BarSongList))</span><br><span class=\"line\">print(<span class=\"string\">\"ourNewSongList:\"</span>)</span><br><span class=\"line\">print(ourNewSongList)</span><br><span class=\"line\"></span><br><span class=\"line\">// 去重的结果与 C 对比，得到此次应该添加的歌曲列表</span><br><span class=\"line\">songListToAdd = list(set(ourNewSongList)-set(OurOldSongList));</span><br><span class=\"line\">print(<span class=\"string\">\"songListToAdd:\"</span>)</span><br><span class=\"line\">print(songListToAdd)</span><br><span class=\"line\"></span><br><span class=\"line\">// 去重的结果与 C 对比，得到此次应该删除的歌曲列表</span><br><span class=\"line\">songListToDel = list(set(OurOldSongList)-set(ourNewSongList));</span><br><span class=\"line\">print(<span class=\"string\">\"songListToDel:\"</span>)</span><br><span class=\"line\">print(songListToDel)</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录 C 帐号，对 C 的歌单添加此次新增的歌曲</span><br><span class=\"line\"><span class=\"keyword\">if</span> len(songListToAdd):</span><br><span class=\"line\">\tsyncSongsToOurSongList(songListToAdd, <span class=\"string\">\"Add\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录 C 帐号，对 C 的歌单删除此次删除的歌曲</span><br><span class=\"line\"><span class=\"keyword\">if</span> len(songListToDel):</span><br><span class=\"line\">\tsyncSongsToOurSongList(songListToDel, <span class=\"string\">\"Del\"</span>)</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/Norcy/ShareNeteaseMusic\" target=\"_blank\" rel=\"noopener\">完整项目地址</a></p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>跟其他 <a href=\"https://norcy.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/\"><strong>技术改变生活</strong></a> 系列的文章一样，依然是那句话</p>\n<blockquote>\n<p>至此，虽然是简简单单的功能，但是，it makes my world better.</p>\n</blockquote>\n"},{"title":"那些年，我看过的","date":"2013-02-28T16:00:00.000Z","description":"我的书籍/电影/电视剧/动漫列表","_content":"\n# 2018年\n## 01月\n+ 《神秘巨星》\n+ 《无问西东》\n+ 《奇门遁甲》\n\n## 02月\n+ 《唐人街探案2》\n+ 《活着本来单纯》（书）\n\n## 04月\n+ 《起跑线》\n\n## 05月\n+ 《罪途》\n+ 《寻梦环游记》\n\n## 06月\n+ 《活着》（书）\n+ 《倚天屠龙记》（书）\n\n## 07月\n+ 《我不是药神》\n\n## 08月\n+ 《爸，我一定行的》\n+ 《小王子》（书）\n+ 《人之岛》（书）\n+ 《厕所英雄》\n\n## 09月\n+ 《碟中谍6》\n+ 《传奇的诞生》\n\n## 10月\n+ 《地心引力》\n+ 《月亮与六便士》（书）\n+ 《杜月笙全传》（书）\n+ 《一起同过窗2》（连续剧）\n+ 《嗝嗝老师》\n+ 《MacTalk跨越边界》（书）\n+ 《李茶的姑妈》\n+ 《名侦探柯南剧场版11_绀碧之棺》\n\n## 11月\n+ 《动物凶猛》（书）\n+ 《谍影重重》\n+ 《哈利波特与密室》\n+ 《狙击电话亭》\n+ 《毒液：致命守护者》\n+ 《西虹市首富》\n\n\n# 2017年\n## 01月\n+ 《鲨滩》\n+ 《西游伏妖篇》\n+ 《乘风破浪》\n+ 《三少爷的剑》\n\n## 02月\n+ 《你的名字》\n\n## 06月\n+ 《非暴力沟通》（书）\n\n## 07月\n+ 《悟空传》\n+ 《小黄人3》\n+ 《嫌疑人x的献身》\n+ 《假面饭店》\n\n## 08月\n+ 《战狼2》\n\n## 09月\n+ 《目击者之追凶》\n+ 《猩球崛起3》\n+ 《太空旅客》\n+ 《时光倒流的女孩》（书）\n\n## 10月\n+ 《羞羞的铁拳》\n+ 《看不见的客人》\n+ 《天才枪手》\n\n## 11月\n+ 《缝纫机乐队》\n+ 《地球脉动2》\n+ 《哈利波特与魔法石》\n\n## 12月\n+ 《解忧杂货店》\n+ 《少有人走的路》（书）\n\n\n# 2016年\n## 01月\n+ 《枭雄》（连续剧）\n+ 《心迷宫》\n+ 《像素大战》\n+ 《亲爱的》\n+ 《越女剑》（书）\n\n## 02月\n+ 《赌侠大战拉斯维加斯》\n+ 《荒蛮故事》\n+ 《美人鱼》\n+ 《火星救援》\n+ 《扑克王》\n+ 《我的少女时代》\n+ 《国产凌凌漆》\n+ 《时间的朋友2015》（书）\n\n## 03月\n+ 《伟大的隐藏者》\n\n## 05月\n+ 《信号》（连续剧）\n+ 《美国队长3》\n+ 《火锅英雄》\n+ 《乒乓侠》\n\n## 06月\n+ 《独立日2》\n+ 《澳门风云3》\n+ 《明日世界》\n+ 《家和万事兴之我爱我车》\n+ 《功夫熊猫3》\n\n## 07月\n+ 《完美陌生人》\n+ 《大鱼海棠》\n+ 《六扇门》\n+ 《安妮和王小明第二季》（书）\n+ 《安妮和王小明第一季》（书）\n+ 《妮玛！这就是大学！》（书）\n+ 《妮玛的唠嗑馆》（书）\n+ 《代码整洁之道》（书）\n\n## 08月\n+ 《余罪 第一季》（连续剧）\n+ 《一起同过窗》\n+ 《三毛流浪记（漫画）》（书）\n\n## 09月\n+ 《余罪 第二季》（连续剧）\n+ 《One of Us》（连续剧）\n+ 《龙珠Z：复活的F》\n+ 《招魂2》\n+ 《叶问3》\n+ 《绝对小孩》（书）\n+ 《小白理财第一课》（书）\n+ 《人间失格》（书）\n+ 《五次方谋杀》（书）\n\n## 10月\n+ 《选老顶》\n+ 《湄公河行动》\n+ 《刑警兄弟》\n+ 《送你一颗子弹》（书）\n+ 《绝对小孩2》（书）\n+ 《把时间当做朋友》（书）\n+ 《嫌疑人X的献身》（书）\n+ 《三观易碎》（书）\n+ 《七堂极简物理课》（书）\n\n## 11月\n+ 《荒岛余生》\n+ 《不正常人类症候群》（书）\n\n\n# 2015年\n## 01月\n+ 《鹿鼎记2神龙教》\n+ 《鹿鼎记》\n+ 《源代码》\n+ 《最佳出价》\n+ 《智取威虎山》\n+ 《恐怖直播》\n+ 《宿敌》\n+ 《在我入睡前》\n+ 《名侦探柯南剧场版6 贝克街的亡灵》\n+ 《十三度凶间》\n+ 《牛奶可乐经济学》（书）\n\n## 02月\n+ 《爱情公寓4》（连续剧）\n+ 《暴走恐怖故事第一季》（连续剧）\n+ 《天降之物》（连续剧）\n+ 《时空恋旅人》\n+ 《无声言证》\n+ 《地球回音》\n+ 《十万个冷笑话电影》\n+ 《匆匆那年》\n+ 《Premature》\n+ 《K-PAX》\n\n## 03月\n+ 《黑洞频率》\n+ 《超能陆战队》\n+ 《等一个人咖啡》\n+ 《穹顶之下》\n+ 《爆裂鼓手》\n+ 《解忧杂货店》（书）\n+ 《我的互联网方法论》（书）\n\n## 04月\n+ 《哆啦A梦：伴我同行》\n\n## 05月\n+ 《生人活祭》\n+ 《伊甸湖》\n\n## 06月\n+ 《名侦探狄仁杰》（连续剧）\n+ 《附身》\n+ 《澳门风云2》\n+ 《海洋之歌》\n+ 《左耳》\n+ 《侏罗纪公园》\n+ 《侏罗纪世界》\n+ 《两个月亮》\n\n## 07月\n+ 《速度与激情7》\n+ 《煎饼侠》\n+ 《捉妖记》\n+ 《小森林·夏秋篇》\n+ 《小森林·冬春篇》\n+ 《名侦探柯南剧场版 异次元的狙击手》\n+ 《五十度灰》\n\n## 08月\n+ 《道士下山》\n+ 《笑傲江湖》\n+ 《笑傲江湖》（书）\n\n## 09月\n+ 《港囧》\n\n## 10月\n+ 《画江湖之不良人》（连续剧）\n+ 《这个男人来自地球》\n+ 《我是路人甲》\n+ 《决战紫禁之巅》\n+ 《Programming with Objective-C》（书）\n\n## 11月\n+ 《夏洛特烦恼》\n+ 《荒庙》（书）\n+ 《暗时间》（书）\n\n## 12月\n+ 《西游记之大圣归来》\n+ 《移动迷宫》\n+ 《真实魔鬼游戏》\n+ 《消失的凶手》\n+ 《尘曲》（书）\n\n\n# 2014年\n## 03月\n+ 《死亡笔记》（连续剧）\n\n## 04月\n+ 《麦兜响当当》\n+ 《零下一度》\n+ 《逆光飞翔》\n+ 《同桌的你》\n+ 《古墓丽影2》\n+ 《古墓丽影》\n\n## 05月\n+ 《麦兜故事》\n+ 《警察故事2013》\n+ 《潘金莲之前世今生》\n+ 《你是下一个》\n+ 《X战警：逆转未来》\n+ 《百年孤独》（书）\n+ 《C++程序设计》（书）\n\n## 06月\n+ 《金刚狼Ⅱ》\n+ 《金刚狼》\n+ 《警察故事2013》\n+ 《生死停留》\n+ 《爆笑角斗士》\n+ 《六福喜事》\n+ 《X战警：第一战》\n+ 《X战警Ⅲ》\n+ 《X战警Ⅱ》\n+ 《X战警Ⅰ》\n+ 《杂的文》（书）\n+ 《天才在左，疯子在右》（书）\n+ 《三重门》（书）\n+ 《c++基础教程》（书）\n\n## 07月\n+ 《进击的巨人》（连续剧）\n+ 《秒速5厘米》\n+ 《狄仁杰之神都龙王》\n+ 《澳门风云》\n+ 《无人区》\n+ 《后会无期》\n+ 《变形金刚4：绝迹重生》\n+ 《十二生肖》\n\n## 08月\n+ 《志明与春娇》\n\n## 09月\n+ 《绣春刀》\n+ 《猩球崛起2》\n+ 《春娇与志明》\n+ 《明日边缘》\n+ 《惊天魔盗团》\n+ 《安德的游戏》\n+ 《分歧者——异类崛起》\n+ 《催眠大师》\n\n## 10月\n+ 《生活启示录》（连续剧）\n+ 《黑暗面》\n+ 《那夜凌晨 我坐上旺角开往大埔的红van》\n+ 《触不可及》\n+ 《被偷走的那五年》\n+ 《猎头游戏》\n+ 《牯岭街少年杀人事件》\n+ 《控方证人》\n+ 《惊声尖叫》\n+ 《归来》\n+ 《四大名捕大结局》\n+ 《决战猩球》\n+ 《一级恐惧》\n+ 《飞狐外传》（书）\n+ 《平凡的世界Ⅲ》（书）\n+ 《平凡的世界Ⅱ》（书）\n+ 《平凡的世界Ⅰ》（书）\n\n## 11月\n+ 《魔女嘉莉》\n+ 《鬼子来了》\n+ 《银河护卫队》\n+ 《透明人2》\n+ 《透明人》\n+ 《林中小屋》\n+ 《极速前进》\n+ 《心花路放》\n+ 《彗星来的那一夜》\n+ 《寒战》\n+ 《失踪罪》\n+ 《太阳照常升起》\n+ 《哆啦A梦：新·大雄的大魔境》\n+ 《十七岁的单车》\n+ 《侧耳倾听》\n+ 《The One I Love》\n+ 《In Your Eyes》\n+ 《连城诀》（书）\n+ 《沙僧吐槽日记》（书）\n+ 《早晨从中午开始》（书）\n+ 《大地飞鹰》（书）\n+ 《一个人的好天气》（书）\n+ 《1988——我想和这个世界谈谈》（书）\n\n## 12月\n+ 《黄飞鸿之英雄有梦》\n+ 《麦兜菠萝油王子》\n+ 《马达加斯加的企鹅》\n+ 《超体》\n+ 《楚留香传奇之大沙漠》\n+ 《极速前进》\n+ 《月亮》\n+ 《星际穿越》\n+ 《新大头儿子和小头爸爸之秘密计划》\n+ 《弹窗惊魂》\n+ 《名侦探柯南剧场版1 引爆摩天楼》\n+ 《刺杀金正恩》\n+ 《关于时间旅行的热门问题》\n+ 《不惧风暴》\n+ 《一步之遥》\n+ 《一个人的武林》\n+ 《The Giver》\n+ 《理科的人Ⅰ》（书）\n+ 《楚留香传奇之血海飘香》（书）\n+ 《楚留香传奇之画眉鸟》（书）\n\n\n","source":"_posts/那些年，我看过的.md","raw":"---\ntitle: 那些年，我看过的\ndate: 2013-3-1\ndescription: 我的书籍/电影/电视剧/动漫列表\ncategories:\n- 代码之外 \n---\n\n# 2018年\n## 01月\n+ 《神秘巨星》\n+ 《无问西东》\n+ 《奇门遁甲》\n\n## 02月\n+ 《唐人街探案2》\n+ 《活着本来单纯》（书）\n\n## 04月\n+ 《起跑线》\n\n## 05月\n+ 《罪途》\n+ 《寻梦环游记》\n\n## 06月\n+ 《活着》（书）\n+ 《倚天屠龙记》（书）\n\n## 07月\n+ 《我不是药神》\n\n## 08月\n+ 《爸，我一定行的》\n+ 《小王子》（书）\n+ 《人之岛》（书）\n+ 《厕所英雄》\n\n## 09月\n+ 《碟中谍6》\n+ 《传奇的诞生》\n\n## 10月\n+ 《地心引力》\n+ 《月亮与六便士》（书）\n+ 《杜月笙全传》（书）\n+ 《一起同过窗2》（连续剧）\n+ 《嗝嗝老师》\n+ 《MacTalk跨越边界》（书）\n+ 《李茶的姑妈》\n+ 《名侦探柯南剧场版11_绀碧之棺》\n\n## 11月\n+ 《动物凶猛》（书）\n+ 《谍影重重》\n+ 《哈利波特与密室》\n+ 《狙击电话亭》\n+ 《毒液：致命守护者》\n+ 《西虹市首富》\n\n\n# 2017年\n## 01月\n+ 《鲨滩》\n+ 《西游伏妖篇》\n+ 《乘风破浪》\n+ 《三少爷的剑》\n\n## 02月\n+ 《你的名字》\n\n## 06月\n+ 《非暴力沟通》（书）\n\n## 07月\n+ 《悟空传》\n+ 《小黄人3》\n+ 《嫌疑人x的献身》\n+ 《假面饭店》\n\n## 08月\n+ 《战狼2》\n\n## 09月\n+ 《目击者之追凶》\n+ 《猩球崛起3》\n+ 《太空旅客》\n+ 《时光倒流的女孩》（书）\n\n## 10月\n+ 《羞羞的铁拳》\n+ 《看不见的客人》\n+ 《天才枪手》\n\n## 11月\n+ 《缝纫机乐队》\n+ 《地球脉动2》\n+ 《哈利波特与魔法石》\n\n## 12月\n+ 《解忧杂货店》\n+ 《少有人走的路》（书）\n\n\n# 2016年\n## 01月\n+ 《枭雄》（连续剧）\n+ 《心迷宫》\n+ 《像素大战》\n+ 《亲爱的》\n+ 《越女剑》（书）\n\n## 02月\n+ 《赌侠大战拉斯维加斯》\n+ 《荒蛮故事》\n+ 《美人鱼》\n+ 《火星救援》\n+ 《扑克王》\n+ 《我的少女时代》\n+ 《国产凌凌漆》\n+ 《时间的朋友2015》（书）\n\n## 03月\n+ 《伟大的隐藏者》\n\n## 05月\n+ 《信号》（连续剧）\n+ 《美国队长3》\n+ 《火锅英雄》\n+ 《乒乓侠》\n\n## 06月\n+ 《独立日2》\n+ 《澳门风云3》\n+ 《明日世界》\n+ 《家和万事兴之我爱我车》\n+ 《功夫熊猫3》\n\n## 07月\n+ 《完美陌生人》\n+ 《大鱼海棠》\n+ 《六扇门》\n+ 《安妮和王小明第二季》（书）\n+ 《安妮和王小明第一季》（书）\n+ 《妮玛！这就是大学！》（书）\n+ 《妮玛的唠嗑馆》（书）\n+ 《代码整洁之道》（书）\n\n## 08月\n+ 《余罪 第一季》（连续剧）\n+ 《一起同过窗》\n+ 《三毛流浪记（漫画）》（书）\n\n## 09月\n+ 《余罪 第二季》（连续剧）\n+ 《One of Us》（连续剧）\n+ 《龙珠Z：复活的F》\n+ 《招魂2》\n+ 《叶问3》\n+ 《绝对小孩》（书）\n+ 《小白理财第一课》（书）\n+ 《人间失格》（书）\n+ 《五次方谋杀》（书）\n\n## 10月\n+ 《选老顶》\n+ 《湄公河行动》\n+ 《刑警兄弟》\n+ 《送你一颗子弹》（书）\n+ 《绝对小孩2》（书）\n+ 《把时间当做朋友》（书）\n+ 《嫌疑人X的献身》（书）\n+ 《三观易碎》（书）\n+ 《七堂极简物理课》（书）\n\n## 11月\n+ 《荒岛余生》\n+ 《不正常人类症候群》（书）\n\n\n# 2015年\n## 01月\n+ 《鹿鼎记2神龙教》\n+ 《鹿鼎记》\n+ 《源代码》\n+ 《最佳出价》\n+ 《智取威虎山》\n+ 《恐怖直播》\n+ 《宿敌》\n+ 《在我入睡前》\n+ 《名侦探柯南剧场版6 贝克街的亡灵》\n+ 《十三度凶间》\n+ 《牛奶可乐经济学》（书）\n\n## 02月\n+ 《爱情公寓4》（连续剧）\n+ 《暴走恐怖故事第一季》（连续剧）\n+ 《天降之物》（连续剧）\n+ 《时空恋旅人》\n+ 《无声言证》\n+ 《地球回音》\n+ 《十万个冷笑话电影》\n+ 《匆匆那年》\n+ 《Premature》\n+ 《K-PAX》\n\n## 03月\n+ 《黑洞频率》\n+ 《超能陆战队》\n+ 《等一个人咖啡》\n+ 《穹顶之下》\n+ 《爆裂鼓手》\n+ 《解忧杂货店》（书）\n+ 《我的互联网方法论》（书）\n\n## 04月\n+ 《哆啦A梦：伴我同行》\n\n## 05月\n+ 《生人活祭》\n+ 《伊甸湖》\n\n## 06月\n+ 《名侦探狄仁杰》（连续剧）\n+ 《附身》\n+ 《澳门风云2》\n+ 《海洋之歌》\n+ 《左耳》\n+ 《侏罗纪公园》\n+ 《侏罗纪世界》\n+ 《两个月亮》\n\n## 07月\n+ 《速度与激情7》\n+ 《煎饼侠》\n+ 《捉妖记》\n+ 《小森林·夏秋篇》\n+ 《小森林·冬春篇》\n+ 《名侦探柯南剧场版 异次元的狙击手》\n+ 《五十度灰》\n\n## 08月\n+ 《道士下山》\n+ 《笑傲江湖》\n+ 《笑傲江湖》（书）\n\n## 09月\n+ 《港囧》\n\n## 10月\n+ 《画江湖之不良人》（连续剧）\n+ 《这个男人来自地球》\n+ 《我是路人甲》\n+ 《决战紫禁之巅》\n+ 《Programming with Objective-C》（书）\n\n## 11月\n+ 《夏洛特烦恼》\n+ 《荒庙》（书）\n+ 《暗时间》（书）\n\n## 12月\n+ 《西游记之大圣归来》\n+ 《移动迷宫》\n+ 《真实魔鬼游戏》\n+ 《消失的凶手》\n+ 《尘曲》（书）\n\n\n# 2014年\n## 03月\n+ 《死亡笔记》（连续剧）\n\n## 04月\n+ 《麦兜响当当》\n+ 《零下一度》\n+ 《逆光飞翔》\n+ 《同桌的你》\n+ 《古墓丽影2》\n+ 《古墓丽影》\n\n## 05月\n+ 《麦兜故事》\n+ 《警察故事2013》\n+ 《潘金莲之前世今生》\n+ 《你是下一个》\n+ 《X战警：逆转未来》\n+ 《百年孤独》（书）\n+ 《C++程序设计》（书）\n\n## 06月\n+ 《金刚狼Ⅱ》\n+ 《金刚狼》\n+ 《警察故事2013》\n+ 《生死停留》\n+ 《爆笑角斗士》\n+ 《六福喜事》\n+ 《X战警：第一战》\n+ 《X战警Ⅲ》\n+ 《X战警Ⅱ》\n+ 《X战警Ⅰ》\n+ 《杂的文》（书）\n+ 《天才在左，疯子在右》（书）\n+ 《三重门》（书）\n+ 《c++基础教程》（书）\n\n## 07月\n+ 《进击的巨人》（连续剧）\n+ 《秒速5厘米》\n+ 《狄仁杰之神都龙王》\n+ 《澳门风云》\n+ 《无人区》\n+ 《后会无期》\n+ 《变形金刚4：绝迹重生》\n+ 《十二生肖》\n\n## 08月\n+ 《志明与春娇》\n\n## 09月\n+ 《绣春刀》\n+ 《猩球崛起2》\n+ 《春娇与志明》\n+ 《明日边缘》\n+ 《惊天魔盗团》\n+ 《安德的游戏》\n+ 《分歧者——异类崛起》\n+ 《催眠大师》\n\n## 10月\n+ 《生活启示录》（连续剧）\n+ 《黑暗面》\n+ 《那夜凌晨 我坐上旺角开往大埔的红van》\n+ 《触不可及》\n+ 《被偷走的那五年》\n+ 《猎头游戏》\n+ 《牯岭街少年杀人事件》\n+ 《控方证人》\n+ 《惊声尖叫》\n+ 《归来》\n+ 《四大名捕大结局》\n+ 《决战猩球》\n+ 《一级恐惧》\n+ 《飞狐外传》（书）\n+ 《平凡的世界Ⅲ》（书）\n+ 《平凡的世界Ⅱ》（书）\n+ 《平凡的世界Ⅰ》（书）\n\n## 11月\n+ 《魔女嘉莉》\n+ 《鬼子来了》\n+ 《银河护卫队》\n+ 《透明人2》\n+ 《透明人》\n+ 《林中小屋》\n+ 《极速前进》\n+ 《心花路放》\n+ 《彗星来的那一夜》\n+ 《寒战》\n+ 《失踪罪》\n+ 《太阳照常升起》\n+ 《哆啦A梦：新·大雄的大魔境》\n+ 《十七岁的单车》\n+ 《侧耳倾听》\n+ 《The One I Love》\n+ 《In Your Eyes》\n+ 《连城诀》（书）\n+ 《沙僧吐槽日记》（书）\n+ 《早晨从中午开始》（书）\n+ 《大地飞鹰》（书）\n+ 《一个人的好天气》（书）\n+ 《1988——我想和这个世界谈谈》（书）\n\n## 12月\n+ 《黄飞鸿之英雄有梦》\n+ 《麦兜菠萝油王子》\n+ 《马达加斯加的企鹅》\n+ 《超体》\n+ 《楚留香传奇之大沙漠》\n+ 《极速前进》\n+ 《月亮》\n+ 《星际穿越》\n+ 《新大头儿子和小头爸爸之秘密计划》\n+ 《弹窗惊魂》\n+ 《名侦探柯南剧场版1 引爆摩天楼》\n+ 《刺杀金正恩》\n+ 《关于时间旅行的热门问题》\n+ 《不惧风暴》\n+ 《一步之遥》\n+ 《一个人的武林》\n+ 《The Giver》\n+ 《理科的人Ⅰ》（书）\n+ 《楚留香传奇之血海飘香》（书）\n+ 《楚留香传奇之画眉鸟》（书）\n\n\n","slug":"那些年，我看过的","published":1,"updated":"2018-11-29T12:30:26.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp2opl3l000zu3qwgg6u28vh","content":"<h1 id=\"2018年\"><a href=\"#2018年\" class=\"headerlink\" title=\"2018年\"></a>2018年</h1><h2 id=\"01月\"><a href=\"#01月\" class=\"headerlink\" title=\"01月\"></a>01月</h2><ul>\n<li>《神秘巨星》</li>\n<li>《无问西东》</li>\n<li>《奇门遁甲》</li>\n</ul>\n<h2 id=\"02月\"><a href=\"#02月\" class=\"headerlink\" title=\"02月\"></a>02月</h2><ul>\n<li>《唐人街探案2》</li>\n<li>《活着本来单纯》（书）</li>\n</ul>\n<h2 id=\"04月\"><a href=\"#04月\" class=\"headerlink\" title=\"04月\"></a>04月</h2><ul>\n<li>《起跑线》</li>\n</ul>\n<h2 id=\"05月\"><a href=\"#05月\" class=\"headerlink\" title=\"05月\"></a>05月</h2><ul>\n<li>《罪途》</li>\n<li>《寻梦环游记》</li>\n</ul>\n<h2 id=\"06月\"><a href=\"#06月\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《活着》（书）</li>\n<li>《倚天屠龙记》（书）</li>\n</ul>\n<h2 id=\"07月\"><a href=\"#07月\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《我不是药神》</li>\n</ul>\n<h2 id=\"08月\"><a href=\"#08月\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《爸，我一定行的》</li>\n<li>《小王子》（书）</li>\n<li>《人之岛》（书）</li>\n<li>《厕所英雄》</li>\n</ul>\n<h2 id=\"09月\"><a href=\"#09月\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《碟中谍6》</li>\n<li>《传奇的诞生》</li>\n</ul>\n<h2 id=\"10月\"><a href=\"#10月\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《地心引力》</li>\n<li>《月亮与六便士》（书）</li>\n<li>《杜月笙全传》（书）</li>\n<li>《一起同过窗2》（连续剧）</li>\n<li>《嗝嗝老师》</li>\n<li>《MacTalk跨越边界》（书）</li>\n<li>《李茶的姑妈》</li>\n<li>《名侦探柯南剧场版11_绀碧之棺》</li>\n</ul>\n<h2 id=\"11月\"><a href=\"#11月\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《动物凶猛》（书）</li>\n<li>《谍影重重》</li>\n<li>《哈利波特与密室》</li>\n<li>《狙击电话亭》</li>\n<li>《毒液：致命守护者》</li>\n<li>《西虹市首富》</li>\n</ul>\n<h1 id=\"2017年\"><a href=\"#2017年\" class=\"headerlink\" title=\"2017年\"></a>2017年</h1><h2 id=\"01月-1\"><a href=\"#01月-1\" class=\"headerlink\" title=\"01月\"></a>01月</h2><ul>\n<li>《鲨滩》</li>\n<li>《西游伏妖篇》</li>\n<li>《乘风破浪》</li>\n<li>《三少爷的剑》</li>\n</ul>\n<h2 id=\"02月-1\"><a href=\"#02月-1\" class=\"headerlink\" title=\"02月\"></a>02月</h2><ul>\n<li>《你的名字》</li>\n</ul>\n<h2 id=\"06月-1\"><a href=\"#06月-1\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《非暴力沟通》（书）</li>\n</ul>\n<h2 id=\"07月-1\"><a href=\"#07月-1\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《悟空传》</li>\n<li>《小黄人3》</li>\n<li>《嫌疑人x的献身》</li>\n<li>《假面饭店》</li>\n</ul>\n<h2 id=\"08月-1\"><a href=\"#08月-1\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《战狼2》</li>\n</ul>\n<h2 id=\"09月-1\"><a href=\"#09月-1\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《目击者之追凶》</li>\n<li>《猩球崛起3》</li>\n<li>《太空旅客》</li>\n<li>《时光倒流的女孩》（书）</li>\n</ul>\n<h2 id=\"10月-1\"><a href=\"#10月-1\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《羞羞的铁拳》</li>\n<li>《看不见的客人》</li>\n<li>《天才枪手》</li>\n</ul>\n<h2 id=\"11月-1\"><a href=\"#11月-1\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《缝纫机乐队》</li>\n<li>《地球脉动2》</li>\n<li>《哈利波特与魔法石》</li>\n</ul>\n<h2 id=\"12月\"><a href=\"#12月\" class=\"headerlink\" title=\"12月\"></a>12月</h2><ul>\n<li>《解忧杂货店》</li>\n<li>《少有人走的路》（书）</li>\n</ul>\n<h1 id=\"2016年\"><a href=\"#2016年\" class=\"headerlink\" title=\"2016年\"></a>2016年</h1><h2 id=\"01月-2\"><a href=\"#01月-2\" class=\"headerlink\" title=\"01月\"></a>01月</h2><ul>\n<li>《枭雄》（连续剧）</li>\n<li>《心迷宫》</li>\n<li>《像素大战》</li>\n<li>《亲爱的》</li>\n<li>《越女剑》（书）</li>\n</ul>\n<h2 id=\"02月-2\"><a href=\"#02月-2\" class=\"headerlink\" title=\"02月\"></a>02月</h2><ul>\n<li>《赌侠大战拉斯维加斯》</li>\n<li>《荒蛮故事》</li>\n<li>《美人鱼》</li>\n<li>《火星救援》</li>\n<li>《扑克王》</li>\n<li>《我的少女时代》</li>\n<li>《国产凌凌漆》</li>\n<li>《时间的朋友2015》（书）</li>\n</ul>\n<h2 id=\"03月\"><a href=\"#03月\" class=\"headerlink\" title=\"03月\"></a>03月</h2><ul>\n<li>《伟大的隐藏者》</li>\n</ul>\n<h2 id=\"05月-1\"><a href=\"#05月-1\" class=\"headerlink\" title=\"05月\"></a>05月</h2><ul>\n<li>《信号》（连续剧）</li>\n<li>《美国队长3》</li>\n<li>《火锅英雄》</li>\n<li>《乒乓侠》</li>\n</ul>\n<h2 id=\"06月-2\"><a href=\"#06月-2\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《独立日2》</li>\n<li>《澳门风云3》</li>\n<li>《明日世界》</li>\n<li>《家和万事兴之我爱我车》</li>\n<li>《功夫熊猫3》</li>\n</ul>\n<h2 id=\"07月-2\"><a href=\"#07月-2\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《完美陌生人》</li>\n<li>《大鱼海棠》</li>\n<li>《六扇门》</li>\n<li>《安妮和王小明第二季》（书）</li>\n<li>《安妮和王小明第一季》（书）</li>\n<li>《妮玛！这就是大学！》（书）</li>\n<li>《妮玛的唠嗑馆》（书）</li>\n<li>《代码整洁之道》（书）</li>\n</ul>\n<h2 id=\"08月-2\"><a href=\"#08月-2\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《余罪 第一季》（连续剧）</li>\n<li>《一起同过窗》</li>\n<li>《三毛流浪记（漫画）》（书）</li>\n</ul>\n<h2 id=\"09月-2\"><a href=\"#09月-2\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《余罪 第二季》（连续剧）</li>\n<li>《One of Us》（连续剧）</li>\n<li>《龙珠Z：复活的F》</li>\n<li>《招魂2》</li>\n<li>《叶问3》</li>\n<li>《绝对小孩》（书）</li>\n<li>《小白理财第一课》（书）</li>\n<li>《人间失格》（书）</li>\n<li>《五次方谋杀》（书）</li>\n</ul>\n<h2 id=\"10月-2\"><a href=\"#10月-2\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《选老顶》</li>\n<li>《湄公河行动》</li>\n<li>《刑警兄弟》</li>\n<li>《送你一颗子弹》（书）</li>\n<li>《绝对小孩2》（书）</li>\n<li>《把时间当做朋友》（书）</li>\n<li>《嫌疑人X的献身》（书）</li>\n<li>《三观易碎》（书）</li>\n<li>《七堂极简物理课》（书）</li>\n</ul>\n<h2 id=\"11月-2\"><a href=\"#11月-2\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《荒岛余生》</li>\n<li>《不正常人类症候群》（书）</li>\n</ul>\n<h1 id=\"2015年\"><a href=\"#2015年\" class=\"headerlink\" title=\"2015年\"></a>2015年</h1><h2 id=\"01月-3\"><a href=\"#01月-3\" class=\"headerlink\" title=\"01月\"></a>01月</h2><ul>\n<li>《鹿鼎记2神龙教》</li>\n<li>《鹿鼎记》</li>\n<li>《源代码》</li>\n<li>《最佳出价》</li>\n<li>《智取威虎山》</li>\n<li>《恐怖直播》</li>\n<li>《宿敌》</li>\n<li>《在我入睡前》</li>\n<li>《名侦探柯南剧场版6 贝克街的亡灵》</li>\n<li>《十三度凶间》</li>\n<li>《牛奶可乐经济学》（书）</li>\n</ul>\n<h2 id=\"02月-3\"><a href=\"#02月-3\" class=\"headerlink\" title=\"02月\"></a>02月</h2><ul>\n<li>《爱情公寓4》（连续剧）</li>\n<li>《暴走恐怖故事第一季》（连续剧）</li>\n<li>《天降之物》（连续剧）</li>\n<li>《时空恋旅人》</li>\n<li>《无声言证》</li>\n<li>《地球回音》</li>\n<li>《十万个冷笑话电影》</li>\n<li>《匆匆那年》</li>\n<li>《Premature》</li>\n<li>《K-PAX》</li>\n</ul>\n<h2 id=\"03月-1\"><a href=\"#03月-1\" class=\"headerlink\" title=\"03月\"></a>03月</h2><ul>\n<li>《黑洞频率》</li>\n<li>《超能陆战队》</li>\n<li>《等一个人咖啡》</li>\n<li>《穹顶之下》</li>\n<li>《爆裂鼓手》</li>\n<li>《解忧杂货店》（书）</li>\n<li>《我的互联网方法论》（书）</li>\n</ul>\n<h2 id=\"04月-1\"><a href=\"#04月-1\" class=\"headerlink\" title=\"04月\"></a>04月</h2><ul>\n<li>《哆啦A梦：伴我同行》</li>\n</ul>\n<h2 id=\"05月-2\"><a href=\"#05月-2\" class=\"headerlink\" title=\"05月\"></a>05月</h2><ul>\n<li>《生人活祭》</li>\n<li>《伊甸湖》</li>\n</ul>\n<h2 id=\"06月-3\"><a href=\"#06月-3\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《名侦探狄仁杰》（连续剧）</li>\n<li>《附身》</li>\n<li>《澳门风云2》</li>\n<li>《海洋之歌》</li>\n<li>《左耳》</li>\n<li>《侏罗纪公园》</li>\n<li>《侏罗纪世界》</li>\n<li>《两个月亮》</li>\n</ul>\n<h2 id=\"07月-3\"><a href=\"#07月-3\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《速度与激情7》</li>\n<li>《煎饼侠》</li>\n<li>《捉妖记》</li>\n<li>《小森林·夏秋篇》</li>\n<li>《小森林·冬春篇》</li>\n<li>《名侦探柯南剧场版 异次元的狙击手》</li>\n<li>《五十度灰》</li>\n</ul>\n<h2 id=\"08月-3\"><a href=\"#08月-3\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《道士下山》</li>\n<li>《笑傲江湖》</li>\n<li>《笑傲江湖》（书）</li>\n</ul>\n<h2 id=\"09月-3\"><a href=\"#09月-3\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《港囧》</li>\n</ul>\n<h2 id=\"10月-3\"><a href=\"#10月-3\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《画江湖之不良人》（连续剧）</li>\n<li>《这个男人来自地球》</li>\n<li>《我是路人甲》</li>\n<li>《决战紫禁之巅》</li>\n<li>《Programming with Objective-C》（书）</li>\n</ul>\n<h2 id=\"11月-3\"><a href=\"#11月-3\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《夏洛特烦恼》</li>\n<li>《荒庙》（书）</li>\n<li>《暗时间》（书）</li>\n</ul>\n<h2 id=\"12月-1\"><a href=\"#12月-1\" class=\"headerlink\" title=\"12月\"></a>12月</h2><ul>\n<li>《西游记之大圣归来》</li>\n<li>《移动迷宫》</li>\n<li>《真实魔鬼游戏》</li>\n<li>《消失的凶手》</li>\n<li>《尘曲》（书）</li>\n</ul>\n<h1 id=\"2014年\"><a href=\"#2014年\" class=\"headerlink\" title=\"2014年\"></a>2014年</h1><h2 id=\"03月-2\"><a href=\"#03月-2\" class=\"headerlink\" title=\"03月\"></a>03月</h2><ul>\n<li>《死亡笔记》（连续剧）</li>\n</ul>\n<h2 id=\"04月-2\"><a href=\"#04月-2\" class=\"headerlink\" title=\"04月\"></a>04月</h2><ul>\n<li>《麦兜响当当》</li>\n<li>《零下一度》</li>\n<li>《逆光飞翔》</li>\n<li>《同桌的你》</li>\n<li>《古墓丽影2》</li>\n<li>《古墓丽影》</li>\n</ul>\n<h2 id=\"05月-3\"><a href=\"#05月-3\" class=\"headerlink\" title=\"05月\"></a>05月</h2><ul>\n<li>《麦兜故事》</li>\n<li>《警察故事2013》</li>\n<li>《潘金莲之前世今生》</li>\n<li>《你是下一个》</li>\n<li>《X战警：逆转未来》</li>\n<li>《百年孤独》（书）</li>\n<li>《C++程序设计》（书）</li>\n</ul>\n<h2 id=\"06月-4\"><a href=\"#06月-4\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《金刚狼Ⅱ》</li>\n<li>《金刚狼》</li>\n<li>《警察故事2013》</li>\n<li>《生死停留》</li>\n<li>《爆笑角斗士》</li>\n<li>《六福喜事》</li>\n<li>《X战警：第一战》</li>\n<li>《X战警Ⅲ》</li>\n<li>《X战警Ⅱ》</li>\n<li>《X战警Ⅰ》</li>\n<li>《杂的文》（书）</li>\n<li>《天才在左，疯子在右》（书）</li>\n<li>《三重门》（书）</li>\n<li>《c++基础教程》（书）</li>\n</ul>\n<h2 id=\"07月-4\"><a href=\"#07月-4\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《进击的巨人》（连续剧）</li>\n<li>《秒速5厘米》</li>\n<li>《狄仁杰之神都龙王》</li>\n<li>《澳门风云》</li>\n<li>《无人区》</li>\n<li>《后会无期》</li>\n<li>《变形金刚4：绝迹重生》</li>\n<li>《十二生肖》</li>\n</ul>\n<h2 id=\"08月-4\"><a href=\"#08月-4\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《志明与春娇》</li>\n</ul>\n<h2 id=\"09月-4\"><a href=\"#09月-4\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《绣春刀》</li>\n<li>《猩球崛起2》</li>\n<li>《春娇与志明》</li>\n<li>《明日边缘》</li>\n<li>《惊天魔盗团》</li>\n<li>《安德的游戏》</li>\n<li>《分歧者——异类崛起》</li>\n<li>《催眠大师》</li>\n</ul>\n<h2 id=\"10月-4\"><a href=\"#10月-4\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《生活启示录》（连续剧）</li>\n<li>《黑暗面》</li>\n<li>《那夜凌晨 我坐上旺角开往大埔的红van》</li>\n<li>《触不可及》</li>\n<li>《被偷走的那五年》</li>\n<li>《猎头游戏》</li>\n<li>《牯岭街少年杀人事件》</li>\n<li>《控方证人》</li>\n<li>《惊声尖叫》</li>\n<li>《归来》</li>\n<li>《四大名捕大结局》</li>\n<li>《决战猩球》</li>\n<li>《一级恐惧》</li>\n<li>《飞狐外传》（书）</li>\n<li>《平凡的世界Ⅲ》（书）</li>\n<li>《平凡的世界Ⅱ》（书）</li>\n<li>《平凡的世界Ⅰ》（书）</li>\n</ul>\n<h2 id=\"11月-4\"><a href=\"#11月-4\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《魔女嘉莉》</li>\n<li>《鬼子来了》</li>\n<li>《银河护卫队》</li>\n<li>《透明人2》</li>\n<li>《透明人》</li>\n<li>《林中小屋》</li>\n<li>《极速前进》</li>\n<li>《心花路放》</li>\n<li>《彗星来的那一夜》</li>\n<li>《寒战》</li>\n<li>《失踪罪》</li>\n<li>《太阳照常升起》</li>\n<li>《哆啦A梦：新·大雄的大魔境》</li>\n<li>《十七岁的单车》</li>\n<li>《侧耳倾听》</li>\n<li>《The One I Love》</li>\n<li>《In Your Eyes》</li>\n<li>《连城诀》（书）</li>\n<li>《沙僧吐槽日记》（书）</li>\n<li>《早晨从中午开始》（书）</li>\n<li>《大地飞鹰》（书）</li>\n<li>《一个人的好天气》（书）</li>\n<li>《1988——我想和这个世界谈谈》（书）</li>\n</ul>\n<h2 id=\"12月-2\"><a href=\"#12月-2\" class=\"headerlink\" title=\"12月\"></a>12月</h2><ul>\n<li>《黄飞鸿之英雄有梦》</li>\n<li>《麦兜菠萝油王子》</li>\n<li>《马达加斯加的企鹅》</li>\n<li>《超体》</li>\n<li>《楚留香传奇之大沙漠》</li>\n<li>《极速前进》</li>\n<li>《月亮》</li>\n<li>《星际穿越》</li>\n<li>《新大头儿子和小头爸爸之秘密计划》</li>\n<li>《弹窗惊魂》</li>\n<li>《名侦探柯南剧场版1 引爆摩天楼》</li>\n<li>《刺杀金正恩》</li>\n<li>《关于时间旅行的热门问题》</li>\n<li>《不惧风暴》</li>\n<li>《一步之遥》</li>\n<li>《一个人的武林》</li>\n<li>《The Giver》</li>\n<li>《理科的人Ⅰ》（书）</li>\n<li>《楚留香传奇之血海飘香》（书）</li>\n<li>《楚留香传奇之画眉鸟》（书）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2018年\"><a href=\"#2018年\" class=\"headerlink\" title=\"2018年\"></a>2018年</h1><h2 id=\"01月\"><a href=\"#01月\" class=\"headerlink\" title=\"01月\"></a>01月</h2><ul>\n<li>《神秘巨星》</li>\n<li>《无问西东》</li>\n<li>《奇门遁甲》</li>\n</ul>\n<h2 id=\"02月\"><a href=\"#02月\" class=\"headerlink\" title=\"02月\"></a>02月</h2><ul>\n<li>《唐人街探案2》</li>\n<li>《活着本来单纯》（书）</li>\n</ul>\n<h2 id=\"04月\"><a href=\"#04月\" class=\"headerlink\" title=\"04月\"></a>04月</h2><ul>\n<li>《起跑线》</li>\n</ul>\n<h2 id=\"05月\"><a href=\"#05月\" class=\"headerlink\" title=\"05月\"></a>05月</h2><ul>\n<li>《罪途》</li>\n<li>《寻梦环游记》</li>\n</ul>\n<h2 id=\"06月\"><a href=\"#06月\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《活着》（书）</li>\n<li>《倚天屠龙记》（书）</li>\n</ul>\n<h2 id=\"07月\"><a href=\"#07月\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《我不是药神》</li>\n</ul>\n<h2 id=\"08月\"><a href=\"#08月\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《爸，我一定行的》</li>\n<li>《小王子》（书）</li>\n<li>《人之岛》（书）</li>\n<li>《厕所英雄》</li>\n</ul>\n<h2 id=\"09月\"><a href=\"#09月\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《碟中谍6》</li>\n<li>《传奇的诞生》</li>\n</ul>\n<h2 id=\"10月\"><a href=\"#10月\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《地心引力》</li>\n<li>《月亮与六便士》（书）</li>\n<li>《杜月笙全传》（书）</li>\n<li>《一起同过窗2》（连续剧）</li>\n<li>《嗝嗝老师》</li>\n<li>《MacTalk跨越边界》（书）</li>\n<li>《李茶的姑妈》</li>\n<li>《名侦探柯南剧场版11_绀碧之棺》</li>\n</ul>\n<h2 id=\"11月\"><a href=\"#11月\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《动物凶猛》（书）</li>\n<li>《谍影重重》</li>\n<li>《哈利波特与密室》</li>\n<li>《狙击电话亭》</li>\n<li>《毒液：致命守护者》</li>\n<li>《西虹市首富》</li>\n</ul>\n<h1 id=\"2017年\"><a href=\"#2017年\" class=\"headerlink\" title=\"2017年\"></a>2017年</h1><h2 id=\"01月-1\"><a href=\"#01月-1\" class=\"headerlink\" title=\"01月\"></a>01月</h2><ul>\n<li>《鲨滩》</li>\n<li>《西游伏妖篇》</li>\n<li>《乘风破浪》</li>\n<li>《三少爷的剑》</li>\n</ul>\n<h2 id=\"02月-1\"><a href=\"#02月-1\" class=\"headerlink\" title=\"02月\"></a>02月</h2><ul>\n<li>《你的名字》</li>\n</ul>\n<h2 id=\"06月-1\"><a href=\"#06月-1\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《非暴力沟通》（书）</li>\n</ul>\n<h2 id=\"07月-1\"><a href=\"#07月-1\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《悟空传》</li>\n<li>《小黄人3》</li>\n<li>《嫌疑人x的献身》</li>\n<li>《假面饭店》</li>\n</ul>\n<h2 id=\"08月-1\"><a href=\"#08月-1\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《战狼2》</li>\n</ul>\n<h2 id=\"09月-1\"><a href=\"#09月-1\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《目击者之追凶》</li>\n<li>《猩球崛起3》</li>\n<li>《太空旅客》</li>\n<li>《时光倒流的女孩》（书）</li>\n</ul>\n<h2 id=\"10月-1\"><a href=\"#10月-1\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《羞羞的铁拳》</li>\n<li>《看不见的客人》</li>\n<li>《天才枪手》</li>\n</ul>\n<h2 id=\"11月-1\"><a href=\"#11月-1\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《缝纫机乐队》</li>\n<li>《地球脉动2》</li>\n<li>《哈利波特与魔法石》</li>\n</ul>\n<h2 id=\"12月\"><a href=\"#12月\" class=\"headerlink\" title=\"12月\"></a>12月</h2><ul>\n<li>《解忧杂货店》</li>\n<li>《少有人走的路》（书）</li>\n</ul>\n<h1 id=\"2016年\"><a href=\"#2016年\" class=\"headerlink\" title=\"2016年\"></a>2016年</h1><h2 id=\"01月-2\"><a href=\"#01月-2\" class=\"headerlink\" title=\"01月\"></a>01月</h2><ul>\n<li>《枭雄》（连续剧）</li>\n<li>《心迷宫》</li>\n<li>《像素大战》</li>\n<li>《亲爱的》</li>\n<li>《越女剑》（书）</li>\n</ul>\n<h2 id=\"02月-2\"><a href=\"#02月-2\" class=\"headerlink\" title=\"02月\"></a>02月</h2><ul>\n<li>《赌侠大战拉斯维加斯》</li>\n<li>《荒蛮故事》</li>\n<li>《美人鱼》</li>\n<li>《火星救援》</li>\n<li>《扑克王》</li>\n<li>《我的少女时代》</li>\n<li>《国产凌凌漆》</li>\n<li>《时间的朋友2015》（书）</li>\n</ul>\n<h2 id=\"03月\"><a href=\"#03月\" class=\"headerlink\" title=\"03月\"></a>03月</h2><ul>\n<li>《伟大的隐藏者》</li>\n</ul>\n<h2 id=\"05月-1\"><a href=\"#05月-1\" class=\"headerlink\" title=\"05月\"></a>05月</h2><ul>\n<li>《信号》（连续剧）</li>\n<li>《美国队长3》</li>\n<li>《火锅英雄》</li>\n<li>《乒乓侠》</li>\n</ul>\n<h2 id=\"06月-2\"><a href=\"#06月-2\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《独立日2》</li>\n<li>《澳门风云3》</li>\n<li>《明日世界》</li>\n<li>《家和万事兴之我爱我车》</li>\n<li>《功夫熊猫3》</li>\n</ul>\n<h2 id=\"07月-2\"><a href=\"#07月-2\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《完美陌生人》</li>\n<li>《大鱼海棠》</li>\n<li>《六扇门》</li>\n<li>《安妮和王小明第二季》（书）</li>\n<li>《安妮和王小明第一季》（书）</li>\n<li>《妮玛！这就是大学！》（书）</li>\n<li>《妮玛的唠嗑馆》（书）</li>\n<li>《代码整洁之道》（书）</li>\n</ul>\n<h2 id=\"08月-2\"><a href=\"#08月-2\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《余罪 第一季》（连续剧）</li>\n<li>《一起同过窗》</li>\n<li>《三毛流浪记（漫画）》（书）</li>\n</ul>\n<h2 id=\"09月-2\"><a href=\"#09月-2\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《余罪 第二季》（连续剧）</li>\n<li>《One of Us》（连续剧）</li>\n<li>《龙珠Z：复活的F》</li>\n<li>《招魂2》</li>\n<li>《叶问3》</li>\n<li>《绝对小孩》（书）</li>\n<li>《小白理财第一课》（书）</li>\n<li>《人间失格》（书）</li>\n<li>《五次方谋杀》（书）</li>\n</ul>\n<h2 id=\"10月-2\"><a href=\"#10月-2\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《选老顶》</li>\n<li>《湄公河行动》</li>\n<li>《刑警兄弟》</li>\n<li>《送你一颗子弹》（书）</li>\n<li>《绝对小孩2》（书）</li>\n<li>《把时间当做朋友》（书）</li>\n<li>《嫌疑人X的献身》（书）</li>\n<li>《三观易碎》（书）</li>\n<li>《七堂极简物理课》（书）</li>\n</ul>\n<h2 id=\"11月-2\"><a href=\"#11月-2\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《荒岛余生》</li>\n<li>《不正常人类症候群》（书）</li>\n</ul>\n<h1 id=\"2015年\"><a href=\"#2015年\" class=\"headerlink\" title=\"2015年\"></a>2015年</h1><h2 id=\"01月-3\"><a href=\"#01月-3\" class=\"headerlink\" title=\"01月\"></a>01月</h2><ul>\n<li>《鹿鼎记2神龙教》</li>\n<li>《鹿鼎记》</li>\n<li>《源代码》</li>\n<li>《最佳出价》</li>\n<li>《智取威虎山》</li>\n<li>《恐怖直播》</li>\n<li>《宿敌》</li>\n<li>《在我入睡前》</li>\n<li>《名侦探柯南剧场版6 贝克街的亡灵》</li>\n<li>《十三度凶间》</li>\n<li>《牛奶可乐经济学》（书）</li>\n</ul>\n<h2 id=\"02月-3\"><a href=\"#02月-3\" class=\"headerlink\" title=\"02月\"></a>02月</h2><ul>\n<li>《爱情公寓4》（连续剧）</li>\n<li>《暴走恐怖故事第一季》（连续剧）</li>\n<li>《天降之物》（连续剧）</li>\n<li>《时空恋旅人》</li>\n<li>《无声言证》</li>\n<li>《地球回音》</li>\n<li>《十万个冷笑话电影》</li>\n<li>《匆匆那年》</li>\n<li>《Premature》</li>\n<li>《K-PAX》</li>\n</ul>\n<h2 id=\"03月-1\"><a href=\"#03月-1\" class=\"headerlink\" title=\"03月\"></a>03月</h2><ul>\n<li>《黑洞频率》</li>\n<li>《超能陆战队》</li>\n<li>《等一个人咖啡》</li>\n<li>《穹顶之下》</li>\n<li>《爆裂鼓手》</li>\n<li>《解忧杂货店》（书）</li>\n<li>《我的互联网方法论》（书）</li>\n</ul>\n<h2 id=\"04月-1\"><a href=\"#04月-1\" class=\"headerlink\" title=\"04月\"></a>04月</h2><ul>\n<li>《哆啦A梦：伴我同行》</li>\n</ul>\n<h2 id=\"05月-2\"><a href=\"#05月-2\" class=\"headerlink\" title=\"05月\"></a>05月</h2><ul>\n<li>《生人活祭》</li>\n<li>《伊甸湖》</li>\n</ul>\n<h2 id=\"06月-3\"><a href=\"#06月-3\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《名侦探狄仁杰》（连续剧）</li>\n<li>《附身》</li>\n<li>《澳门风云2》</li>\n<li>《海洋之歌》</li>\n<li>《左耳》</li>\n<li>《侏罗纪公园》</li>\n<li>《侏罗纪世界》</li>\n<li>《两个月亮》</li>\n</ul>\n<h2 id=\"07月-3\"><a href=\"#07月-3\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《速度与激情7》</li>\n<li>《煎饼侠》</li>\n<li>《捉妖记》</li>\n<li>《小森林·夏秋篇》</li>\n<li>《小森林·冬春篇》</li>\n<li>《名侦探柯南剧场版 异次元的狙击手》</li>\n<li>《五十度灰》</li>\n</ul>\n<h2 id=\"08月-3\"><a href=\"#08月-3\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《道士下山》</li>\n<li>《笑傲江湖》</li>\n<li>《笑傲江湖》（书）</li>\n</ul>\n<h2 id=\"09月-3\"><a href=\"#09月-3\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《港囧》</li>\n</ul>\n<h2 id=\"10月-3\"><a href=\"#10月-3\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《画江湖之不良人》（连续剧）</li>\n<li>《这个男人来自地球》</li>\n<li>《我是路人甲》</li>\n<li>《决战紫禁之巅》</li>\n<li>《Programming with Objective-C》（书）</li>\n</ul>\n<h2 id=\"11月-3\"><a href=\"#11月-3\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《夏洛特烦恼》</li>\n<li>《荒庙》（书）</li>\n<li>《暗时间》（书）</li>\n</ul>\n<h2 id=\"12月-1\"><a href=\"#12月-1\" class=\"headerlink\" title=\"12月\"></a>12月</h2><ul>\n<li>《西游记之大圣归来》</li>\n<li>《移动迷宫》</li>\n<li>《真实魔鬼游戏》</li>\n<li>《消失的凶手》</li>\n<li>《尘曲》（书）</li>\n</ul>\n<h1 id=\"2014年\"><a href=\"#2014年\" class=\"headerlink\" title=\"2014年\"></a>2014年</h1><h2 id=\"03月-2\"><a href=\"#03月-2\" class=\"headerlink\" title=\"03月\"></a>03月</h2><ul>\n<li>《死亡笔记》（连续剧）</li>\n</ul>\n<h2 id=\"04月-2\"><a href=\"#04月-2\" class=\"headerlink\" title=\"04月\"></a>04月</h2><ul>\n<li>《麦兜响当当》</li>\n<li>《零下一度》</li>\n<li>《逆光飞翔》</li>\n<li>《同桌的你》</li>\n<li>《古墓丽影2》</li>\n<li>《古墓丽影》</li>\n</ul>\n<h2 id=\"05月-3\"><a href=\"#05月-3\" class=\"headerlink\" title=\"05月\"></a>05月</h2><ul>\n<li>《麦兜故事》</li>\n<li>《警察故事2013》</li>\n<li>《潘金莲之前世今生》</li>\n<li>《你是下一个》</li>\n<li>《X战警：逆转未来》</li>\n<li>《百年孤独》（书）</li>\n<li>《C++程序设计》（书）</li>\n</ul>\n<h2 id=\"06月-4\"><a href=\"#06月-4\" class=\"headerlink\" title=\"06月\"></a>06月</h2><ul>\n<li>《金刚狼Ⅱ》</li>\n<li>《金刚狼》</li>\n<li>《警察故事2013》</li>\n<li>《生死停留》</li>\n<li>《爆笑角斗士》</li>\n<li>《六福喜事》</li>\n<li>《X战警：第一战》</li>\n<li>《X战警Ⅲ》</li>\n<li>《X战警Ⅱ》</li>\n<li>《X战警Ⅰ》</li>\n<li>《杂的文》（书）</li>\n<li>《天才在左，疯子在右》（书）</li>\n<li>《三重门》（书）</li>\n<li>《c++基础教程》（书）</li>\n</ul>\n<h2 id=\"07月-4\"><a href=\"#07月-4\" class=\"headerlink\" title=\"07月\"></a>07月</h2><ul>\n<li>《进击的巨人》（连续剧）</li>\n<li>《秒速5厘米》</li>\n<li>《狄仁杰之神都龙王》</li>\n<li>《澳门风云》</li>\n<li>《无人区》</li>\n<li>《后会无期》</li>\n<li>《变形金刚4：绝迹重生》</li>\n<li>《十二生肖》</li>\n</ul>\n<h2 id=\"08月-4\"><a href=\"#08月-4\" class=\"headerlink\" title=\"08月\"></a>08月</h2><ul>\n<li>《志明与春娇》</li>\n</ul>\n<h2 id=\"09月-4\"><a href=\"#09月-4\" class=\"headerlink\" title=\"09月\"></a>09月</h2><ul>\n<li>《绣春刀》</li>\n<li>《猩球崛起2》</li>\n<li>《春娇与志明》</li>\n<li>《明日边缘》</li>\n<li>《惊天魔盗团》</li>\n<li>《安德的游戏》</li>\n<li>《分歧者——异类崛起》</li>\n<li>《催眠大师》</li>\n</ul>\n<h2 id=\"10月-4\"><a href=\"#10月-4\" class=\"headerlink\" title=\"10月\"></a>10月</h2><ul>\n<li>《生活启示录》（连续剧）</li>\n<li>《黑暗面》</li>\n<li>《那夜凌晨 我坐上旺角开往大埔的红van》</li>\n<li>《触不可及》</li>\n<li>《被偷走的那五年》</li>\n<li>《猎头游戏》</li>\n<li>《牯岭街少年杀人事件》</li>\n<li>《控方证人》</li>\n<li>《惊声尖叫》</li>\n<li>《归来》</li>\n<li>《四大名捕大结局》</li>\n<li>《决战猩球》</li>\n<li>《一级恐惧》</li>\n<li>《飞狐外传》（书）</li>\n<li>《平凡的世界Ⅲ》（书）</li>\n<li>《平凡的世界Ⅱ》（书）</li>\n<li>《平凡的世界Ⅰ》（书）</li>\n</ul>\n<h2 id=\"11月-4\"><a href=\"#11月-4\" class=\"headerlink\" title=\"11月\"></a>11月</h2><ul>\n<li>《魔女嘉莉》</li>\n<li>《鬼子来了》</li>\n<li>《银河护卫队》</li>\n<li>《透明人2》</li>\n<li>《透明人》</li>\n<li>《林中小屋》</li>\n<li>《极速前进》</li>\n<li>《心花路放》</li>\n<li>《彗星来的那一夜》</li>\n<li>《寒战》</li>\n<li>《失踪罪》</li>\n<li>《太阳照常升起》</li>\n<li>《哆啦A梦：新·大雄的大魔境》</li>\n<li>《十七岁的单车》</li>\n<li>《侧耳倾听》</li>\n<li>《The One I Love》</li>\n<li>《In Your Eyes》</li>\n<li>《连城诀》（书）</li>\n<li>《沙僧吐槽日记》（书）</li>\n<li>《早晨从中午开始》（书）</li>\n<li>《大地飞鹰》（书）</li>\n<li>《一个人的好天气》（书）</li>\n<li>《1988——我想和这个世界谈谈》（书）</li>\n</ul>\n<h2 id=\"12月-2\"><a href=\"#12月-2\" class=\"headerlink\" title=\"12月\"></a>12月</h2><ul>\n<li>《黄飞鸿之英雄有梦》</li>\n<li>《麦兜菠萝油王子》</li>\n<li>《马达加斯加的企鹅》</li>\n<li>《超体》</li>\n<li>《楚留香传奇之大沙漠》</li>\n<li>《极速前进》</li>\n<li>《月亮》</li>\n<li>《星际穿越》</li>\n<li>《新大头儿子和小头爸爸之秘密计划》</li>\n<li>《弹窗惊魂》</li>\n<li>《名侦探柯南剧场版1 引爆摩天楼》</li>\n<li>《刺杀金正恩》</li>\n<li>《关于时间旅行的热门问题》</li>\n<li>《不惧风暴》</li>\n<li>《一步之遥》</li>\n<li>《一个人的武林》</li>\n<li>《The Giver》</li>\n<li>《理科的人Ⅰ》（书）</li>\n<li>《楚留香传奇之血海飘香》（书）</li>\n<li>《楚留香传奇之画眉鸟》（书）</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjp2opl310001u3qw8u3lr9dl","category_id":"cjp2opl360005u3qww4s8qdnc","_id":"cjp2opl3c000cu3qw00tnvjoy"},{"post_id":"cjp2opl3a000au3qwpg2z7r78","category_id":"cjp2opl390009u3qwkftjryt7","_id":"cjp2opl3f000gu3qw4hly5jlz"},{"post_id":"cjp2opl340003u3qw67l5ultn","category_id":"cjp2opl390009u3qwkftjryt7","_id":"cjp2opl3g000ju3qwcsyq2arm"},{"post_id":"cjp2opl3b000bu3qwvjwcjk39","category_id":"cjp2opl390009u3qwkftjryt7","_id":"cjp2opl3h000lu3qw7lmc96vo"},{"post_id":"cjp2opl3d000eu3qw7djtpb9v","category_id":"cjp2opl360005u3qww4s8qdnc","_id":"cjp2opl3i000ou3qwzv5p7toc"},{"post_id":"cjp2opl370006u3qws05vhiw6","category_id":"cjp2opl390009u3qwkftjryt7","_id":"cjp2opl3i000qu3qw5qx9yp12"},{"post_id":"cjp2opl3e000fu3qwg2xhjklt","category_id":"cjp2opl390009u3qwkftjryt7","_id":"cjp2opl3j000tu3qwac5u0lji"},{"post_id":"cjp2opl380007u3qwt49l9d7z","category_id":"cjp2opl3f000hu3qwcdww9fgv","_id":"cjp2opl3k000vu3qwyz2fzreh"},{"post_id":"cjp2opl3g000ku3qwaq9hva23","category_id":"cjp2opl390009u3qwkftjryt7","_id":"cjp2opl3l000yu3qwk6bq51v6"},{"post_id":"cjp2opl3h000nu3qwadpeh32v","category_id":"cjp2opl360005u3qww4s8qdnc","_id":"cjp2opl3m0010u3qwn0veugx3"},{"post_id":"cjp2opl390008u3qwsnjxk6l7","category_id":"cjp2opl390009u3qwkftjryt7","_id":"cjp2opl3m0011u3qwx3hgtqp5"},{"post_id":"cjp2opl3f000iu3qwan6ahp26","category_id":"cjp2opl3j000ru3qw29dgrpz3","_id":"cjp2opl3n0013u3qwztskxruu"},{"post_id":"cjp2opl3k000uu3qwelimv166","category_id":"cjp2opl3f000hu3qwcdww9fgv","_id":"cjp2opl3n0014u3qwm53pd1uq"},{"post_id":"cjp2opl3i000pu3qwyydmvas3","category_id":"cjp2opl3k000wu3qw00l3lv2d","_id":"cjp2opl3n0016u3qwsuoszs51"},{"post_id":"cjp2opl3j000su3qwy4q02ctg","category_id":"cjp2opl3k000wu3qw00l3lv2d","_id":"cjp2opl3n0018u3qw0ukrnizg"},{"post_id":"cjp2opl3l000xu3qwb2x4arib","category_id":"cjp2opl3k000wu3qw00l3lv2d","_id":"cjp2opl3o0019u3qw2wuqbu1y"},{"post_id":"cjp2opl3l000zu3qwgg6u28vh","category_id":"cjp2opl3n0017u3qwcdp9pv6m","_id":"cjp2opl3o001au3qw2bdhqzq0"}],"PostTag":[],"Tag":[]}}