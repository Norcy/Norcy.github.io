{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/view.jpg","path":"images/view.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/girl.jpg","path":"images/girl.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"source/images/girl2.jpg","path":"images/girl2.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"1688d33f93ffb280a9a74e8f3568150c0f862de6","modified":1519612575000},{"_id":"themes/next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1513503305000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1513503305000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1513503305000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1513503305000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1513503305000},{"_id":"themes/next/_config.yml","hash":"c0cafff60695d042abec85594907757b57bc46ae","modified":1519890756000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1513503305000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1513503305000},{"_id":"themes/next/bower.json","hash":"d7f8d4eb7c6ac1bb8d642112601005f93e3da49b","modified":1513503305000},{"_id":"themes/next/README.md","hash":"0b709591995001cd860384d6c189e51d91690714","modified":1513503305000},{"_id":"themes/next/gulpfile.coffee","hash":"b3d53f36460119c741a98c0dc494b1c65d3ec943","modified":1513503305000},{"_id":"themes/next/package.json","hash":"bd016b54983b7e06a649ee915b2e13a60d47553e","modified":1513503305000},{"_id":"source/_posts/2016-01-27-Reading-List.md","hash":"b28872cfb7b37f058e0bf8543fdd8619c4ab3745","modified":1513503305000},{"_id":"source/_posts/ARC MRC 调用未声明方法.md","hash":"7ae840ea8381fa83e6ed534ffb52190d9427c87a","modified":1513503305000},{"_id":"source/_posts/Effective-Objective-C-读书笔记.md","hash":"11594bf29556d66ca6ef9c3ab582079ee8ae49a3","modified":1513503305000},{"_id":"source/_posts/NSTimer 会保留目标对象.md","hash":"0b2170b7fc447c9c78de0eca86d38596e365b04f","modified":1513503305000},{"_id":"source/_posts/NSUserdefaults与NSMutableArray的坑.md","hash":"8ddcf9cb687b0c82a56bf0b9f3fde802b790ad1f","modified":1513503305000},{"_id":"source/_posts/Objective-C中的消息转发机制.md","hash":"d974838dbe9a6c2ce6c51b35fa076833f70b6a9f","modified":1513503305000},{"_id":"source/_posts/UITableView 中，UICollectionView 相互复用之间 contentOffset.md","hash":"b8328c7e4c84ce33ca54b435f3524797086c48fa","modified":1513503305000},{"_id":"source/_posts/iOS技能树.md","hash":"8d62a3bb23f0e5a7af6b479aa7954985fe2b7f86","modified":1513503305000},{"_id":"source/_posts/iOS的单例模式与多线程安全.md","hash":"2053c92edbd96b7e91edc25a50a12f084ee2b5a9","modified":1513503305000},{"_id":"source/_posts/关于Objective-C中的BOOL你所要知道的.md","hash":"e26d2bea2ecdea7827d2526863ca9002af2c4d91","modified":1513503305000},{"_id":"source/_posts/同步、异步、阻塞、非阻塞的简单理解.md","hash":"acdb3dc06334a7adc7214644714882cacb5a4730","modified":1513503305000},{"_id":"source/_posts/如何用iPad在床上优雅的看大片.md","hash":"a6f9b11b38702054e361c8478079d2fccd8553f1","modified":1513503305000},{"_id":"source/_posts/神在细节之中.md","hash":"ea53392153fde66a1d64009111314e199f014460","modified":1513503305000},{"_id":"source/about/index.md","hash":"351c21ee98ceb27e26a0d3feb59c3be80a6348e4","modified":1513503305000},{"_id":"source/categories/index.md","hash":"e490c8ff8bdc5480c9315508a1e1b28234fd26cf","modified":1513503305000},{"_id":"source/_posts/那些年，我看过的.md","hash":"a0b1c4182eebff3f99ccd9e677ad7ccfaf90d093","modified":1519612614000},{"_id":"source/tags/index.md","hash":"691cc939ea1b75415995c4beea4e431a71cd92be","modified":1513503305000},{"_id":"source/images/view.jpg","hash":"a7b69856e3d241eec549632515c6e7dc16e378c1","modified":1513503305000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1513503305000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1513503305000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1513503305000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1513503305000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1513503305000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1513503305000},{"_id":"themes/next/layout/_layout.swig","hash":"60ea575c328d7e70260a495818c892b7d23362cf","modified":1519887857000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f27c779da54c55bbf9cea8bd98d1707a69a0e8ea","modified":1513503305000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1513503305000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1513503305000},{"_id":"themes/next/layout/archive.swig","hash":"3b8b08b802c6fc953a33489a0e3b9327f068dde7","modified":1513503305000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1513503305000},{"_id":"themes/next/layout/index.swig","hash":"d2fb59f9c589333d578de97483d87800e2c65568","modified":1513503305000},{"_id":"themes/next/layout/index_backup.swig","hash":"38b1ad401b748965369296b86327d23082a1fe93","modified":1513503305000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1513503305000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1513503305000},{"_id":"themes/next/layout/post.swig","hash":"f32dd1095f4fbee494a86893856dc7cc6329e293","modified":1513503305000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1513503305000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1513503305000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1513503305000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1513503305000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1513503305000},{"_id":"themes/next/layout/_macro/post.swig","hash":"c099532fe99c0befd537cf9ea304f2bdb2597651","modified":1513503305000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"82a9bc2ba60ce68419128ff60624bd74b15dfb78","modified":1513503305000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"44cc089c111d7a9df7844affa980e56edd276bf1","modified":1513503305000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"3003fda5a8af553451f7945f4e1ce006ca72e4c4","modified":1513503305000},{"_id":"themes/next/layout/_partials/head.swig","hash":"7edcc47b01b60e565b39b2baf3a87c20b61c7eaf","modified":1513503305000},{"_id":"themes/next/layout/_partials/header.swig","hash":"4286af7fe6eeab974e52d704a28290e7c7ed5490","modified":1513503305000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1513503305000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1513503305000},{"_id":"themes/next/layout/_partials/search.swig","hash":"64f14da26792a17bc27836c4e9d83190175f36e6","modified":1513503305000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1513503305000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1513503305000},{"_id":"themes/next/scripts/filters/sticky.js","hash":"6b1ea0c09105352813357d0fff4e1d3f4c821fa3","modified":1513503305000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f12d7b0946d37853caa29009e6d134c2a378ad20","modified":1513503305000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1513503305000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1513503305000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1513503305000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1513503305000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1513503305000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1513503305000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1513503305000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1513503305000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1513503305000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1513503305000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1513503305000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513503305000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513503305000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1513503305000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1513503305000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1513503305000},{"_id":"source/images/girl.jpg","hash":"195786b13bb6264e22541aec1a437b90c739213f","modified":1513503305000},{"_id":"themes/next/layout/_scripts/bootstrap/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513503305000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1513503305000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1513503305000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1513503305000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1513503305000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1513503305000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"2b8f8c63abfcc805fad42b1c174cf61b6233d345","modified":1513503305000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"d79bd946f07b83b47926dd67bb9d40e652b94769","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/baidushare.swig","hash":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"2fc4a0d2c825a512f39c0eadd78452e90615465a","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"df03220eb8526e17dc9c9f17780c2d6699367181","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1513503305000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3e619449787d3caca07d62d59dc589e6d1c6cc7b","modified":1513503305000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1513503305000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1513503305000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1513503305000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"1da6bab5b8af093a319726d1e93ddd922161f584","modified":1513503305000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"e6488372eacb4c8acbda42ed366e27a6de7693d4","modified":1513503305000},{"_id":"themes/next/source/css/_variables/default.styl","hash":"6728c0b82f9a5a24c7a7fa8c9f00dedbe9508bef","modified":1513503305000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1513503305000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"cca1fe42d49d3946f44b6ef1b247175f16ba796c","modified":1513503305000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1513503305000},{"_id":"themes/next/source/js/src/motion.js","hash":"a3d2eeeed8edecbeab35fe0bca1222874120b974","modified":1513503305000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1513503305000},{"_id":"themes/next/source/js/src/utils.js","hash":"7eb00abf9bc14516463d9f29db41805e808a565c","modified":1513503305000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1513503305000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1513503305000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1513503305000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1513503305000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1513503305000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1513503305000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1513503305000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1513503305000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1513503305000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1513503305000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1513503305000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1513503305000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1513503305000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1513503305000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1513503305000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1513503305000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1513503305000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"fa2b7a0006b6c447fa025474f8e0af4e4e569a36","modified":1513503305000},{"_id":"themes/next/source/css/_common/_section/header.styl","hash":"a6aa8a56f9f645ae5a76a1034f79adf73b053aa0","modified":1513503305000},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","hash":"54ef223d6683ad9ed21b24e8091c4dd63001316f","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"8d9b0f37cf0cd1c25e36303041406a8c72caf766","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1513503305000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7570bfb7d3ca51c04ab7e09abcb3b46016785391","modified":1513503305000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4ecc0501f715f8823d3be1df2a85ba1512cf380c","modified":1513503305000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"2432b833add17ddd35aad098bf300d3f951375d2","modified":1513503305000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1513503305000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1513503305000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"5f766cf26f966dbf9dcfe681f40ab9032e3e8a08","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"d50c2a9ae363d26ed2e9bc226a9dc7abeb9ace1b","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"1631a430655eadb485574d1a9bedd49460988b11","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"5a8036fc61207ca0fe38c9782ed2f686fbf764be","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"fc7d96b897290dbd93bc8c515a2058fc4c374ea7","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"36d707098100abd1ded76a2d016d8c95691b2420","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"159464cb8a7e01e32db9ec70dec391ec70a72f9c","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"eb4f5a0ae12b67d5e9b24056ec5715d03deda856","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"42b08217ac7264cde7e4b72fde025a936a8f90c4","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"dcbfef1c76288620f7f405a7aeba893d458d5b6a","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"a4366f6b71079119e5b72ece52df0c6af8961ce2","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1513503305000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1513503305000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1513503305000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"94f935331995bfeadf1084fb8f0665ab39fd1c8d","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1513503305000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1513503305000},{"_id":"source/images/girl2.jpg","hash":"5a19566bf07cc23517be384b87f70c93a3a62e98","modified":1513503305000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1513503305000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1513503305000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"5d189b059c0a475917d771b349582dacdd575951","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"61763d236029d2a4414be499d0e65d7dfb34605b","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"6242be4307a3b3dafc14e556f51c8875c41a1ddd","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"23dd966324937deeccc8f5fa16a6d32e4e46243b","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"fe71e9be08cb418cf68352fd6212ddd0d7150579","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"719e09bb2e8fb82183381fadb0708aa761f1e0b4","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"330a2ce52c5a5fefc1e85c473113a3bc58210c76","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"5c415dc8efab7c1bdeffacafa3100d1da6628b03","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"99d994bd19895a4aaa2fa8d12801ec72dd3cf118","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"01db9373cd13c1aec840205c622064dd6ae03361","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"89fef1caf94caf76ca09c643b83b0b4d4e417e08","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"6533563b34241e5c73da68156aba89e880b93f53","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"1099b5d07a60d93dad6221677c60cba60a82266b","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"0fcc3381927fbc7e5b2e30f3cccec331d9963d2b","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1513503305000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"c946b642bccc7a73c471bf6f119e40f54d0f1663","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1513503305000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1513503305000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1513503305000},{"_id":"public/about/index.html","hash":"cac7c9d1c2808b824acbc4a44bc4279f54607a67","modified":1519890772045},{"_id":"public/categories/index.html","hash":"8a31a3ac6ada868c66c8c100772f62d19635f301","modified":1519890772045},{"_id":"public/tags/index.html","hash":"96d3003d9f682b82d8dd56963d70746bbf516cc0","modified":1519890772045},{"_id":"public/archives/page/2/index.html","hash":"528d369bb938a189f58319b89b2b30325e58e26e","modified":1519890772045},{"_id":"public/archives/2013/index.html","hash":"3ced22228a5949dba5e708bc4600c56bdbcd784f","modified":1519890772045},{"_id":"public/archives/2013/03/index.html","hash":"ba8cc8ff1a8b51726339852eed146cae11e94950","modified":1519890772045},{"_id":"public/archives/2016/index.html","hash":"c894df8956b7788bba87efe42894901c78cbedb1","modified":1519890772045},{"_id":"public/archives/2016/page/2/index.html","hash":"f2924a2fad68c6397e688ccac2c9cb8582fc0122","modified":1519890772045},{"_id":"public/archives/2016/01/index.html","hash":"b5007928d1869d217e8097c37fb8d62d6579697d","modified":1519890772045},{"_id":"public/archives/2016/02/index.html","hash":"b6cf9c054cda2a30e889a83226fe0cb05815ae80","modified":1519890772045},{"_id":"public/archives/2016/03/index.html","hash":"9839a2a9fd22181faa047d9d1b0c77139206cd3d","modified":1519890772045},{"_id":"public/archives/2016/06/index.html","hash":"f2beba88bf446becccb09886d32d3b4b1ceece09","modified":1519890772045},{"_id":"public/archives/2016/07/index.html","hash":"a861423be14525f19add24c42f7fe953e0a504ca","modified":1519890772046},{"_id":"public/archives/2016/08/index.html","hash":"a84c4f9f55812c41fbf283859cbf1c3839932717","modified":1519890772046},{"_id":"public/archives/2016/09/index.html","hash":"055780680c786c8713b2ce1fbb53db92f3b57c95","modified":1519890772046},{"_id":"public/archives/2017/index.html","hash":"f5fbac12a57c6858e2c9c57cbf340ec89a672162","modified":1519890772046},{"_id":"public/archives/2017/04/index.html","hash":"1b0a28c4415682690fd6280214fd5f6629150125","modified":1519890772046},{"_id":"public/categories/Others/index.html","hash":"035607d520de886d3e142f88297f80071893291e","modified":1519890772046},{"_id":"public/categories/iOS/index.html","hash":"d412900411767e841671f4383077a3ec43e296a2","modified":1519890772046},{"_id":"public/categories/读书笔记/index.html","hash":"501308e38fc180ee74ec70994dc14b166970843a","modified":1519890772046},{"_id":"public/categories/代码之外/index.html","hash":"0a8c1910b58469d3199f9aa684cf8b157685f447","modified":1519890772046},{"_id":"public/page/2/index.html","hash":"693f97d6cf012eac714bbe44be1ab0ac905948da","modified":1519890772046},{"_id":"public/2017/04/05/iOS的单例模式与多线程安全/index.html","hash":"86f76eafc57ea41d678f4e57749d77d9fc9d5707","modified":1519890772046},{"_id":"public/2016/09/25/Objective-C中的消息转发机制/index.html","hash":"8dad7ae0f47b0631a0becbc2277a44a35971864c","modified":1519890772046},{"_id":"public/2016/08/24/同步、异步、阻塞、非阻塞的简单理解/index.html","hash":"50a122ec9f9aeb507f10aa9b945733663790fc68","modified":1519890772046},{"_id":"public/2016/07/25/神在细节之中/index.html","hash":"3df32f7e8af92eb35b2007b7beb35716baf36765","modified":1519890772046},{"_id":"public/2016/08/04/如何用iPad在床上优雅的看大片/index.html","hash":"6a22e90ecbd5ea1f2c26476debd18e4b84f65be0","modified":1519890772046},{"_id":"public/2016/06/20/NSTimer 会保留目标对象/index.html","hash":"007c03a9d7338a3ce6046746dd28956907abeed2","modified":1519890772046},{"_id":"public/2016/06/15/ARC MRC 调用未声明方法/index.html","hash":"2f36ea1f6359ca29a9313ca1aa473de1a1f9f5af","modified":1519890772046},{"_id":"public/2016/06/12/NSUserdefaults与NSMutableArray的坑/index.html","hash":"f5baf15611751f61d504641212fd8fb99315fc33","modified":1519890772046},{"_id":"public/2016/06/01/关于Objective-C中的BOOL你所要知道的/index.html","hash":"af30360d606507fe78728ab75f9d84220c6e33e5","modified":1519890772046},{"_id":"public/2016/03/28/UITableView 中，UICollectionView 相互复用之间 contentOffset/index.html","hash":"7089babaeb94a79b0685ebd4f2279f1160043299","modified":1519890772047},{"_id":"public/2016/03/19/Effective-Objective-C-读书笔记/index.html","hash":"9c2928c4b4e442caef37ef68a8d4677fb95da0ee","modified":1519890772047},{"_id":"public/2016/02/18/iOS技能树/index.html","hash":"c6e3e5c8b6c56440e6f41bf56b23f02372f1d7fa","modified":1519890772047},{"_id":"public/2016/01/27/2016-01-27-Reading-List/index.html","hash":"10a2790032c6fa8950ca205294aff1c7f4ac96c8","modified":1519890772047},{"_id":"public/2013/03/01/那些年，我看过的/index.html","hash":"94a4f2f5785b35d7512ceff906fffefebb45c9e2","modified":1519890772047},{"_id":"public/archives/index.html","hash":"ea414152073d490648e10bb9391d55c036c5ac17","modified":1519890772047},{"_id":"public/index.html","hash":"9b1fe8f3cdebebfb9bc4144fbb0a739e8371a5e8","modified":1519890772047},{"_id":"public/images/view.jpg","hash":"a7b69856e3d241eec549632515c6e7dc16e378c1","modified":1519890772051},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1519890772051},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1519890772051},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1519890772051},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1519890772052},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1519890772052},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1519890772052},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1519890772052},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519890772052},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519890772052},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1519890772052},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1519890772052},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1519890772052},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1519890772052},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1519890772052},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1519890772052},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1519890772052},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1519890772052},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1519890772052},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1519890772052},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1519890772052},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1519890772052},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1519890772052},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1519890772052},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1519890772463},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1519890772466},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1519890772466},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1519890772470},{"_id":"public/js/src/bootstrap.js","hash":"cca1fe42d49d3946f44b6ef1b247175f16ba796c","modified":1519890772470},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1519890772470},{"_id":"public/js/src/motion.js","hash":"a3d2eeeed8edecbeab35fe0bca1222874120b974","modified":1519890772470},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1519890772470},{"_id":"public/js/src/utils.js","hash":"7eb00abf9bc14516463d9f29db41805e808a565c","modified":1519890772470},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1519890772470},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1519890772470},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1519890772470},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1519890772470},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1519890772470},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1519890772470},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1519890772470},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1519890772470},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1519890772470},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1519890772470},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1519890772470},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1519890772470},{"_id":"public/js/src/schemes/pisces.js","hash":"94f935331995bfeadf1084fb8f0665ab39fd1c8d","modified":1519890772470},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1519890772471},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1519890772471},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1519890772471},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1519890772471},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1519890772471},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1519890772471},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1519890772471},{"_id":"public/css/main.css","hash":"332edb10b2e213355e9cf5df06b6347c4a6a96b9","modified":1519890772471},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1519890772471},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1519890772471},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1519890772471},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1519890772471},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1519890772471},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1519890772471},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1519890772471},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1519890772471},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1519890772471},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1519890772471},{"_id":"public/images/girl.jpg","hash":"195786b13bb6264e22541aec1a437b90c739213f","modified":1519890772475},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1519890772479},{"_id":"public/images/girl2.jpg","hash":"5a19566bf07cc23517be384b87f70c93a3a62e98","modified":1519890772481}],"Category":[{"name":"Others","_id":"cje87q0920004tjqwgqgzv1z1"},{"name":"iOS","_id":"cje87q0960009tjqwuwmq34ht"},{"name":"读书笔记","_id":"cje87q099000dtjqw6212joqv"},{"name":"代码之外","_id":"cje87q09h000rtjqwp4qgq3iu"}],"Data":[],"Page":[{"title":"about","date":"2016-02-18T13:54:09.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-02-18 21:54:09\ntype: about\n---\n","updated":"2017-12-17T09:35:05.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cje87q08z0001tjqwneb3ja36","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-02-18T13:21:40.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-02-18 21:21:40\ntype: categories\n---\n","updated":"2017-12-17T09:35:05.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cje87q0910003tjqw062q1bb6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-02-18T13:20:07.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-02-18 21:20:07\ntype: tags\n---\n","updated":"2017-12-17T09:35:05.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cje87q0940006tjqwoljwq9t8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"iOS Reading List","description":"未整理的知识列表","date":"2016-01-26T16:00:00.000Z","photos":[],"keywords":null,"_content":"\n# 2016-01\n+ ## [iOS 开发博客列表](https://github.com/tangqiaoboy/iOSBlogCN)\n\n# 2016-02\n+ ## frame 和 bounds 区别\n\n\t1. [设置父 View 的 bounds 的原点，本质是将父 View 的左上角顶点改为 bounds 的原点值](http://blog.csdn.net/mad1989/article/details/8711697)\n\t2. 快速输出 frame 和 bounds：NSStringFromCGRect(view.frame)\n\t3. [bounds 比其 frame 大或小的影响](http://www.cocoachina.com/ios/20140925/9755.html)\n\t4. [横屏之后，播放器 Controller 的 view 的 frame 的 size 为(320,480)，而 bounds 的 size 为(480,320)](http://stackoverflow.com/questions/17036225/why-self-view-frame-and-self-view-bounds-are-different-w`hen-the-devices-rotate)，这是因为横屏对播放器 Controller 的 view 应用了 transform，应用了 transform 之后 frame 不变，但是 bounds 会改变\n\t\n\t\tIn addition the frame property’s values are undefined if the view has any transform other than the identity transform. Rotating a view into landscape mode applies a transform to the view so it is not safe to rely on frame values for an app in landscape mode.\n\t\n\t\t摘自 [UIView Frames and Bounds](http://blog.carbonfive.com/2010/05/27/uiview-frames-and-bounds/)\n\n+ ## [如何成为一名入门级 iOS 开发者](http://www.jianshu.com/p/958c1c52db6c)\n\n+ ## 调试过程使用\"thread return\"or \"thread return YES\"来 return 函数\n\n+ ## [SVN 合并分支](https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-dug-merge.html)\n\n# 2016-03\n+ ## 调试技巧之条件断点(BOOL)[str isEqualToString:@\"ABC\"]","source":"_posts/2016-01-27-Reading-List.md","raw":"---\ntitle: iOS Reading List\ndescription: 未整理的知识列表\ndate: 2016-1-27\ncategories:\n- Others\nphotos: \nkeywords:\n---\n\n# 2016-01\n+ ## [iOS 开发博客列表](https://github.com/tangqiaoboy/iOSBlogCN)\n\n# 2016-02\n+ ## frame 和 bounds 区别\n\n\t1. [设置父 View 的 bounds 的原点，本质是将父 View 的左上角顶点改为 bounds 的原点值](http://blog.csdn.net/mad1989/article/details/8711697)\n\t2. 快速输出 frame 和 bounds：NSStringFromCGRect(view.frame)\n\t3. [bounds 比其 frame 大或小的影响](http://www.cocoachina.com/ios/20140925/9755.html)\n\t4. [横屏之后，播放器 Controller 的 view 的 frame 的 size 为(320,480)，而 bounds 的 size 为(480,320)](http://stackoverflow.com/questions/17036225/why-self-view-frame-and-self-view-bounds-are-different-w`hen-the-devices-rotate)，这是因为横屏对播放器 Controller 的 view 应用了 transform，应用了 transform 之后 frame 不变，但是 bounds 会改变\n\t\n\t\tIn addition the frame property’s values are undefined if the view has any transform other than the identity transform. Rotating a view into landscape mode applies a transform to the view so it is not safe to rely on frame values for an app in landscape mode.\n\t\n\t\t摘自 [UIView Frames and Bounds](http://blog.carbonfive.com/2010/05/27/uiview-frames-and-bounds/)\n\n+ ## [如何成为一名入门级 iOS 开发者](http://www.jianshu.com/p/958c1c52db6c)\n\n+ ## 调试过程使用\"thread return\"or \"thread return YES\"来 return 函数\n\n+ ## [SVN 合并分支](https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-dug-merge.html)\n\n# 2016-03\n+ ## 调试技巧之条件断点(BOOL)[str isEqualToString:@\"ABC\"]","slug":"2016-01-27-Reading-List","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","link":"","_id":"cje87q08v0000tjqwlj587dz9","content":"<h1 id=\"2016-01\"><a href=\"#2016-01\" class=\"headerlink\" title=\"2016-01\"></a>2016-01</h1><ul>\n<li><h2 id=\"iOS-开发博客列表\"><a href=\"#iOS-开发博客列表\" class=\"headerlink\" title=\"iOS 开发博客列表\"></a><a href=\"https://github.com/tangqiaoboy/iOSBlogCN\" target=\"_blank\" rel=\"noopener\">iOS 开发博客列表</a></h2></li>\n</ul>\n<h1 id=\"2016-02\"><a href=\"#2016-02\" class=\"headerlink\" title=\"2016-02\"></a>2016-02</h1><ul>\n<li><h2 id=\"frame-和-bounds-区别\"><a href=\"#frame-和-bounds-区别\" class=\"headerlink\" title=\"frame 和 bounds 区别\"></a>frame 和 bounds 区别</h2><ol>\n<li><a href=\"http://blog.csdn.net/mad1989/article/details/8711697\" target=\"_blank\" rel=\"noopener\">设置父 View 的 bounds 的原点，本质是将父 View 的左上角顶点改为 bounds 的原点值</a></li>\n<li>快速输出 frame 和 bounds：NSStringFromCGRect(view.frame)</li>\n<li><a href=\"http://www.cocoachina.com/ios/20140925/9755.html\" target=\"_blank\" rel=\"noopener\">bounds 比其 frame 大或小的影响</a></li>\n<li><p><a href=\"http://stackoverflow.com/questions/17036225/why-self-view-frame-and-self-view-bounds-are-different-w`hen-the-devices-rotate\" target=\"_blank\" rel=\"noopener\">横屏之后，播放器 Controller 的 view 的 frame 的 size 为(320,480)，而 bounds 的 size 为(480,320)</a>，这是因为横屏对播放器 Controller 的 view 应用了 transform，应用了 transform 之后 frame 不变，但是 bounds 会改变</p>\n<p> In addition the frame property’s values are undefined if the view has any transform other than the identity transform. Rotating a view into landscape mode applies a transform to the view so it is not safe to rely on frame values for an app in landscape mode.</p>\n<p> 摘自 <a href=\"http://blog.carbonfive.com/2010/05/27/uiview-frames-and-bounds/\" target=\"_blank\" rel=\"noopener\">UIView Frames and Bounds</a></p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"如何成为一名入门级-iOS-开发者\"><a href=\"#如何成为一名入门级-iOS-开发者\" class=\"headerlink\" title=\"如何成为一名入门级 iOS 开发者\"></a><a href=\"http://www.jianshu.com/p/958c1c52db6c\" target=\"_blank\" rel=\"noopener\">如何成为一名入门级 iOS 开发者</a></h2></li>\n<li><h2 id=\"调试过程使用”thread-return”or-“thread-return-YES”来-return-函数\"><a href=\"#调试过程使用”thread-return”or-“thread-return-YES”来-return-函数\" class=\"headerlink\" title=\"调试过程使用”thread return”or “thread return YES”来 return 函数\"></a>调试过程使用”thread return”or “thread return YES”来 return 函数</h2></li>\n<li><h2 id=\"SVN-合并分支\"><a href=\"#SVN-合并分支\" class=\"headerlink\" title=\"SVN 合并分支\"></a><a href=\"https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-dug-merge.html\" target=\"_blank\" rel=\"noopener\">SVN 合并分支</a></h2></li>\n</ul>\n<h1 id=\"2016-03\"><a href=\"#2016-03\" class=\"headerlink\" title=\"2016-03\"></a>2016-03</h1><ul>\n<li><h2 id=\"调试技巧之条件断点-BOOL-str-isEqualToString-”ABC”\"><a href=\"#调试技巧之条件断点-BOOL-str-isEqualToString-”ABC”\" class=\"headerlink\" title=\"调试技巧之条件断点(BOOL)[str isEqualToString:@”ABC”]\"></a>调试技巧之条件断点(BOOL)[str isEqualToString:@”ABC”]</h2></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2016-01\"><a href=\"#2016-01\" class=\"headerlink\" title=\"2016-01\"></a>2016-01</h1><ul>\n<li><h2 id=\"iOS-开发博客列表\"><a href=\"#iOS-开发博客列表\" class=\"headerlink\" title=\"iOS 开发博客列表\"></a><a href=\"https://github.com/tangqiaoboy/iOSBlogCN\" target=\"_blank\" rel=\"noopener\">iOS 开发博客列表</a></h2></li>\n</ul>\n<h1 id=\"2016-02\"><a href=\"#2016-02\" class=\"headerlink\" title=\"2016-02\"></a>2016-02</h1><ul>\n<li><h2 id=\"frame-和-bounds-区别\"><a href=\"#frame-和-bounds-区别\" class=\"headerlink\" title=\"frame 和 bounds 区别\"></a>frame 和 bounds 区别</h2><ol>\n<li><a href=\"http://blog.csdn.net/mad1989/article/details/8711697\" target=\"_blank\" rel=\"noopener\">设置父 View 的 bounds 的原点，本质是将父 View 的左上角顶点改为 bounds 的原点值</a></li>\n<li>快速输出 frame 和 bounds：NSStringFromCGRect(view.frame)</li>\n<li><a href=\"http://www.cocoachina.com/ios/20140925/9755.html\" target=\"_blank\" rel=\"noopener\">bounds 比其 frame 大或小的影响</a></li>\n<li><p><a href=\"http://stackoverflow.com/questions/17036225/why-self-view-frame-and-self-view-bounds-are-different-w`hen-the-devices-rotate\" target=\"_blank\" rel=\"noopener\">横屏之后，播放器 Controller 的 view 的 frame 的 size 为(320,480)，而 bounds 的 size 为(480,320)</a>，这是因为横屏对播放器 Controller 的 view 应用了 transform，应用了 transform 之后 frame 不变，但是 bounds 会改变</p>\n<p> In addition the frame property’s values are undefined if the view has any transform other than the identity transform. Rotating a view into landscape mode applies a transform to the view so it is not safe to rely on frame values for an app in landscape mode.</p>\n<p> 摘自 <a href=\"http://blog.carbonfive.com/2010/05/27/uiview-frames-and-bounds/\" target=\"_blank\" rel=\"noopener\">UIView Frames and Bounds</a></p>\n</li>\n</ol>\n</li>\n<li><h2 id=\"如何成为一名入门级-iOS-开发者\"><a href=\"#如何成为一名入门级-iOS-开发者\" class=\"headerlink\" title=\"如何成为一名入门级 iOS 开发者\"></a><a href=\"http://www.jianshu.com/p/958c1c52db6c\" target=\"_blank\" rel=\"noopener\">如何成为一名入门级 iOS 开发者</a></h2></li>\n<li><h2 id=\"调试过程使用”thread-return”or-“thread-return-YES”来-return-函数\"><a href=\"#调试过程使用”thread-return”or-“thread-return-YES”来-return-函数\" class=\"headerlink\" title=\"调试过程使用”thread return”or “thread return YES”来 return 函数\"></a>调试过程使用”thread return”or “thread return YES”来 return 函数</h2></li>\n<li><h2 id=\"SVN-合并分支\"><a href=\"#SVN-合并分支\" class=\"headerlink\" title=\"SVN 合并分支\"></a><a href=\"https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-dug-merge.html\" target=\"_blank\" rel=\"noopener\">SVN 合并分支</a></h2></li>\n</ul>\n<h1 id=\"2016-03\"><a href=\"#2016-03\" class=\"headerlink\" title=\"2016-03\"></a>2016-03</h1><ul>\n<li><h2 id=\"调试技巧之条件断点-BOOL-str-isEqualToString-”ABC”\"><a href=\"#调试技巧之条件断点-BOOL-str-isEqualToString-”ABC”\" class=\"headerlink\" title=\"调试技巧之条件断点(BOOL)[str isEqualToString:@”ABC”]\"></a>调试技巧之条件断点(BOOL)[str isEqualToString:@”ABC”]</h2></li>\n</ul>\n","sticky":0},{"title":"ARC/MRC 调用未声明方法","date":"2016-06-14T16:00:00.000Z","keywords":"ARC,MRC,未声明方法,performSelector,undeclared methods","_content":"\n# 背景\n有一次，发现调用一个未声明的方法的时候，Xcode 居然没有像往常一样给出错误提示，而只是给了 Warning，研究后发现原来该文件不是 ARC，所以出现这种问题，那么 ARC 和 MRC 之间，对于调用未声明的方法，有什么区别呢？\n# 实验\n`[self noSuchMethod];`\n\nMRC 下，调用一个未声明的方法，编译器会给出 Warning:\n> \"Instance method 'noSuchMethod' not found (return type defaults to 'id')\"\n\nARC 下，调用一个未声明的方法，编译器却给出 Error:\n> \"No visible @interface for 'xxx' declares the selector 'noSuchMethod'\"\n\n\n原因：\n\nARC 下，编译器需要知道方法返回值的所有者，才能正确在合适的地方添加 retain/release 等，所以显式调用一个未声明的方法在 ARC 下默认是不允许的\n\n下面是具体的代码提示，跟Xcode的版本有关系，我的Xcode是`Version 7.3.1 (7D1014)`\n\nMRC:\n\n```objectivec\nid classA;\n\n// Warning:Instance method '-xyz' not found (return type defaults to 'id')\n[classA xyz];\n\n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz)];\n\n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\")];\n\n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil];\n    \n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil afterDelay:0];\n\n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil afterDelay:0];\n```\n\nARC:\n\n```objectivec\nid classA;\n    \n// Error:No known instance method for selector 'xyz' 或者\n// Error:No visible @interface for 'xxx' declares the selector 'xyz'\n[classA xyz];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz)];\n    \n// Warning:\"PerformSelector may cause a leak because its selector is unknown\"\n[classA performSelector:NSSelectorFromString(@\"xyz\")];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil];\n    \n// Warning:\"PerformSelector may cause a leak because its selector is unknown\"\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil afterDelay:0];\n    \n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil afterDelay:0];\n```\n\n问题：\n\n1. @selector 和 NSSelectorFromString 区别\n\n    可以看到使用 @selector()，编译器可以知道相应方法没有被声明；而使用 NSSelectorFromString，编译器并不知情，因为该方法是动态的，在 Runtime 的时候才能确定相应的方法实现，所以编译器选择了忽略\n    \n    所以 MRC 下很简单，@selector 就给警告， NSSelectorFromString 就不管\n    \n    ARC 下，就复杂点，@selectot 依然给警告，但是 NSSelectorFromString 的处理就复杂点，继续往下看\n    \n2. 那为什么 ARC 下， `performSelector:NSSelectorFromString()` 会有 Leak Warning\n    \n    事实上，无论 xyz 方法存在不存在，只要是 ARC 下，使用`performSelector:NSSelectorFromString()`就会有该 Warning 产生，因为编译器并不知道你调用了什么方法(是含有`alloc`/`new`/`copy`/`mutableCopy`关键字的方法还是普通方法)，那它也不知道该不该添加 retain/release 等，所以给出可能产生内存泄露的警告\n    \n    如果确定了这样调用没有内存问题，那么可以通过以下方法消除 Warning：\n    \n    + 针对部分代码\n    \n    ```objectivec\n    #pragma clang diagnostic push\n    #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n    [classA performSelector:NSSelectorFromString(@\"xyz\")];\n    #pragma clang diagnostic pop\n    ```\n\n    更骚一点的做法是\n    \n    ```objectivec\n    #define SILENCE_PERFORMSELECTOR(expr)                               \\\n    do {                                                                \\\n    _Pragma(\"clang diagnostic push\")                                    \\\n    _Pragma(\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\") \\\n    expr;                                                               \\\n    _Pragma(\"clang diagnostic pop\")                                     \\\n    } while(0)\n    \n    SILENCE_PERFORMSELECTOR([classA performSelector:NSSelectorFromString(@\"xyz\")]);\n    ```\n\n    + 针对单个文件，与设置某个文件为非 ARC 类似（见小Tips），添加`-Wno-arc-performSelector-leaks`\n    + 针对整个工程，Build Settings，搜索 Other Warning Flags，添加`-Wno-arc-performSelector-leaks`\n    \n3. 最后的问题，为什么 ARC 下， `performSelector:NSSelectorFromString() withObject:afterDelay:` 就没有 Leak Warning 呢\n    \n    看看这几个函数的原型\n    \n    ```objectivec\n    - (id)performSelector:(SEL)aSelector;\n    - (id)performSelector:(SEL)aSelector withObject:(id)object;\n    - (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;    \n    ```\n    可以看到，`performSelector:withObject:afterDelay:`返回值是 void。所以可以推测，Xcode 认为，你既然写了 afterDelay（即使是延迟0秒），那么它的返回值是 void，无论 selector 有没有返回值，都不需要为之添加 retain/release，所以这种情况下没有内存问题\n\n# 小Tips\n1. ARC 与 MRC 互转：工程 -> Targets -> Build Phases -> Compile Sources -> 对应的.m文件的Compiler Flags添加`-fno-objc-arc`(MRC)/`-fobjc-arc`(ARC)\n2. 判断 ARC 与 MRC 的快速方法，在 `dealloc` 里面调用 `[super dealloc];`，如果报错则是 ARC，否则是 MRC\n\n# 参考链接\n+ [stackoverflow1](http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/7954697#7954697)\n+ [stackoverflow2](http://stackoverflow.com/questions/20582642/why-arc-forbids-calls-to-undeclared-methods/20582863#20582863)","source":"_posts/ARC MRC 调用未声明方法.md","raw":"---\ntitle: ARC/MRC 调用未声明方法\ndate: 2016-06-15\ncategories:\n- iOS\nkeywords: ARC,MRC,未声明方法,performSelector,undeclared methods\n---\n\n# 背景\n有一次，发现调用一个未声明的方法的时候，Xcode 居然没有像往常一样给出错误提示，而只是给了 Warning，研究后发现原来该文件不是 ARC，所以出现这种问题，那么 ARC 和 MRC 之间，对于调用未声明的方法，有什么区别呢？\n# 实验\n`[self noSuchMethod];`\n\nMRC 下，调用一个未声明的方法，编译器会给出 Warning:\n> \"Instance method 'noSuchMethod' not found (return type defaults to 'id')\"\n\nARC 下，调用一个未声明的方法，编译器却给出 Error:\n> \"No visible @interface for 'xxx' declares the selector 'noSuchMethod'\"\n\n\n原因：\n\nARC 下，编译器需要知道方法返回值的所有者，才能正确在合适的地方添加 retain/release 等，所以显式调用一个未声明的方法在 ARC 下默认是不允许的\n\n下面是具体的代码提示，跟Xcode的版本有关系，我的Xcode是`Version 7.3.1 (7D1014)`\n\nMRC:\n\n```objectivec\nid classA;\n\n// Warning:Instance method '-xyz' not found (return type defaults to 'id')\n[classA xyz];\n\n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz)];\n\n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\")];\n\n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil];\n    \n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil afterDelay:0];\n\n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil afterDelay:0];\n```\n\nARC:\n\n```objectivec\nid classA;\n    \n// Error:No known instance method for selector 'xyz' 或者\n// Error:No visible @interface for 'xxx' declares the selector 'xyz'\n[classA xyz];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz)];\n    \n// Warning:\"PerformSelector may cause a leak because its selector is unknown\"\n[classA performSelector:NSSelectorFromString(@\"xyz\")];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil];\n    \n// Warning:\"PerformSelector may cause a leak because its selector is unknown\"\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil];\n    \n// Warning:Undeclared selector 'xyz'\n[classA performSelector:@selector(xyz) withObject:nil afterDelay:0];\n    \n// No Error, No Warning\n[classA performSelector:NSSelectorFromString(@\"xyz\") withObject:nil afterDelay:0];\n```\n\n问题：\n\n1. @selector 和 NSSelectorFromString 区别\n\n    可以看到使用 @selector()，编译器可以知道相应方法没有被声明；而使用 NSSelectorFromString，编译器并不知情，因为该方法是动态的，在 Runtime 的时候才能确定相应的方法实现，所以编译器选择了忽略\n    \n    所以 MRC 下很简单，@selector 就给警告， NSSelectorFromString 就不管\n    \n    ARC 下，就复杂点，@selectot 依然给警告，但是 NSSelectorFromString 的处理就复杂点，继续往下看\n    \n2. 那为什么 ARC 下， `performSelector:NSSelectorFromString()` 会有 Leak Warning\n    \n    事实上，无论 xyz 方法存在不存在，只要是 ARC 下，使用`performSelector:NSSelectorFromString()`就会有该 Warning 产生，因为编译器并不知道你调用了什么方法(是含有`alloc`/`new`/`copy`/`mutableCopy`关键字的方法还是普通方法)，那它也不知道该不该添加 retain/release 等，所以给出可能产生内存泄露的警告\n    \n    如果确定了这样调用没有内存问题，那么可以通过以下方法消除 Warning：\n    \n    + 针对部分代码\n    \n    ```objectivec\n    #pragma clang diagnostic push\n    #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n    [classA performSelector:NSSelectorFromString(@\"xyz\")];\n    #pragma clang diagnostic pop\n    ```\n\n    更骚一点的做法是\n    \n    ```objectivec\n    #define SILENCE_PERFORMSELECTOR(expr)                               \\\n    do {                                                                \\\n    _Pragma(\"clang diagnostic push\")                                    \\\n    _Pragma(\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\") \\\n    expr;                                                               \\\n    _Pragma(\"clang diagnostic pop\")                                     \\\n    } while(0)\n    \n    SILENCE_PERFORMSELECTOR([classA performSelector:NSSelectorFromString(@\"xyz\")]);\n    ```\n\n    + 针对单个文件，与设置某个文件为非 ARC 类似（见小Tips），添加`-Wno-arc-performSelector-leaks`\n    + 针对整个工程，Build Settings，搜索 Other Warning Flags，添加`-Wno-arc-performSelector-leaks`\n    \n3. 最后的问题，为什么 ARC 下， `performSelector:NSSelectorFromString() withObject:afterDelay:` 就没有 Leak Warning 呢\n    \n    看看这几个函数的原型\n    \n    ```objectivec\n    - (id)performSelector:(SEL)aSelector;\n    - (id)performSelector:(SEL)aSelector withObject:(id)object;\n    - (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;    \n    ```\n    可以看到，`performSelector:withObject:afterDelay:`返回值是 void。所以可以推测，Xcode 认为，你既然写了 afterDelay（即使是延迟0秒），那么它的返回值是 void，无论 selector 有没有返回值，都不需要为之添加 retain/release，所以这种情况下没有内存问题\n\n# 小Tips\n1. ARC 与 MRC 互转：工程 -> Targets -> Build Phases -> Compile Sources -> 对应的.m文件的Compiler Flags添加`-fno-objc-arc`(MRC)/`-fobjc-arc`(ARC)\n2. 判断 ARC 与 MRC 的快速方法，在 `dealloc` 里面调用 `[super dealloc];`，如果报错则是 ARC，否则是 MRC\n\n# 参考链接\n+ [stackoverflow1](http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/7954697#7954697)\n+ [stackoverflow2](http://stackoverflow.com/questions/20582642/why-arc-forbids-calls-to-undeclared-methods/20582863#20582863)","slug":"ARC MRC 调用未声明方法","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje87q08z0002tjqwjygvx2ca","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>有一次，发现调用一个未声明的方法的时候，Xcode 居然没有像往常一样给出错误提示，而只是给了 Warning，研究后发现原来该文件不是 ARC，所以出现这种问题，那么 ARC 和 MRC 之间，对于调用未声明的方法，有什么区别呢？</p>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><p><code>[self noSuchMethod];</code></p>\n<p>MRC 下，调用一个未声明的方法，编译器会给出 Warning:</p>\n<blockquote>\n<p>“Instance method ‘noSuchMethod’ not found (return type defaults to ‘id’)”</p>\n</blockquote>\n<p>ARC 下，调用一个未声明的方法，编译器却给出 Error:</p>\n<blockquote>\n<p>“No visible @interface for ‘xxx’ declares the selector ‘noSuchMethod’”</p>\n</blockquote>\n<p>原因：</p>\n<p>ARC 下，编译器需要知道方法返回值的所有者，才能正确在合适的地方添加 retain/release 等，所以显式调用一个未声明的方法在 ARC 下默认是不允许的</p>\n<p>下面是具体的代码提示，跟Xcode的版本有关系，我的Xcode是<code>Version 7.3.1 (7D1014)</code></p>\n<p>MRC:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> classA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Instance method '-xyz' not found (return type defaults to 'id')</span></span><br><span class=\"line\">[classA xyz];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>ARC:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> classA;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Error:No known instance method for selector 'xyz' 或者</span></span><br><span class=\"line\"><span class=\"comment\">// Error:No visible @interface for 'xxx' declares the selector 'xyz'</span></span><br><span class=\"line\">[classA xyz];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz)];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:\"PerformSelector may cause a leak because its selector is unknown\"</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:\"PerformSelector may cause a leak because its selector is unknown\"</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>问题：</p>\n<ol>\n<li><p>@selector 和 NSSelectorFromString 区别</p>\n<p> 可以看到使用 @selector()，编译器可以知道相应方法没有被声明；而使用 NSSelectorFromString，编译器并不知情，因为该方法是动态的，在 Runtime 的时候才能确定相应的方法实现，所以编译器选择了忽略</p>\n<p> 所以 MRC 下很简单，@selector 就给警告， NSSelectorFromString 就不管</p>\n<p> ARC 下，就复杂点，@selectot 依然给警告，但是 NSSelectorFromString 的处理就复杂点，继续往下看</p>\n</li>\n<li><p>那为什么 ARC 下， <code>performSelector:NSSelectorFromString()</code> 会有 Leak Warning</p>\n<p> 事实上，无论 xyz 方法存在不存在，只要是 ARC 下，使用<code>performSelector:NSSelectorFromString()</code>就会有该 Warning 产生，因为编译器并不知道你调用了什么方法(是含有<code>alloc</code>/<code>new</code>/<code>copy</code>/<code>mutableCopy</code>关键字的方法还是普通方法)，那它也不知道该不该添加 retain/release 等，所以给出可能产生内存泄露的警告</p>\n<p> 如果确定了这样调用没有内存问题，那么可以通过以下方法消除 Warning：</p>\n<ul>\n<li><p>针对部分代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic push</span></span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic ignored <span class=\"meta-string\">\"-Warc-performSelector-leaks\"</span></span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic pop</span></span><br></pre></td></tr></table></figure>\n<p>更骚一点的做法是</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define SILENCE_PERFORMSELECTOR(expr)                               \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;                                                                \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic push\"</span>)                                    \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\"</span>) \\</span><br><span class=\"line\">expr;                                                               \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic pop\"</span>)                                     \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">SILENCE_PERFORMSELECTOR([classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>针对单个文件，与设置某个文件为非 ARC 类似（见小Tips），添加<code>-Wno-arc-performSelector-leaks</code></p>\n</li>\n<li>针对整个工程，Build Settings，搜索 Other Warning Flags，添加<code>-Wno-arc-performSelector-leaks</code></li>\n</ul>\n</li>\n<li><p>最后的问题，为什么 ARC 下， <code>performSelector:NSSelectorFromString() withObject:afterDelay:</code> 就没有 Leak Warning 呢</p>\n<p> 看看这几个函数的原型</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)performSelector:(SEL)aSelector;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)performSelector:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)object;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector withObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)anArgument afterDelay:(<span class=\"built_in\">NSTimeInterval</span>)delay;</span><br></pre></td></tr></table></figure>\n<p> 可以看到，<code>performSelector:withObject:afterDelay:</code>返回值是 void。所以可以推测，Xcode 认为，你既然写了 afterDelay（即使是延迟0秒），那么它的返回值是 void，无论 selector 有没有返回值，都不需要为之添加 retain/release，所以这种情况下没有内存问题</p>\n</li>\n</ol>\n<h1 id=\"小Tips\"><a href=\"#小Tips\" class=\"headerlink\" title=\"小Tips\"></a>小Tips</h1><ol>\n<li>ARC 与 MRC 互转：工程 -&gt; Targets -&gt; Build Phases -&gt; Compile Sources -&gt; 对应的.m文件的Compiler Flags添加<code>-fno-objc-arc</code>(MRC)/<code>-fobjc-arc</code>(ARC)</li>\n<li>判断 ARC 与 MRC 的快速方法，在 <code>dealloc</code> 里面调用 <code>[super dealloc];</code>，如果报错则是 ARC，否则是 MRC</li>\n</ol>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/7954697#7954697\" target=\"_blank\" rel=\"noopener\">stackoverflow1</a></li>\n<li><a href=\"http://stackoverflow.com/questions/20582642/why-arc-forbids-calls-to-undeclared-methods/20582863#20582863\" target=\"_blank\" rel=\"noopener\">stackoverflow2</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>有一次，发现调用一个未声明的方法的时候，Xcode 居然没有像往常一样给出错误提示，而只是给了 Warning，研究后发现原来该文件不是 ARC，所以出现这种问题，那么 ARC 和 MRC 之间，对于调用未声明的方法，有什么区别呢？</p>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><p><code>[self noSuchMethod];</code></p>\n<p>MRC 下，调用一个未声明的方法，编译器会给出 Warning:</p>\n<blockquote>\n<p>“Instance method ‘noSuchMethod’ not found (return type defaults to ‘id’)”</p>\n</blockquote>\n<p>ARC 下，调用一个未声明的方法，编译器却给出 Error:</p>\n<blockquote>\n<p>“No visible @interface for ‘xxx’ declares the selector ‘noSuchMethod’”</p>\n</blockquote>\n<p>原因：</p>\n<p>ARC 下，编译器需要知道方法返回值的所有者，才能正确在合适的地方添加 retain/release 等，所以显式调用一个未声明的方法在 ARC 下默认是不允许的</p>\n<p>下面是具体的代码提示，跟Xcode的版本有关系，我的Xcode是<code>Version 7.3.1 (7D1014)</code></p>\n<p>MRC:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> classA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Instance method '-xyz' not found (return type defaults to 'id')</span></span><br><span class=\"line\">[classA xyz];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>ARC:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> classA;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Error:No known instance method for selector 'xyz' 或者</span></span><br><span class=\"line\"><span class=\"comment\">// Error:No visible @interface for 'xxx' declares the selector 'xyz'</span></span><br><span class=\"line\">[classA xyz];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz)];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:\"PerformSelector may cause a leak because its selector is unknown\"</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:\"PerformSelector may cause a leak because its selector is unknown\"</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// Warning:Undeclared selector 'xyz'</span></span><br><span class=\"line\">[classA performSelector:<span class=\"keyword\">@selector</span>(xyz) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// No Error, No Warning</span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>问题：</p>\n<ol>\n<li><p>@selector 和 NSSelectorFromString 区别</p>\n<p> 可以看到使用 @selector()，编译器可以知道相应方法没有被声明；而使用 NSSelectorFromString，编译器并不知情，因为该方法是动态的，在 Runtime 的时候才能确定相应的方法实现，所以编译器选择了忽略</p>\n<p> 所以 MRC 下很简单，@selector 就给警告， NSSelectorFromString 就不管</p>\n<p> ARC 下，就复杂点，@selectot 依然给警告，但是 NSSelectorFromString 的处理就复杂点，继续往下看</p>\n</li>\n<li><p>那为什么 ARC 下， <code>performSelector:NSSelectorFromString()</code> 会有 Leak Warning</p>\n<p> 事实上，无论 xyz 方法存在不存在，只要是 ARC 下，使用<code>performSelector:NSSelectorFromString()</code>就会有该 Warning 产生，因为编译器并不知道你调用了什么方法(是含有<code>alloc</code>/<code>new</code>/<code>copy</code>/<code>mutableCopy</code>关键字的方法还是普通方法)，那它也不知道该不该添加 retain/release 等，所以给出可能产生内存泄露的警告</p>\n<p> 如果确定了这样调用没有内存问题，那么可以通过以下方法消除 Warning：</p>\n<ul>\n<li><p>针对部分代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic push</span></span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic ignored <span class=\"meta-string\">\"-Warc-performSelector-leaks\"</span></span></span><br><span class=\"line\">[classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)];</span><br><span class=\"line\"><span class=\"meta\">#pragma clang diagnostic pop</span></span><br></pre></td></tr></table></figure>\n<p>更骚一点的做法是</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define SILENCE_PERFORMSELECTOR(expr)                               \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;                                                                \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic push\"</span>)                                    \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\"</span>) \\</span><br><span class=\"line\">expr;                                                               \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">\"clang diagnostic pop\"</span>)                                     \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">SILENCE_PERFORMSELECTOR([classA performSelector:<span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"xyz\"</span>)]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>针对单个文件，与设置某个文件为非 ARC 类似（见小Tips），添加<code>-Wno-arc-performSelector-leaks</code></p>\n</li>\n<li>针对整个工程，Build Settings，搜索 Other Warning Flags，添加<code>-Wno-arc-performSelector-leaks</code></li>\n</ul>\n</li>\n<li><p>最后的问题，为什么 ARC 下， <code>performSelector:NSSelectorFromString() withObject:afterDelay:</code> 就没有 Leak Warning 呢</p>\n<p> 看看这几个函数的原型</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)performSelector:(SEL)aSelector;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)performSelector:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)object;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector withObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)anArgument afterDelay:(<span class=\"built_in\">NSTimeInterval</span>)delay;</span><br></pre></td></tr></table></figure>\n<p> 可以看到，<code>performSelector:withObject:afterDelay:</code>返回值是 void。所以可以推测，Xcode 认为，你既然写了 afterDelay（即使是延迟0秒），那么它的返回值是 void，无论 selector 有没有返回值，都不需要为之添加 retain/release，所以这种情况下没有内存问题</p>\n</li>\n</ol>\n<h1 id=\"小Tips\"><a href=\"#小Tips\" class=\"headerlink\" title=\"小Tips\"></a>小Tips</h1><ol>\n<li>ARC 与 MRC 互转：工程 -&gt; Targets -&gt; Build Phases -&gt; Compile Sources -&gt; 对应的.m文件的Compiler Flags添加<code>-fno-objc-arc</code>(MRC)/<code>-fobjc-arc</code>(ARC)</li>\n<li>判断 ARC 与 MRC 的快速方法，在 <code>dealloc</code> 里面调用 <code>[super dealloc];</code>，如果报错则是 ARC，否则是 MRC</li>\n</ol>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/7954697#7954697\" target=\"_blank\" rel=\"noopener\">stackoverflow1</a></li>\n<li><a href=\"http://stackoverflow.com/questions/20582642/why-arc-forbids-calls-to-undeclared-methods/20582863#20582863\" target=\"_blank\" rel=\"noopener\">stackoverflow2</a></li>\n</ul>\n","sticky":0},{"title":"Effective-Objective-C-读书笔记","description":"《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》","date":"2016-03-18T16:00:00.000Z","photos":[],"_content":"\n# 第1章 熟悉Objective—C \n## 第1条：了解Objective—C语言的起源\n```objectivec\nNSString *s1 = @\"Hello\";\nNSString *s2 = s1;\n```\n+ s1 和s2 的内存分配在栈上\n+ @\"Hello\"的内存分配在堆上\n+ s1 和 s2 指向同一块内存\n\n\n## 第2条：在类的头文件中尽量少引入其他头文件\n\n## 第3条：多用字面量语法，少用与之等价的方法\n### 使用字面量语法，它是一种语法糖：\n```objectivec\nNSString *str = @\"Hello\";\nNSNumber *intNum = @1;\nNSNumber *doubleNum = @2.5;\nNSNumber *charNum = @'a';\nNSNumber *boolNum = @YES;\nNSArray *array = @[@\"hello\", @1, @2.5, @'a'];\nNSString *str2 = array[0];\nNSDictionary *dic = @{@\"1\":@1, @\"2\":@2};\n```\n### 这个语法糖更容易暴露隐藏的问题\n```objectivec\nNSArray *array1 = [NSArray arrayWithObjects: obj1, obj2, obj3, nil];\nNSArray *array2 = @[obj1, obj2, obj3];\n```\n如果 obj1 和 obj3 非空，而 obj2 是 nil\n\n那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常\n\n### 使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\n```objectivec\nNSMuatableArray *mArray = [@[@1, @2] mutableCopy];\n```\n## 第4条：多用类型常量，少用#define预处理指令 \n详见[NSNotification Name 最佳写法](http://www.cnblogs.com/chenyg32/p/5080301.html)\n\n## 第5条：用枚举表示状态、选项、状态码\n### 使用 `NS_ENUM` 和 `NS_OPTIONS` 来表示`状态机`，\n```objectivec\n//NS_ENUM，定义状态等普通枚举\ntypedef NS_ENUM(NSUInteger, TTGState) {\n    TTGStateOK = 0,\n    TTGStateError,\n    TTGStateUnknow\n};\n\n//NS_OPTIONS，定义选项\ntypedef NS_OPTIONS(NSUInteger, TTGDirection) {\n    TTGDirectionNone = 0,\n    TTGDirectionTop = 1 << 0,\n    TTGDirectionLeft = 1 << 1,\n    TTGDirectionRight = 1 << 2,\n    TTGDirectionBottom = 1 << 3\n};\n```\n### 如果一个`枚举变量`可以同时表示一个或多个选项的集合，那么应当使用 `NS_OPTIONS`，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用`或操作`将其组合起来进行表示\n\n### 相比较 C 语言中的枚举，使用 `NS_ENUM` 和 `NS_OPTIONS` 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\n```objectivec\ntypedef enum _TTGState {\n    TTGStateOK  = 0,\n    TTGStateError,\n    TTGStateUnknow\n} TTGState;\n```\n### 处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举\n\n### 参考链接：[Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5](http://tutuge.me/2015/03/21/effective-objective-c-5-enum/)\n\n# 第2章 对象、消息、运行期 \n## 第6条：理解“属性”这一概念 \n### 理解好`属性`和`实例变量`的区别\n\n属性 = 实例变量 + setter + getter\n\n如果声明属性\n\n    @property (nonatomic, copy) NSString *str;\n\n则编译器会默认实现\n\n```objectivec\n//.h\n- (NSString *)str;\n- (void)setStr:(NSString *)str;\n\n//.m\n- (NSString *)str\n{\n\treturn _str;\n}\n\n- (void)setStr:(NSString *)str\n{\n\t_str = [str copy];\n}\n```\n其中 `_str` 就是`实例变量`\n \n### 使用`点语法`访问属性 = 调用 setter/getter 方法\n\n### Property 的4种 attribute\n\t\n+ 原子性(atomic, nonatomic)\n+ 读写权限(readonly, readwrite)\n+ 内存管理(strong, weak, unsafe_unretained, retain, assign, copy)\n+ 存取方法(getter, setter)\n\n### 非 ARC 下，没有 weak\n\n### ARC下，修饰指针的内存修饰符\n+ `__weak`:不retain，如果对象被回收，该指针会被置nil\n+ `__strong`:默认，如果对象被回收，需要手动将指针置为nil？\n+ `__unsafe__unretained`:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）\n+ `__autoreleasing`:实现把对象\"按引用传递\"给方法，变量在方法返回时自动释放\n\n编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量\n\n### 常见数据类型的内存修饰符（待补充）\n| 数据类型 | 内存修饰符 |\n| :--:|:--:|\n| 基本数据类型(int, NSInteger) | assign |\n| block | copy |\n| NSString | copy |\n| NSMutableString | strong |\n| NSArray | copy |\n| NSMutableArray | strong |\n\n### NSArray 用 strong 还是 copy 修饰\n```objc\n//.h\n@property (nonatomic, strong) NSArray *strongArray;\n@property (nonatomic, copy)   NSArray *copyedArray;\n//.m\nself.strongArray = [NSArray array];\nself.copyedArray = [NSArray array];\n    \nNSMutableArray *mutableArray = [@[@\"1\"] mutableCopy];\nself.strongArray = mutableArray;\nself.copyedArray = mutableArray;\n    \n[mutableArray addObject:@\"2\"];\n    \nNSLog(@\"%@\\n%@\\n%@\", mutableArray, self.strongArray, self.copyedArray); //输出 (1,2) (1,2) (1)\n```\n可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。\n\n\n## 第7条：在对象内部尽量直接访问实例变量\n### 类内使用 self.xxx 和 _xxx 的区别\n\n+ 访问 _xxx 不经过 setter/getter 方法，速度更快\n+ 访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作\n+ 访问 _xxx 不经过 setter/getter 方法，无法触发 KVO\n+ 访问 _xxx 不经过 setter/getter 方法，无法断点\n\n### 什么时候使用 _xxx\n\n+ 折中方案，读的时候使用 _xxx，写的时候使用 self.xxx\n+ 父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错\n+ 如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性\n+ 使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败\n```objectivec\n- (NSString *)str\n{\n\tif (!_str)\n\t\t_str = [[NSString alloc] init];\n\treturn _str;\n}\n```\n## 第8条：理解“对象等同性”这一概念 \n\n\n## 第9条：以“类族模式”隐藏实现细节 \n## 第10条：在既有类中使用关联对象存放自定义数据 \n“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性\n\n### 语法\n```objc\nvoid objc_setAssociatedObject (id object, void *key, id value, objc_AssociationPolicy policy);\n\nid objc_getAssociatedObject(id object, void *key);\n\nvoid objc_removeAssociatedObject(id object);    // 移除object上的所有关联对象\n```\n其中 objc_AssociationPolicy 是关联对象的属性，如下\n\n```objc\nOBJC_ASSOCIATION_ASSIGN             --- assign\nOBJC_ASSOCIATION_RETAIN_NONATOMIC   --- nonatomic, retain\nOBJC_ASSOCIATION_COPY_NONATOMIC     --- nonatomic, copy\nOBJC_ASSOCIATION_RETAIN             --- retain\nOBJC_ASSOCIATION_COPY               --- copy\n```\n\n### 与 NSDictionary 的区别\n设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。\n\n所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @\"xxx\"\n\n### 例子1\n假如一个页面有2个弹窗，那么代码可能是这样写\n\n```objc\n- (void)askUserAQuestion\n{\n    UIAlertView *alert = [[UIAlertView alloc]\n            initWithTitle:@\"Question\"\n                  message:@\"What do you want to do?\"\n                 delegate:self\n        cancelButtonTitle:@\"Cancel\"\n        otherButtonTitles:@\"Continue\", nil];\n    [alert show];\n}\n\n// UIAlertViewDelegate protocol method\n- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n    if (buttonIndex == 0)\n    {\n        [self doCancel];\n    }\n    else\n    {\n        [self doContinue];\n    }\n}\n```\n\n缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性\n\n```objc\n#import <objc/runtime.h>\n\nstatic void *EOCMyAlertViewKey = \"EOCMyAlertViewKey\";\n\n- (void)askUserAQuestion\n{\n\tUIAlertView *alert = [[UIAlertView alloc]\n\t        initWithTitle:@\"Question\"\n\t              message:@\"What do you want to do?\"\n\t             delegate:self\n\t    cancelButtonTitle:@\"Cancel\"\n\t    otherButtonTitles:@\"Continue\", nil];\n\n\tvoid (^block)(NSInteger) = ^(NSInteger buttonIndex) {\n\t    if (buttonIndex == 0)\n\t    {\n\t\t    [self doCancel];\n\t    }\n\t    else\n\t    {\n\t\t    [self doContinue];\n\t    }\n\t};\n\n\tobjc_setAssociatedObject(alert,\n                             EOCMyAlertViewKey,\n                             block,\n                             OBJC_ASSOCIATION_COPY);\n\n\t[alert show];\n}\n\n// UIAlertViewDelegate protocol method\n- (void)alertView:(UIAlertView *)alertView\n    clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n\tvoid (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);\n\tblock(buttonIndex);\n}\n```\n\n优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView\n\n### 例子2 为协议文件添加属性\n.h\n\n```objc\n#import \"QLJCEONAVRSSFeed.h\"\n\n@interface QLJCEONAVRSSFeed (contentOffset)\n\n@property (nonatomic, assign)CGPoint savedOffset;\n\n@end\n```\n.m\n\n```objc\n#import \"QLJCEONAVRSSFeed+contentOffset.h\"\n\n#define feed_saved_Off_set_x_key @\"feed_saved_Off_set_x_key\"\n#define feed_saved_Off_set_y_key @\"feed_saved_Off_set_y_key\"\n\n@implementation QLJCEONAVRSSFeed (contentOffset)\n\n@dynamic savedOffset;\n\n- (CGPoint)savedOffset\n{\n    NSNumber *xObj = objc_getAssociatedObject(self, feed_saved_Off_set_x_key);\n    NSNumber *yObj = objc_getAssociatedObject(self, feed_saved_Off_set_y_key);\n    \n    CGPoint point = CGPointMake([xObj floatValue], [yObj floatValue]);\n    \n    return point;\n}\n\n- (void)setSavedOffset:(CGPoint)savedOffset\n{\n    objc_setAssociatedObject(self, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    objc_setAssociatedObject(self, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n```\n\n\n## 第11条：理解objc_msgSend的作用\n见 [Objective-C中的消息转发机制](http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/)\n## 第12条：理解消息转发机制\n见 [Objective-C中的消息转发机制](http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/)\n\n \n## 第13条：用“方法调配技术”调试“黑盒方法”\n创建自己的方法\n\n```objc\n#import \"NSString+MyAdditions.h\"\n\n@implementation NSString (MyAdditions)\n- (NSString *)myLowercaseString\n{\n    NSString *lowercase = [self myLowercaseString];\n    NSLog(@\"This is my own method: %@\", lowercase);\n    return lowercase;\n}\n@end\n```\n替换\n\n```objc\nMethod originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));\nMethod swappedMethod = class_getInstanceMethod([NSString class], @selector(myLowercaseString));\nmethod_exchangeImplementations(originalMethod, swappedMethod);\n```\n\n \n## 第14条：理解“类对象”的用意 \n### 我们所说的 Objective-C 对象究竟是什么\n\n```objc\ntypedef struct objc_object{\n  Class isa;  //=> 指向对象所属的类\n} *id;\n```\n结论：Objective-C 对象 = id = objc_object\n\n### 那么 Class 是什么\n```objc\ntypedef struct objc_class *Class;  \n```\n### 那么 objc_class 又是什么\n```objc\nstruct objc_class {  \n    Class isa;\n    Class super_class;  \n    const char *name;  \n    long version;  \n    long info;  \n    long instance_size;  \n    struct objc_ivar_list *ivars;  \n    struct objc_method_list **methodLists;  \n    struct objc_cache *cache;  \n    struct objc_protocol_list *protocols;  \n}; \n```\n\n### 类的继承体系\n![](http://7xsd8c.com1.z0.glb.clouddn.com/isa.png)\n\n```objc\nNSString *str = @\"Hello\";\n```\nstr 是一个对象，is a NSString\n\nNSString 是类，is a NSString metaclass\n\nNSString metaclass 是元类，类方法就定义在这里\n\n\n# 第3章 接口与API设计 \n## done 第15条：用前缀避免命名空间冲突 \n## done 第16条：提供“全能初始化方法”\n详见[Designated Initializer](http://www.cnblogs.com/chenyg32/p/4870303.html)\n## done 第17条：实现description方法\n## done 第18条：尽量使用不可变对象\n+ 如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite\n+ 不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法\n\n## done 第19条：使用清晰而协调的命名方式:\n### 如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了\n\n### 对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX\n    @property (nonatomic, assign, getter = isOn) on;\n\n## done 第20条：为私有方法名加前缀 \n## done 第21条：理解Objective—C错误模型 \n## done 第22条：理解NSCopying协议 \n详见[浅析Objective-C的copy](http://www.cnblogs.com/chenyg32/p/5167194.html)\n \n# 第4章 协议与分类 \n## 第23条：通过委托与数据源协议进行对象间通信 \n```objc\nif([_delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)])\n{ \n    [_delegate networkFetcher:self didReceiveData:data];  \n}\n```\n\n如果上面的代码写了很多次，则可以考虑以下优化：\n\n```objc\n// 在扩展中定义结构体\n@interface EOCNetworkFetcher(\n{ \n    struct { \n    unsigned int didReceiveData : 1; \n    unsigned int didFailWithError : 1; \n    } _delegateFlags; \n} \n@end  \n\n@implementation \nEOCNetworkFetcher \n- (void)setDelegate:(id)delegate\n{ \n    _delegate = delegate; // 缓存委托对象相应方法能力 \n    _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]; \n    _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)]; \n} \n@end\n\n这样每次调用delegate相关方法之前就只需要直接查询标志：\nif(_delegateFlags.didReceiveData)\n{ \n    [_delegate networkFetcher:self didReceiveData:data]; \n}\n```\n\n## done 第24条：将类的实现代码分散到便于管理的数个分类之中 \n## 第25条：总是为第三方类的分类名称加前缀\n1. 为第三方类添加分类时，总应给其名称加上你专用的前缀\n2. 为第三方类添加分类时，总应给方法名加上你专用的前缀\n\n```objc\n@interface NSString (ABC_HTTP)\n-(NSString *)abc_urlEncodedString;\n-(NSString *)abc_urlDecodedString;\n@end\n```\n\n## 第26条：勿在分类中声明属性 \n属性应该在主类中声明\n\n如果分类中声明属性需要自己重写 setter 和 getter\n\n方法如下：\n```objc\n#import <objc/runtime.h>\n\nstatic const char *kFriendsPropertyKey = \"kFriendsPropertyKey\";\n\n@implementation Person(Friendship)\n@dynamic friends;\n\n-(NSArray*)friends \n{\n　　return objc_getAssociatedObject(self, kFriendsPropertyKey);\n}\n\n-(void)setFriends:(NSArray*)friends \n{\n　　objc_setAssociaedObject(self, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);\n}\n@end\n```\n\n缺点如下\n1. 相似的代码要写很多遍\n2. 极易忽略属性定义的内存管理语义，且不好维护\n\n## 第27条：使用“class—continuation分类”隐藏实现细节\n声明私有实例变量的3种方法\n\n+ 方法1：对外暴露，声明为 private（暴露了细节，不建议）\n\n    .h\n\n    ```objectivec\n    @interface ABC:NSObject\n    {\n    @private\n        XYZ *_xyz;\n    }\n    @end\n    ```\n    1. 把私有变量放在头文件，暴露了细节，不好\n    2. 假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题\n    3. 所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？\n    \n    \n+ 方法2：不对外暴露\n\n    .m\n    \n    ```objectivec\n    @interface ABC()\n    {\n        XYZ *_xyz;\n    }\n    @property (nonatomic, strong) XYZ *xyz2;\n    @end\n    ```\n+ 方法3：对外只读，对内读写\n\n    .h\n    \n    ```objectivec\n    @property (nonatomic, readonly) XYZ *xyz;\n    ```\n    .m\n    \n    ```objectivec\n    @interface ABC()\n    @property (nonatomic, readwrite) XYZ *xyz;\n    @end\n    ```\n\n## done 第28条：通过协议提供匿名对象 \n\n# 第5章 内存管理 \n## 第29条：理解引用计数 \n### 悬浮指针\n\n```objectivec\nNSNumber *number = [[NSNumber alloc] initWithInt:1];\n[array addObject:number];\n[number release];\nnumber = nil;   //如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知\n```\n\n### autorelease\n\n```objectivec\n- (NSString *)stringValue\n{\n    NSString *str = [[NSString alloc] initWithFormat:@\"Hello\"];\n    return str;\n}\n```\n这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放\n\n但是，这是十分不合理的，因为从方法名上看（不含`alloc/new/copy/mutableCopy`），调用者并不知道它需要负责释放该对象\n\n所以此时，autorelease 就应运而生了\n\n```objectivec\n- (NSString *)stringValue\n{\n    NSString *str = [[NSString alloc] initWithFormat:@\"Hello\"];\n    return [str autorelease];\n}\n```\n\nstr 对象会在其所在的释放池释放的时候被释放\n\n如果外部需要 retain 该返回值，则需要这样做\n\n```objectivec\nNSString *str = [[self stringValue] retain];\n// ...\n[str release];\n```\n\n> autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间\n\n## 第30条：以ARC简化引用计数\n### ARC 的本质是自动添加 release/retian/autorelease 等\n```objectivec\n+ (XYZ *)newXYZ\n{\n    XYZ *xyz = [[XYZ alloc] init];\n    return xyz;\n}\n\n+ (XYZ *)createXYZ\n{\n    XYZ *xyz = [[XYZ alloc] init];\n    /*ARC自动添加\n    xyz = [xyz autorelease];\n     */\n    return xyz;\n}\n\n- (void)f\n{\n    XYZ *xyz1 = [XYZ newXYZ];\n    XYZ *xyz2 = [XYZ createXYZ];\n    /*ARC自动添加\n    [xyz1 release];\n     */\n}\n```\n\n### 扩展阅读：[iOS开发ARC内存管理技术要点](http://www.cnblogs.com/flyFreeZn/p/4264220.html)\n\n## done 第31条：在dealloc方法中只释放引用并解除监听 \n## done 第32条：编写“异常安全代码”时留意内存管理问题 \n```objc\n@try {\n EOCSomeClass *object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];\n [object release];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏\n\n解决方法：\n\n```objc\nEOCSomeClass *object;\n@try {\n object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n@finally {\n [object release];\n}\n```\n\n同理，ARC 下也会发生这个问题\n\n```objc\n@try {\n EOCSomeClass *object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题\n\n总结：\n\n1. 当捕获到异常,应该注意确保@try中创建的对象被清理完成.\n2. ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.\n\n\n## done 第33条：以弱引用避免保留环 \n## done 第34条：以“自动释放池块”降低内存峰值 \n\nARC下，可以使用 @autoreleasepool 来降低内存峰值\n\n```objc\nfor (int i = 0; i < 9999; ++i)\n{\n    @autoreleasepool{\n        A *a = [[A alloc] init];\n        [self handle:a];\n    }\n}\n```\n\na 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值\n\n使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有\n```objc\n[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n    // 这里被一个局部@autoreleasepool包围着\n}];\n```\n\n另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用\n\n另外，关于降低内存峰值的之前也有学习过，见[Objective-C 内存管理](http://www.cnblogs.com/chenyg32/p/3859110.html)\n## done 第35条：用“僵尸对象”调试内存管理问题 \n僵尸对象是调试内存管理问题的最佳方式\n\n被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。\n\n打开僵尸对象的方法：\n\nXcode -> Run -> Diagnostics -> Enable Zombie Objects\n![](http://img.blog.csdn.net/20150803102818758)\n\n\n僵尸对象的原理：\n\n替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存\n\n原理代码：\n\n```objc\n// Obtain the class of the object being deallocated\nClass cls = object_getClass(self);\n\n// Get the class's name\nconst char *clsName = class_getName(cls);\n\n// Prepend _NSZombie_ to the class name\nconst char *zombieClsName = @\"_NSZombie_\" + clsName;\n\n// See if the specific zombie class exists\nClass zombieCls = objc_lookUpClass(zombieClsName);\n\n// If the specific zombie class doesn't exists,\n// then it needs to be created\n\nif(!zombieCls){\n// Obtain the template  zombie class, where the new class's \n// name is the prepended string from above\n   zombieCls = objc_duplicateClass(baseZombieCls,   \n   zombieClsName,0);\n}\n\n// Perform normal destruction of the object being deallocated\nobjc_destructInstance(self);\n\n// Set the class of the object being deallocated\n// to the zombie class\nobjc_setClass(self, zombieCls) \n\n// The class of \"self\" is now _NSZombie_OriginalClass\n```\n\n## done 第36条：不要使用retainCount \n \n# 第6章 块与大中枢派发 \n## done 第37条：理解“块”这一概念 \n\n\t在Objective-C语言中，一共有3种类型的block：\n\t_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。\n\t_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。\n\t_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。\n\n+ 全局 Block：_NSConcreteGlobalBlock\n\n    + 定义在函数外面的 block 是全局静态的，没有访问任何外部变量\n    + 定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的\n\n\t问题：那么定义在函数外部的，捕获变量的，是 global 吗？\n\n\t```objc\n\tvoid f()\n\t{\n\t    ^{ printf(\"Hello, World!\\n\"); } ();\n\t}\n\t```\n\n+ 栈 Block：_NSConcreteStackBlock\n\n\t```objc\n\tvoid f()\n\t{\n\t    char a = 'A';\n\t    ^{ printf(\"%c\\n\",a); } ();\n\t}\n\t```\n\n+ 堆 Block：_NSConcreteMallocBlock\n\n\tNSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中\n\n\t```objc\n\tvoid f()\n\t{\n\t    char a = 'A';\n\t    void (^block)() = [^{ printf(\"%c\\n\",a); } copy];\n\t}\n\t```\n\n\t\t对全局 Block 进行 copy 后，什么事也不会发生\n\t\t对栈 Block 进行 copy 后，会得到一个堆 Block\n\t\t对堆 Block 进行 copy 后，其引用计数会加1\n\n+ 例子\n\n\t```objc\n\tvoid (^blcok)();\n\tif (1)\n\t{\n\t    block = ^{\n\t        NSLog(@\"Hello\");\n\t    }\n\t}\n\tblock();\n```\n\n\tblock执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放\n\n\t正确做法是\n\n\t```objc\n\tvoid (^blcok)();\n\tif (1)\n\t{\n\t    block = [^{\n\t        NSLog(@\"Hello\");\n\t    } copy];\n\t}\n\tblock();\n\t```\n\n+ 更多细节见[《谈Objective-C block的实现》](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/)\n\n## done 第38条：为常用的块类型创建typedef \n## done 第39条：用handler块降低代码分散程度 \n## 第40条：用块引用其所属对象时不要出现保留环 \n例子1\n\n```objc\n// EOCNetworkFetcher.h\n\n#import <Foundation/Foundation.h>\n\ntypedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);\n\n@interface EOCNetworkFetcher : NSObject\n\n@property (nonatomic, strong, readonly) NSURL *url;\n\n- (id)initWithURL:(NSURL*)url;\n\n- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;\n\n@end\n```\n\n```objc\n// EOCNetworkFetcher.m\n#import \"EOCNetworkFetcher.h\"\n\n@interface EOCNetworkFetcher ()\n@property (nonatomic, strong, readwrite) NSURL *url;\n@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;\n@property (nonatomic, strong) NSData *downloadedData;\n@end\n\n\n@implementation EOCNetworkFetcher\n\n- (id)initWithURL:(NSURL*)url\n{\n\t\tif ((self = [super init])) {\n\t\t\t\t_url = url;\n\t\t}\n\t\treturn self;\n}\n\n- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion\n{\n\t\tself.completionHandler = completion;\n\t\t// Start the request\n\t\t// Request sets downloadedData property\n\t\t// When request is finished, p_requestCompleted is called\n}\n\n- (void)p_requestCompleted {\n\t\tif (_completionHandler) {\n\t\t\t\t_completionHandler(_downloadedData);\n\t\t}\n}\n\n@end\n```\n\n```objc\n@implementation EOCClass\n{\n    EOCNetworkFetcher* _networkFetcher;\n    NSData* _fetchedData;\n}\n\n- (void)downloadData\n{\n    NSURL* url = [[NSURL alloc] initWithString:@\"http://www.example.com/something.dat\"];\n\t\t\n    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];\n\n\t\t[_networkFetcher startWithCompletionHandler:^(NSData *data){\n\n\t\t\t\tNSLog(@\"Request URL %@ finished\", _networkFetcher.url);\n\t\t\t\t_fetchedData = data;\n\n\t\t}];\n}\n@end\n```\n\nEoCClass -> networkFetcher -> block -> self(通过_fetchedData)\n\n例子2\n\n将 networkFetcher 变为局部变量，修改如下：\n\n```objc\n- (void)downloadData {\n NSURL *url = [[NSURL alloc] initWithString:\n @\"http://www.example.com/something.dat\"];\n EOCNetworkFetcher *networkFetcher =\n [[EOCNetworkFetcher alloc] initWithURL:url];\n [networkFetcher startWithCompletionHandler:^(NSData *data){\n NSLog(@\"Request URL %@ finished\", networkFetcher.url);\n _fetchedData = data;\n }];\n}\n```\n\nnetworkFetcher -> block -> networkFetcher(通过url)\n\n## 第41条：多用派发队列，少用同步锁\n \n## 第42条：多用GCD，少用performSelector系列方法\n### 如何延迟执行一个方法\n```objc\n// 方法1：使用 performSelector\n[self performSelector:@selector(foo) withObject:nil afterDelay:5.0];\n\n// 方法2：使用 dispatch_after\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    [self foo];\n});\n```\n使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题\n\n当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消\n\n\n### 如何让一个方法在主线程执行\n```objc\n// 方法1：使用 performSelector\n[self performSelectorOnMainThread:@selector(foo) withObject:nil waitUntilDone:NO];\n\n// 方法2：使用 dispatch_after\ndispatch_async(dispatch_get_main_queue(), ^{\n    [self foo];\n});\n```\n使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题\n \n## 第43条：掌握GCD及操作队列的使用时机\n要知道有个东西叫做 NSOperationQueue 就行了\n## 第44条：通过Dispatch Group机制，根据系统资源状况来执行任务 \n## 第45条：使用dispatch_once来执行只需运行一次的线程安全代码\n以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once\n\n比如单例的书写方式\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n```\n\n \n## 第46条：不要使用`dispatch_get_current_queue`\n尽量别用，该接口已废弃\n \n# 第7章 系统框架 \n## 第47条：熟悉系统框架\n+ CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）\n+ CoreAudio:音频处理 API（C语言）\n+ AVFoundation:视频处理接口（Objective-C）\n+ CoreData:数据库接口（Objective-C）\n+ CoreText:文字渲染排版接口（C语言）\n \n## done 第48条：多用块枚举，少用for循环\n\n## 第49条：对自定义其内存管理语义的collection使用无缝桥接 \n### 使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge CFArrayRef)array;\nNSLog(@\"%@ count: %li\", cfArray, CFArrayGetCount(cfArray));\n```\n+ NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray\n+ CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数\n\n### 桥式转换\n+ `__bridge`：只做类型转换，不修改对象（内存）管理权；\n+ `__bridge_retained`：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；\n+ `__bridge_transfer`：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC\n\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge_retained CFArrayRef)array;\nCFRelease(cfArray);  // 因为是 __bridge_retained，所以需要调用 CFRelease\n```\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge_retained CFArrayRef)array;\nNSArray *array2 = (__bridge_transfer NSArray *)cfArray;\n//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理\n```\n\n### 使用无缝桥接修改 Collection 的内存管理语义\nNSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error\n\n关于拷贝协议可以查看：[浅析Objective-C的copy](http://www.cnblogs.com/chenyg32/p/5167194.html)\n\n无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典\n\n创建函数\n\n```objc\nCFMutableDictionaryRef CFDictionaryCreateMutable(\n    CFAllocatorRef allocator,  // 一般传NULL，采用系统默认的内存分配器\n    CFIndex capacity,          // 初始大小，并非最大容量\n    const CFDictionaryKeyCallBacks *keyCallBacks,    // 回调\n    const CFDictionaryValueCallBacks *valueCallBacks // 回调\n);\n```\n\n键值回调\n\n```objc\ntypedef struct {\n    CFIndex\t\t\t\tversion;    //一般为0\n    CFDictionaryRetainCallBack\t\tretain; //遇到retain的回调\n    CFDictionaryReleaseCallBack\t\trelease;//遇到release的回调\n    CFDictionaryCopyDescriptionCallBack\tcopyDescription;//一般传NULL，采用系统默认\n    CFDictionaryEqualCallBack\t\tequal;  //一般传CFEqual\n    CFDictionaryHashCallBack\t\thash;   //一般传CFHash\n} CFDictionaryKeyCallBacks;\n\ntypedef struct {\n    CFIndex\t\t\t\tversion;    //一般为0\n    CFDictionaryRetainCallBack\t\tretain; //遇到retain的回调\n    CFDictionaryReleaseCallBack\t\trelease;//遇到release的回调\n    CFDictionaryCopyDescriptionCallBack\tcopyDescription;    //一般传NULL，采用系统默认\n    CFDictionaryEqualCallBack\t\tequal;  //一般传CFEqual\n} CFDictionaryValueCallBacks;\n```\n\n创建“保留”键，“保留”值的 NSDictionary\n\n```objc\nconst void* EOCRetainCallback (CFAllocatorRef allocator , const void *value)\n{\n    return CFRetain(value);\n}\n\nvoid EOCReleaseCallback(CFAllocatorRef allocator , const void *value)\n{\n    CFRelease(value);\n}\n\nCFDictionaryKeyCallBacks keyCallbacks = \n{\n    0,\n    EOCRetainCallback,\n    EOCReleaseCallback,\n    NULL,\n    CFEqual,\n    CFHash\n};\n\nCFDictionaryValueCallBacks valueCallbacks = \n{\n    0,\n    EOCRetainCallback,\n    EOCReleaseCallback,\n    NULL,\n    CFEqual,\n};\n    \nCFMutableDictionaryRef aCFDictionary = CFDictionaryCreateMutable(NULL, 0, &keyCallbacks, &valueCallbacks);\nNSMutableDictionary *anNSdictionary = (__bridge_transfer NSMutableDictionary *)aCFDictionary;\n```\n\n## 第50条：构建缓存时选用NSCache而非NSDictionary \n+ 实现缓存时应选用 NSCache 而非 NSDictionary\n+ 可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据\n+ NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）\n+ NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）\n+ 使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除\n\n扩展阅读：[利用NSCache提升效率](https://www.ganlvji.com/nscache/)\n\n## 第51条：精简initialize与load的实现代码\n|           | load  | initialize |\n| :--: |:--:| :-:|\n| 执行次数   | 1次 | 1次 |\n| 执行时机   | app启动时所有运行时需要用到的类 | 惰性调用，需要使用到具体类的时候才调用 |\n| 作用      | 调试 现基本不用 |初始化全局oc对象（普通对象可以在声明的时候初始化）|\n| 执行时环境 | 系统不稳定，许多东西尚未初始化 | 系统处于正常状态 |\n| 调用顺序   | 1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类 | 跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名 |\n| 相同点    | 1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁| 同左 |\n\n### initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\n假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：\n```objc\n@interface A : NSObject\n@end\n@implementation A\n+ (void)initialize\n{\n    NSLog(@\"%@\", self);\n}\n@end\n\n@interface B : A\n@end\n@implementation B\n@end\n```\n此时创建一个B对象，输出是\n> A  \n> B\n\n初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B\n\n所以 A 的 initialize 方法应该这样写\n\n```objc\n+ (void)initialize\n{\n    if (self == [A class])\n    {\n        NSLog(@\"%@\", self);\n    }\n}\n```\n此时创建一个B对象，输出是\n> B\n\n## 第52条：别忘了NSTimer会保留其目标对象\n参见：[NSTimer 会保留目标对象](http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/)","source":"_posts/Effective-Objective-C-读书笔记.md","raw":"---\ntitle: Effective-Objective-C-读书笔记\ndescription: 《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》\ndate: 2016-03-19\ncategories:\n- 读书笔记\nphotos: \n---\n\n# 第1章 熟悉Objective—C \n## 第1条：了解Objective—C语言的起源\n```objectivec\nNSString *s1 = @\"Hello\";\nNSString *s2 = s1;\n```\n+ s1 和s2 的内存分配在栈上\n+ @\"Hello\"的内存分配在堆上\n+ s1 和 s2 指向同一块内存\n\n\n## 第2条：在类的头文件中尽量少引入其他头文件\n\n## 第3条：多用字面量语法，少用与之等价的方法\n### 使用字面量语法，它是一种语法糖：\n```objectivec\nNSString *str = @\"Hello\";\nNSNumber *intNum = @1;\nNSNumber *doubleNum = @2.5;\nNSNumber *charNum = @'a';\nNSNumber *boolNum = @YES;\nNSArray *array = @[@\"hello\", @1, @2.5, @'a'];\nNSString *str2 = array[0];\nNSDictionary *dic = @{@\"1\":@1, @\"2\":@2};\n```\n### 这个语法糖更容易暴露隐藏的问题\n```objectivec\nNSArray *array1 = [NSArray arrayWithObjects: obj1, obj2, obj3, nil];\nNSArray *array2 = @[obj1, obj2, obj3];\n```\n如果 obj1 和 obj3 非空，而 obj2 是 nil\n\n那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常\n\n### 使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\n```objectivec\nNSMuatableArray *mArray = [@[@1, @2] mutableCopy];\n```\n## 第4条：多用类型常量，少用#define预处理指令 \n详见[NSNotification Name 最佳写法](http://www.cnblogs.com/chenyg32/p/5080301.html)\n\n## 第5条：用枚举表示状态、选项、状态码\n### 使用 `NS_ENUM` 和 `NS_OPTIONS` 来表示`状态机`，\n```objectivec\n//NS_ENUM，定义状态等普通枚举\ntypedef NS_ENUM(NSUInteger, TTGState) {\n    TTGStateOK = 0,\n    TTGStateError,\n    TTGStateUnknow\n};\n\n//NS_OPTIONS，定义选项\ntypedef NS_OPTIONS(NSUInteger, TTGDirection) {\n    TTGDirectionNone = 0,\n    TTGDirectionTop = 1 << 0,\n    TTGDirectionLeft = 1 << 1,\n    TTGDirectionRight = 1 << 2,\n    TTGDirectionBottom = 1 << 3\n};\n```\n### 如果一个`枚举变量`可以同时表示一个或多个选项的集合，那么应当使用 `NS_OPTIONS`，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用`或操作`将其组合起来进行表示\n\n### 相比较 C 语言中的枚举，使用 `NS_ENUM` 和 `NS_OPTIONS` 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\n```objectivec\ntypedef enum _TTGState {\n    TTGStateOK  = 0,\n    TTGStateError,\n    TTGStateUnknow\n} TTGState;\n```\n### 处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举\n\n### 参考链接：[Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5](http://tutuge.me/2015/03/21/effective-objective-c-5-enum/)\n\n# 第2章 对象、消息、运行期 \n## 第6条：理解“属性”这一概念 \n### 理解好`属性`和`实例变量`的区别\n\n属性 = 实例变量 + setter + getter\n\n如果声明属性\n\n    @property (nonatomic, copy) NSString *str;\n\n则编译器会默认实现\n\n```objectivec\n//.h\n- (NSString *)str;\n- (void)setStr:(NSString *)str;\n\n//.m\n- (NSString *)str\n{\n\treturn _str;\n}\n\n- (void)setStr:(NSString *)str\n{\n\t_str = [str copy];\n}\n```\n其中 `_str` 就是`实例变量`\n \n### 使用`点语法`访问属性 = 调用 setter/getter 方法\n\n### Property 的4种 attribute\n\t\n+ 原子性(atomic, nonatomic)\n+ 读写权限(readonly, readwrite)\n+ 内存管理(strong, weak, unsafe_unretained, retain, assign, copy)\n+ 存取方法(getter, setter)\n\n### 非 ARC 下，没有 weak\n\n### ARC下，修饰指针的内存修饰符\n+ `__weak`:不retain，如果对象被回收，该指针会被置nil\n+ `__strong`:默认，如果对象被回收，需要手动将指针置为nil？\n+ `__unsafe__unretained`:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）\n+ `__autoreleasing`:实现把对象\"按引用传递\"给方法，变量在方法返回时自动释放\n\n编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量\n\n### 常见数据类型的内存修饰符（待补充）\n| 数据类型 | 内存修饰符 |\n| :--:|:--:|\n| 基本数据类型(int, NSInteger) | assign |\n| block | copy |\n| NSString | copy |\n| NSMutableString | strong |\n| NSArray | copy |\n| NSMutableArray | strong |\n\n### NSArray 用 strong 还是 copy 修饰\n```objc\n//.h\n@property (nonatomic, strong) NSArray *strongArray;\n@property (nonatomic, copy)   NSArray *copyedArray;\n//.m\nself.strongArray = [NSArray array];\nself.copyedArray = [NSArray array];\n    \nNSMutableArray *mutableArray = [@[@\"1\"] mutableCopy];\nself.strongArray = mutableArray;\nself.copyedArray = mutableArray;\n    \n[mutableArray addObject:@\"2\"];\n    \nNSLog(@\"%@\\n%@\\n%@\", mutableArray, self.strongArray, self.copyedArray); //输出 (1,2) (1,2) (1)\n```\n可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。\n\n\n## 第7条：在对象内部尽量直接访问实例变量\n### 类内使用 self.xxx 和 _xxx 的区别\n\n+ 访问 _xxx 不经过 setter/getter 方法，速度更快\n+ 访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作\n+ 访问 _xxx 不经过 setter/getter 方法，无法触发 KVO\n+ 访问 _xxx 不经过 setter/getter 方法，无法断点\n\n### 什么时候使用 _xxx\n\n+ 折中方案，读的时候使用 _xxx，写的时候使用 self.xxx\n+ 父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错\n+ 如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性\n+ 使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败\n```objectivec\n- (NSString *)str\n{\n\tif (!_str)\n\t\t_str = [[NSString alloc] init];\n\treturn _str;\n}\n```\n## 第8条：理解“对象等同性”这一概念 \n\n\n## 第9条：以“类族模式”隐藏实现细节 \n## 第10条：在既有类中使用关联对象存放自定义数据 \n“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性\n\n### 语法\n```objc\nvoid objc_setAssociatedObject (id object, void *key, id value, objc_AssociationPolicy policy);\n\nid objc_getAssociatedObject(id object, void *key);\n\nvoid objc_removeAssociatedObject(id object);    // 移除object上的所有关联对象\n```\n其中 objc_AssociationPolicy 是关联对象的属性，如下\n\n```objc\nOBJC_ASSOCIATION_ASSIGN             --- assign\nOBJC_ASSOCIATION_RETAIN_NONATOMIC   --- nonatomic, retain\nOBJC_ASSOCIATION_COPY_NONATOMIC     --- nonatomic, copy\nOBJC_ASSOCIATION_RETAIN             --- retain\nOBJC_ASSOCIATION_COPY               --- copy\n```\n\n### 与 NSDictionary 的区别\n设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。\n\n所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @\"xxx\"\n\n### 例子1\n假如一个页面有2个弹窗，那么代码可能是这样写\n\n```objc\n- (void)askUserAQuestion\n{\n    UIAlertView *alert = [[UIAlertView alloc]\n            initWithTitle:@\"Question\"\n                  message:@\"What do you want to do?\"\n                 delegate:self\n        cancelButtonTitle:@\"Cancel\"\n        otherButtonTitles:@\"Continue\", nil];\n    [alert show];\n}\n\n// UIAlertViewDelegate protocol method\n- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n    if (buttonIndex == 0)\n    {\n        [self doCancel];\n    }\n    else\n    {\n        [self doContinue];\n    }\n}\n```\n\n缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性\n\n```objc\n#import <objc/runtime.h>\n\nstatic void *EOCMyAlertViewKey = \"EOCMyAlertViewKey\";\n\n- (void)askUserAQuestion\n{\n\tUIAlertView *alert = [[UIAlertView alloc]\n\t        initWithTitle:@\"Question\"\n\t              message:@\"What do you want to do?\"\n\t             delegate:self\n\t    cancelButtonTitle:@\"Cancel\"\n\t    otherButtonTitles:@\"Continue\", nil];\n\n\tvoid (^block)(NSInteger) = ^(NSInteger buttonIndex) {\n\t    if (buttonIndex == 0)\n\t    {\n\t\t    [self doCancel];\n\t    }\n\t    else\n\t    {\n\t\t    [self doContinue];\n\t    }\n\t};\n\n\tobjc_setAssociatedObject(alert,\n                             EOCMyAlertViewKey,\n                             block,\n                             OBJC_ASSOCIATION_COPY);\n\n\t[alert show];\n}\n\n// UIAlertViewDelegate protocol method\n- (void)alertView:(UIAlertView *)alertView\n    clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n\tvoid (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);\n\tblock(buttonIndex);\n}\n```\n\n优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView\n\n### 例子2 为协议文件添加属性\n.h\n\n```objc\n#import \"QLJCEONAVRSSFeed.h\"\n\n@interface QLJCEONAVRSSFeed (contentOffset)\n\n@property (nonatomic, assign)CGPoint savedOffset;\n\n@end\n```\n.m\n\n```objc\n#import \"QLJCEONAVRSSFeed+contentOffset.h\"\n\n#define feed_saved_Off_set_x_key @\"feed_saved_Off_set_x_key\"\n#define feed_saved_Off_set_y_key @\"feed_saved_Off_set_y_key\"\n\n@implementation QLJCEONAVRSSFeed (contentOffset)\n\n@dynamic savedOffset;\n\n- (CGPoint)savedOffset\n{\n    NSNumber *xObj = objc_getAssociatedObject(self, feed_saved_Off_set_x_key);\n    NSNumber *yObj = objc_getAssociatedObject(self, feed_saved_Off_set_y_key);\n    \n    CGPoint point = CGPointMake([xObj floatValue], [yObj floatValue]);\n    \n    return point;\n}\n\n- (void)setSavedOffset:(CGPoint)savedOffset\n{\n    objc_setAssociatedObject(self, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    objc_setAssociatedObject(self, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n```\n\n\n## 第11条：理解objc_msgSend的作用\n见 [Objective-C中的消息转发机制](http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/)\n## 第12条：理解消息转发机制\n见 [Objective-C中的消息转发机制](http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/)\n\n \n## 第13条：用“方法调配技术”调试“黑盒方法”\n创建自己的方法\n\n```objc\n#import \"NSString+MyAdditions.h\"\n\n@implementation NSString (MyAdditions)\n- (NSString *)myLowercaseString\n{\n    NSString *lowercase = [self myLowercaseString];\n    NSLog(@\"This is my own method: %@\", lowercase);\n    return lowercase;\n}\n@end\n```\n替换\n\n```objc\nMethod originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));\nMethod swappedMethod = class_getInstanceMethod([NSString class], @selector(myLowercaseString));\nmethod_exchangeImplementations(originalMethod, swappedMethod);\n```\n\n \n## 第14条：理解“类对象”的用意 \n### 我们所说的 Objective-C 对象究竟是什么\n\n```objc\ntypedef struct objc_object{\n  Class isa;  //=> 指向对象所属的类\n} *id;\n```\n结论：Objective-C 对象 = id = objc_object\n\n### 那么 Class 是什么\n```objc\ntypedef struct objc_class *Class;  \n```\n### 那么 objc_class 又是什么\n```objc\nstruct objc_class {  \n    Class isa;\n    Class super_class;  \n    const char *name;  \n    long version;  \n    long info;  \n    long instance_size;  \n    struct objc_ivar_list *ivars;  \n    struct objc_method_list **methodLists;  \n    struct objc_cache *cache;  \n    struct objc_protocol_list *protocols;  \n}; \n```\n\n### 类的继承体系\n![](http://7xsd8c.com1.z0.glb.clouddn.com/isa.png)\n\n```objc\nNSString *str = @\"Hello\";\n```\nstr 是一个对象，is a NSString\n\nNSString 是类，is a NSString metaclass\n\nNSString metaclass 是元类，类方法就定义在这里\n\n\n# 第3章 接口与API设计 \n## done 第15条：用前缀避免命名空间冲突 \n## done 第16条：提供“全能初始化方法”\n详见[Designated Initializer](http://www.cnblogs.com/chenyg32/p/4870303.html)\n## done 第17条：实现description方法\n## done 第18条：尽量使用不可变对象\n+ 如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite\n+ 不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法\n\n## done 第19条：使用清晰而协调的命名方式:\n### 如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了\n\n### 对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX\n    @property (nonatomic, assign, getter = isOn) on;\n\n## done 第20条：为私有方法名加前缀 \n## done 第21条：理解Objective—C错误模型 \n## done 第22条：理解NSCopying协议 \n详见[浅析Objective-C的copy](http://www.cnblogs.com/chenyg32/p/5167194.html)\n \n# 第4章 协议与分类 \n## 第23条：通过委托与数据源协议进行对象间通信 \n```objc\nif([_delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)])\n{ \n    [_delegate networkFetcher:self didReceiveData:data];  \n}\n```\n\n如果上面的代码写了很多次，则可以考虑以下优化：\n\n```objc\n// 在扩展中定义结构体\n@interface EOCNetworkFetcher(\n{ \n    struct { \n    unsigned int didReceiveData : 1; \n    unsigned int didFailWithError : 1; \n    } _delegateFlags; \n} \n@end  \n\n@implementation \nEOCNetworkFetcher \n- (void)setDelegate:(id)delegate\n{ \n    _delegate = delegate; // 缓存委托对象相应方法能力 \n    _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]; \n    _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)]; \n} \n@end\n\n这样每次调用delegate相关方法之前就只需要直接查询标志：\nif(_delegateFlags.didReceiveData)\n{ \n    [_delegate networkFetcher:self didReceiveData:data]; \n}\n```\n\n## done 第24条：将类的实现代码分散到便于管理的数个分类之中 \n## 第25条：总是为第三方类的分类名称加前缀\n1. 为第三方类添加分类时，总应给其名称加上你专用的前缀\n2. 为第三方类添加分类时，总应给方法名加上你专用的前缀\n\n```objc\n@interface NSString (ABC_HTTP)\n-(NSString *)abc_urlEncodedString;\n-(NSString *)abc_urlDecodedString;\n@end\n```\n\n## 第26条：勿在分类中声明属性 \n属性应该在主类中声明\n\n如果分类中声明属性需要自己重写 setter 和 getter\n\n方法如下：\n```objc\n#import <objc/runtime.h>\n\nstatic const char *kFriendsPropertyKey = \"kFriendsPropertyKey\";\n\n@implementation Person(Friendship)\n@dynamic friends;\n\n-(NSArray*)friends \n{\n　　return objc_getAssociatedObject(self, kFriendsPropertyKey);\n}\n\n-(void)setFriends:(NSArray*)friends \n{\n　　objc_setAssociaedObject(self, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);\n}\n@end\n```\n\n缺点如下\n1. 相似的代码要写很多遍\n2. 极易忽略属性定义的内存管理语义，且不好维护\n\n## 第27条：使用“class—continuation分类”隐藏实现细节\n声明私有实例变量的3种方法\n\n+ 方法1：对外暴露，声明为 private（暴露了细节，不建议）\n\n    .h\n\n    ```objectivec\n    @interface ABC:NSObject\n    {\n    @private\n        XYZ *_xyz;\n    }\n    @end\n    ```\n    1. 把私有变量放在头文件，暴露了细节，不好\n    2. 假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题\n    3. 所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？\n    \n    \n+ 方法2：不对外暴露\n\n    .m\n    \n    ```objectivec\n    @interface ABC()\n    {\n        XYZ *_xyz;\n    }\n    @property (nonatomic, strong) XYZ *xyz2;\n    @end\n    ```\n+ 方法3：对外只读，对内读写\n\n    .h\n    \n    ```objectivec\n    @property (nonatomic, readonly) XYZ *xyz;\n    ```\n    .m\n    \n    ```objectivec\n    @interface ABC()\n    @property (nonatomic, readwrite) XYZ *xyz;\n    @end\n    ```\n\n## done 第28条：通过协议提供匿名对象 \n\n# 第5章 内存管理 \n## 第29条：理解引用计数 \n### 悬浮指针\n\n```objectivec\nNSNumber *number = [[NSNumber alloc] initWithInt:1];\n[array addObject:number];\n[number release];\nnumber = nil;   //如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知\n```\n\n### autorelease\n\n```objectivec\n- (NSString *)stringValue\n{\n    NSString *str = [[NSString alloc] initWithFormat:@\"Hello\"];\n    return str;\n}\n```\n这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放\n\n但是，这是十分不合理的，因为从方法名上看（不含`alloc/new/copy/mutableCopy`），调用者并不知道它需要负责释放该对象\n\n所以此时，autorelease 就应运而生了\n\n```objectivec\n- (NSString *)stringValue\n{\n    NSString *str = [[NSString alloc] initWithFormat:@\"Hello\"];\n    return [str autorelease];\n}\n```\n\nstr 对象会在其所在的释放池释放的时候被释放\n\n如果外部需要 retain 该返回值，则需要这样做\n\n```objectivec\nNSString *str = [[self stringValue] retain];\n// ...\n[str release];\n```\n\n> autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间\n\n## 第30条：以ARC简化引用计数\n### ARC 的本质是自动添加 release/retian/autorelease 等\n```objectivec\n+ (XYZ *)newXYZ\n{\n    XYZ *xyz = [[XYZ alloc] init];\n    return xyz;\n}\n\n+ (XYZ *)createXYZ\n{\n    XYZ *xyz = [[XYZ alloc] init];\n    /*ARC自动添加\n    xyz = [xyz autorelease];\n     */\n    return xyz;\n}\n\n- (void)f\n{\n    XYZ *xyz1 = [XYZ newXYZ];\n    XYZ *xyz2 = [XYZ createXYZ];\n    /*ARC自动添加\n    [xyz1 release];\n     */\n}\n```\n\n### 扩展阅读：[iOS开发ARC内存管理技术要点](http://www.cnblogs.com/flyFreeZn/p/4264220.html)\n\n## done 第31条：在dealloc方法中只释放引用并解除监听 \n## done 第32条：编写“异常安全代码”时留意内存管理问题 \n```objc\n@try {\n EOCSomeClass *object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];\n [object release];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏\n\n解决方法：\n\n```objc\nEOCSomeClass *object;\n@try {\n object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n@finally {\n [object release];\n}\n```\n\n同理，ARC 下也会发生这个问题\n\n```objc\n@try {\n EOCSomeClass *object = [[EOCSomeClass alloc] init];\n [object doSomethingThatMayThrow];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题\n\n总结：\n\n1. 当捕获到异常,应该注意确保@try中创建的对象被清理完成.\n2. ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.\n\n\n## done 第33条：以弱引用避免保留环 \n## done 第34条：以“自动释放池块”降低内存峰值 \n\nARC下，可以使用 @autoreleasepool 来降低内存峰值\n\n```objc\nfor (int i = 0; i < 9999; ++i)\n{\n    @autoreleasepool{\n        A *a = [[A alloc] init];\n        [self handle:a];\n    }\n}\n```\n\na 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值\n\n使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有\n```objc\n[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n    // 这里被一个局部@autoreleasepool包围着\n}];\n```\n\n另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用\n\n另外，关于降低内存峰值的之前也有学习过，见[Objective-C 内存管理](http://www.cnblogs.com/chenyg32/p/3859110.html)\n## done 第35条：用“僵尸对象”调试内存管理问题 \n僵尸对象是调试内存管理问题的最佳方式\n\n被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。\n\n打开僵尸对象的方法：\n\nXcode -> Run -> Diagnostics -> Enable Zombie Objects\n![](http://img.blog.csdn.net/20150803102818758)\n\n\n僵尸对象的原理：\n\n替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存\n\n原理代码：\n\n```objc\n// Obtain the class of the object being deallocated\nClass cls = object_getClass(self);\n\n// Get the class's name\nconst char *clsName = class_getName(cls);\n\n// Prepend _NSZombie_ to the class name\nconst char *zombieClsName = @\"_NSZombie_\" + clsName;\n\n// See if the specific zombie class exists\nClass zombieCls = objc_lookUpClass(zombieClsName);\n\n// If the specific zombie class doesn't exists,\n// then it needs to be created\n\nif(!zombieCls){\n// Obtain the template  zombie class, where the new class's \n// name is the prepended string from above\n   zombieCls = objc_duplicateClass(baseZombieCls,   \n   zombieClsName,0);\n}\n\n// Perform normal destruction of the object being deallocated\nobjc_destructInstance(self);\n\n// Set the class of the object being deallocated\n// to the zombie class\nobjc_setClass(self, zombieCls) \n\n// The class of \"self\" is now _NSZombie_OriginalClass\n```\n\n## done 第36条：不要使用retainCount \n \n# 第6章 块与大中枢派发 \n## done 第37条：理解“块”这一概念 \n\n\t在Objective-C语言中，一共有3种类型的block：\n\t_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。\n\t_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。\n\t_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。\n\n+ 全局 Block：_NSConcreteGlobalBlock\n\n    + 定义在函数外面的 block 是全局静态的，没有访问任何外部变量\n    + 定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的\n\n\t问题：那么定义在函数外部的，捕获变量的，是 global 吗？\n\n\t```objc\n\tvoid f()\n\t{\n\t    ^{ printf(\"Hello, World!\\n\"); } ();\n\t}\n\t```\n\n+ 栈 Block：_NSConcreteStackBlock\n\n\t```objc\n\tvoid f()\n\t{\n\t    char a = 'A';\n\t    ^{ printf(\"%c\\n\",a); } ();\n\t}\n\t```\n\n+ 堆 Block：_NSConcreteMallocBlock\n\n\tNSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中\n\n\t```objc\n\tvoid f()\n\t{\n\t    char a = 'A';\n\t    void (^block)() = [^{ printf(\"%c\\n\",a); } copy];\n\t}\n\t```\n\n\t\t对全局 Block 进行 copy 后，什么事也不会发生\n\t\t对栈 Block 进行 copy 后，会得到一个堆 Block\n\t\t对堆 Block 进行 copy 后，其引用计数会加1\n\n+ 例子\n\n\t```objc\n\tvoid (^blcok)();\n\tif (1)\n\t{\n\t    block = ^{\n\t        NSLog(@\"Hello\");\n\t    }\n\t}\n\tblock();\n```\n\n\tblock执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放\n\n\t正确做法是\n\n\t```objc\n\tvoid (^blcok)();\n\tif (1)\n\t{\n\t    block = [^{\n\t        NSLog(@\"Hello\");\n\t    } copy];\n\t}\n\tblock();\n\t```\n\n+ 更多细节见[《谈Objective-C block的实现》](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/)\n\n## done 第38条：为常用的块类型创建typedef \n## done 第39条：用handler块降低代码分散程度 \n## 第40条：用块引用其所属对象时不要出现保留环 \n例子1\n\n```objc\n// EOCNetworkFetcher.h\n\n#import <Foundation/Foundation.h>\n\ntypedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);\n\n@interface EOCNetworkFetcher : NSObject\n\n@property (nonatomic, strong, readonly) NSURL *url;\n\n- (id)initWithURL:(NSURL*)url;\n\n- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;\n\n@end\n```\n\n```objc\n// EOCNetworkFetcher.m\n#import \"EOCNetworkFetcher.h\"\n\n@interface EOCNetworkFetcher ()\n@property (nonatomic, strong, readwrite) NSURL *url;\n@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;\n@property (nonatomic, strong) NSData *downloadedData;\n@end\n\n\n@implementation EOCNetworkFetcher\n\n- (id)initWithURL:(NSURL*)url\n{\n\t\tif ((self = [super init])) {\n\t\t\t\t_url = url;\n\t\t}\n\t\treturn self;\n}\n\n- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion\n{\n\t\tself.completionHandler = completion;\n\t\t// Start the request\n\t\t// Request sets downloadedData property\n\t\t// When request is finished, p_requestCompleted is called\n}\n\n- (void)p_requestCompleted {\n\t\tif (_completionHandler) {\n\t\t\t\t_completionHandler(_downloadedData);\n\t\t}\n}\n\n@end\n```\n\n```objc\n@implementation EOCClass\n{\n    EOCNetworkFetcher* _networkFetcher;\n    NSData* _fetchedData;\n}\n\n- (void)downloadData\n{\n    NSURL* url = [[NSURL alloc] initWithString:@\"http://www.example.com/something.dat\"];\n\t\t\n    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];\n\n\t\t[_networkFetcher startWithCompletionHandler:^(NSData *data){\n\n\t\t\t\tNSLog(@\"Request URL %@ finished\", _networkFetcher.url);\n\t\t\t\t_fetchedData = data;\n\n\t\t}];\n}\n@end\n```\n\nEoCClass -> networkFetcher -> block -> self(通过_fetchedData)\n\n例子2\n\n将 networkFetcher 变为局部变量，修改如下：\n\n```objc\n- (void)downloadData {\n NSURL *url = [[NSURL alloc] initWithString:\n @\"http://www.example.com/something.dat\"];\n EOCNetworkFetcher *networkFetcher =\n [[EOCNetworkFetcher alloc] initWithURL:url];\n [networkFetcher startWithCompletionHandler:^(NSData *data){\n NSLog(@\"Request URL %@ finished\", networkFetcher.url);\n _fetchedData = data;\n }];\n}\n```\n\nnetworkFetcher -> block -> networkFetcher(通过url)\n\n## 第41条：多用派发队列，少用同步锁\n \n## 第42条：多用GCD，少用performSelector系列方法\n### 如何延迟执行一个方法\n```objc\n// 方法1：使用 performSelector\n[self performSelector:@selector(foo) withObject:nil afterDelay:5.0];\n\n// 方法2：使用 dispatch_after\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    [self foo];\n});\n```\n使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题\n\n当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消\n\n\n### 如何让一个方法在主线程执行\n```objc\n// 方法1：使用 performSelector\n[self performSelectorOnMainThread:@selector(foo) withObject:nil waitUntilDone:NO];\n\n// 方法2：使用 dispatch_after\ndispatch_async(dispatch_get_main_queue(), ^{\n    [self foo];\n});\n```\n使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题\n \n## 第43条：掌握GCD及操作队列的使用时机\n要知道有个东西叫做 NSOperationQueue 就行了\n## 第44条：通过Dispatch Group机制，根据系统资源状况来执行任务 \n## 第45条：使用dispatch_once来执行只需运行一次的线程安全代码\n以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once\n\n比如单例的书写方式\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n```\n\n \n## 第46条：不要使用`dispatch_get_current_queue`\n尽量别用，该接口已废弃\n \n# 第7章 系统框架 \n## 第47条：熟悉系统框架\n+ CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）\n+ CoreAudio:音频处理 API（C语言）\n+ AVFoundation:视频处理接口（Objective-C）\n+ CoreData:数据库接口（Objective-C）\n+ CoreText:文字渲染排版接口（C语言）\n \n## done 第48条：多用块枚举，少用for循环\n\n## 第49条：对自定义其内存管理语义的collection使用无缝桥接 \n### 使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge CFArrayRef)array;\nNSLog(@\"%@ count: %li\", cfArray, CFArrayGetCount(cfArray));\n```\n+ NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray\n+ CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数\n\n### 桥式转换\n+ `__bridge`：只做类型转换，不修改对象（内存）管理权；\n+ `__bridge_retained`：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；\n+ `__bridge_transfer`：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC\n\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge_retained CFArrayRef)array;\nCFRelease(cfArray);  // 因为是 __bridge_retained，所以需要调用 CFRelease\n```\n```objc\nNSArray *array = @[@1, @2, @3];\nCFArrayRef cfArray = (__bridge_retained CFArrayRef)array;\nNSArray *array2 = (__bridge_transfer NSArray *)cfArray;\n//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理\n```\n\n### 使用无缝桥接修改 Collection 的内存管理语义\nNSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error\n\n关于拷贝协议可以查看：[浅析Objective-C的copy](http://www.cnblogs.com/chenyg32/p/5167194.html)\n\n无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典\n\n创建函数\n\n```objc\nCFMutableDictionaryRef CFDictionaryCreateMutable(\n    CFAllocatorRef allocator,  // 一般传NULL，采用系统默认的内存分配器\n    CFIndex capacity,          // 初始大小，并非最大容量\n    const CFDictionaryKeyCallBacks *keyCallBacks,    // 回调\n    const CFDictionaryValueCallBacks *valueCallBacks // 回调\n);\n```\n\n键值回调\n\n```objc\ntypedef struct {\n    CFIndex\t\t\t\tversion;    //一般为0\n    CFDictionaryRetainCallBack\t\tretain; //遇到retain的回调\n    CFDictionaryReleaseCallBack\t\trelease;//遇到release的回调\n    CFDictionaryCopyDescriptionCallBack\tcopyDescription;//一般传NULL，采用系统默认\n    CFDictionaryEqualCallBack\t\tequal;  //一般传CFEqual\n    CFDictionaryHashCallBack\t\thash;   //一般传CFHash\n} CFDictionaryKeyCallBacks;\n\ntypedef struct {\n    CFIndex\t\t\t\tversion;    //一般为0\n    CFDictionaryRetainCallBack\t\tretain; //遇到retain的回调\n    CFDictionaryReleaseCallBack\t\trelease;//遇到release的回调\n    CFDictionaryCopyDescriptionCallBack\tcopyDescription;    //一般传NULL，采用系统默认\n    CFDictionaryEqualCallBack\t\tequal;  //一般传CFEqual\n} CFDictionaryValueCallBacks;\n```\n\n创建“保留”键，“保留”值的 NSDictionary\n\n```objc\nconst void* EOCRetainCallback (CFAllocatorRef allocator , const void *value)\n{\n    return CFRetain(value);\n}\n\nvoid EOCReleaseCallback(CFAllocatorRef allocator , const void *value)\n{\n    CFRelease(value);\n}\n\nCFDictionaryKeyCallBacks keyCallbacks = \n{\n    0,\n    EOCRetainCallback,\n    EOCReleaseCallback,\n    NULL,\n    CFEqual,\n    CFHash\n};\n\nCFDictionaryValueCallBacks valueCallbacks = \n{\n    0,\n    EOCRetainCallback,\n    EOCReleaseCallback,\n    NULL,\n    CFEqual,\n};\n    \nCFMutableDictionaryRef aCFDictionary = CFDictionaryCreateMutable(NULL, 0, &keyCallbacks, &valueCallbacks);\nNSMutableDictionary *anNSdictionary = (__bridge_transfer NSMutableDictionary *)aCFDictionary;\n```\n\n## 第50条：构建缓存时选用NSCache而非NSDictionary \n+ 实现缓存时应选用 NSCache 而非 NSDictionary\n+ 可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据\n+ NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）\n+ NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）\n+ 使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除\n\n扩展阅读：[利用NSCache提升效率](https://www.ganlvji.com/nscache/)\n\n## 第51条：精简initialize与load的实现代码\n|           | load  | initialize |\n| :--: |:--:| :-:|\n| 执行次数   | 1次 | 1次 |\n| 执行时机   | app启动时所有运行时需要用到的类 | 惰性调用，需要使用到具体类的时候才调用 |\n| 作用      | 调试 现基本不用 |初始化全局oc对象（普通对象可以在声明的时候初始化）|\n| 执行时环境 | 系统不稳定，许多东西尚未初始化 | 系统处于正常状态 |\n| 调用顺序   | 1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类 | 跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名 |\n| 相同点    | 1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁| 同左 |\n\n### initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\n假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：\n```objc\n@interface A : NSObject\n@end\n@implementation A\n+ (void)initialize\n{\n    NSLog(@\"%@\", self);\n}\n@end\n\n@interface B : A\n@end\n@implementation B\n@end\n```\n此时创建一个B对象，输出是\n> A  \n> B\n\n初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B\n\n所以 A 的 initialize 方法应该这样写\n\n```objc\n+ (void)initialize\n{\n    if (self == [A class])\n    {\n        NSLog(@\"%@\", self);\n    }\n}\n```\n此时创建一个B对象，输出是\n> B\n\n## 第52条：别忘了NSTimer会保留其目标对象\n参见：[NSTimer 会保留目标对象](http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/)","slug":"Effective-Objective-C-读书笔记","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","link":"","_id":"cje87q0930005tjqw9d1ffoxo","content":"<h1 id=\"第1章-熟悉Objective—C\"><a href=\"#第1章-熟悉Objective—C\" class=\"headerlink\" title=\"第1章 熟悉Objective—C\"></a>第1章 熟悉Objective—C</h1><h2 id=\"第1条：了解Objective—C语言的起源\"><a href=\"#第1条：了解Objective—C语言的起源\" class=\"headerlink\" title=\"第1条：了解Objective—C语言的起源\"></a>第1条：了解Objective—C语言的起源</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *s1 = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *s2 = s1;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>s1 和s2 的内存分配在栈上</li>\n<li>@”Hello”的内存分配在堆上</li>\n<li>s1 和 s2 指向同一块内存</li>\n</ul>\n<h2 id=\"第2条：在类的头文件中尽量少引入其他头文件\"><a href=\"#第2条：在类的头文件中尽量少引入其他头文件\" class=\"headerlink\" title=\"第2条：在类的头文件中尽量少引入其他头文件\"></a>第2条：在类的头文件中尽量少引入其他头文件</h2><h2 id=\"第3条：多用字面量语法，少用与之等价的方法\"><a href=\"#第3条：多用字面量语法，少用与之等价的方法\" class=\"headerlink\" title=\"第3条：多用字面量语法，少用与之等价的方法\"></a>第3条：多用字面量语法，少用与之等价的方法</h2><h3 id=\"使用字面量语法，它是一种语法糖：\"><a href=\"#使用字面量语法，它是一种语法糖：\" class=\"headerlink\" title=\"使用字面量语法，它是一种语法糖：\"></a>使用字面量语法，它是一种语法糖：</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *intNum = @<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *doubleNum = @<span class=\"number\">2.5</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *charNum = @<span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *boolNum = @YES;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"hello\"</span>, @<span class=\"number\">1</span>, @<span class=\"number\">2.5</span>, @<span class=\"string\">'a'</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *str2 = array[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dic = @&#123;<span class=\"string\">@\"1\"</span>:@<span class=\"number\">1</span>, <span class=\"string\">@\"2\"</span>:@<span class=\"number\">2</span>&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"这个语法糖更容易暴露隐藏的问题\"><a href=\"#这个语法糖更容易暴露隐藏的问题\" class=\"headerlink\" title=\"这个语法糖更容易暴露隐藏的问题\"></a>这个语法糖更容易暴露隐藏的问题</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array1 = [<span class=\"built_in\">NSArray</span> arrayWithObjects: obj1, obj2, obj3, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array2 = @[obj1, obj2, obj3];</span><br></pre></td></tr></table></figure>\n<p>如果 obj1 和 obj3 非空，而 obj2 是 nil</p>\n<p>那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常</p>\n<h3 id=\"使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\"><a href=\"#使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\" class=\"headerlink\" title=\"使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\"></a>使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMuatableArray</span> *mArray = [@[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>] mutableCopy];</span><br></pre></td></tr></table></figure>\n<h2 id=\"第4条：多用类型常量，少用-define预处理指令\"><a href=\"#第4条：多用类型常量，少用-define预处理指令\" class=\"headerlink\" title=\"第4条：多用类型常量，少用#define预处理指令\"></a>第4条：多用类型常量，少用#define预处理指令</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/5080301.html\" target=\"_blank\" rel=\"noopener\">NSNotification Name 最佳写法</a></p>\n<h2 id=\"第5条：用枚举表示状态、选项、状态码\"><a href=\"#第5条：用枚举表示状态、选项、状态码\" class=\"headerlink\" title=\"第5条：用枚举表示状态、选项、状态码\"></a>第5条：用枚举表示状态、选项、状态码</h2><h3 id=\"使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，\"><a href=\"#使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，\" class=\"headerlink\" title=\"使用 NS_ENUM 和 NS_OPTIONS 来表示状态机，\"></a>使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 来表示<code>状态机</code>，</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NS_ENUM，定义状态等普通枚举</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, TTGState) &#123;</span><br><span class=\"line\">    TTGStateOK = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGStateError,</span><br><span class=\"line\">    TTGStateUnknow</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NS_OPTIONS，定义选项</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, TTGDirection) &#123;</span><br><span class=\"line\">    TTGDirectionNone = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGDirectionTop = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGDirectionLeft = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">    TTGDirectionRight = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">    TTGDirectionBottom = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示\"><a href=\"#如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示\" class=\"headerlink\" title=\"如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用 NS_OPTIONS，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用或操作将其组合起来进行表示\"></a>如果一个<code>枚举变量</code>可以同时表示一个或多个选项的集合，那么应当使用 <code>NS_OPTIONS</code>，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用<code>或操作</code>将其组合起来进行表示</h3><h3 id=\"相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\"><a href=\"#相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\" class=\"headerlink\" title=\"相比较 C 语言中的枚举，使用 NS_ENUM 和 NS_OPTIONS 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\"></a>相比较 C 语言中的枚举，使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> _TTGState &#123;</span><br><span class=\"line\">    TTGStateOK  = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGStateError,</span><br><span class=\"line\">    TTGStateUnknow</span><br><span class=\"line\">&#125; TTGState;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举\"><a href=\"#处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举\" class=\"headerlink\" title=\"处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举\"></a>处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举</h3><h3 id=\"参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\"><a href=\"#参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\" class=\"headerlink\" title=\"参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\"></a>参考链接：<a href=\"http://tutuge.me/2015/03/21/effective-objective-c-5-enum/\" target=\"_blank\" rel=\"noopener\">Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5</a></h3><h1 id=\"第2章-对象、消息、运行期\"><a href=\"#第2章-对象、消息、运行期\" class=\"headerlink\" title=\"第2章 对象、消息、运行期\"></a>第2章 对象、消息、运行期</h1><h2 id=\"第6条：理解“属性”这一概念\"><a href=\"#第6条：理解“属性”这一概念\" class=\"headerlink\" title=\"第6条：理解“属性”这一概念\"></a>第6条：理解“属性”这一概念</h2><h3 id=\"理解好属性和实例变量的区别\"><a href=\"#理解好属性和实例变量的区别\" class=\"headerlink\" title=\"理解好属性和实例变量的区别\"></a>理解好<code>属性</code>和<code>实例变量</code>的区别</h3><p>属性 = 实例变量 + setter + getter</p>\n<p>如果声明属性</p>\n<pre><code>@property (nonatomic, copy) NSString *str;\n</code></pre><p>则编译器会默认实现</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setStr:(<span class=\"built_in\">NSString</span> *)str;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setStr:(<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_str = [str <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>_str</code> 就是<code>实例变量</code></p>\n<h3 id=\"使用点语法访问属性-调用-setter-getter-方法\"><a href=\"#使用点语法访问属性-调用-setter-getter-方法\" class=\"headerlink\" title=\"使用点语法访问属性 = 调用 setter/getter 方法\"></a>使用<code>点语法</code>访问属性 = 调用 setter/getter 方法</h3><h3 id=\"Property-的4种-attribute\"><a href=\"#Property-的4种-attribute\" class=\"headerlink\" title=\"Property 的4种 attribute\"></a>Property 的4种 attribute</h3><ul>\n<li>原子性(atomic, nonatomic)</li>\n<li>读写权限(readonly, readwrite)</li>\n<li>内存管理(strong, weak, unsafe_unretained, retain, assign, copy)</li>\n<li>存取方法(getter, setter)</li>\n</ul>\n<h3 id=\"非-ARC-下，没有-weak\"><a href=\"#非-ARC-下，没有-weak\" class=\"headerlink\" title=\"非 ARC 下，没有 weak\"></a>非 ARC 下，没有 weak</h3><h3 id=\"ARC下，修饰指针的内存修饰符\"><a href=\"#ARC下，修饰指针的内存修饰符\" class=\"headerlink\" title=\"ARC下，修饰指针的内存修饰符\"></a>ARC下，修饰指针的内存修饰符</h3><ul>\n<li><code>__weak</code>:不retain，如果对象被回收，该指针会被置nil</li>\n<li><code>__strong</code>:默认，如果对象被回收，需要手动将指针置为nil？</li>\n<li><code>__unsafe__unretained</code>:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）</li>\n<li><code>__autoreleasing</code>:实现把对象”按引用传递”给方法，变量在方法返回时自动释放</li>\n</ul>\n<p>编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量</p>\n<h3 id=\"常见数据类型的内存修饰符（待补充）\"><a href=\"#常见数据类型的内存修饰符（待补充）\" class=\"headerlink\" title=\"常见数据类型的内存修饰符（待补充）\"></a>常见数据类型的内存修饰符（待补充）</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">内存修饰符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">基本数据类型(int, NSInteger)</td>\n<td style=\"text-align:center\">assign</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">block</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSString</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableString</td>\n<td style=\"text-align:center\">strong</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSArray</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableArray</td>\n<td style=\"text-align:center\">strong</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"NSArray-用-strong-还是-copy-修饰\"><a href=\"#NSArray-用-strong-还是-copy-修饰\" class=\"headerlink\" title=\"NSArray 用 strong 还是 copy 修饰\"></a>NSArray 用 strong 还是 copy 修饰</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> *strongArray;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>)   <span class=\"built_in\">NSArray</span> *copyedArray;</span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongArray = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyedArray = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableArray = [@[<span class=\"string\">@\"1\"</span>] mutableCopy];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongArray = mutableArray;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyedArray = mutableArray;</span><br><span class=\"line\">    </span><br><span class=\"line\">[mutableArray addObject:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\\n%@\\n%@\"</span>, mutableArray, <span class=\"keyword\">self</span>.strongArray, <span class=\"keyword\">self</span>.copyedArray); <span class=\"comment\">//输出 (1,2) (1,2) (1)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。</p>\n<h2 id=\"第7条：在对象内部尽量直接访问实例变量\"><a href=\"#第7条：在对象内部尽量直接访问实例变量\" class=\"headerlink\" title=\"第7条：在对象内部尽量直接访问实例变量\"></a>第7条：在对象内部尽量直接访问实例变量</h2><h3 id=\"类内使用-self-xxx-和-xxx-的区别\"><a href=\"#类内使用-self-xxx-和-xxx-的区别\" class=\"headerlink\" title=\"类内使用 self.xxx 和 _xxx 的区别\"></a>类内使用 self.xxx 和 _xxx 的区别</h3><ul>\n<li>访问 _xxx 不经过 setter/getter 方法，速度更快</li>\n<li>访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作</li>\n<li>访问 _xxx 不经过 setter/getter 方法，无法触发 KVO</li>\n<li>访问 _xxx 不经过 setter/getter 方法，无法断点</li>\n</ul>\n<h3 id=\"什么时候使用-xxx\"><a href=\"#什么时候使用-xxx\" class=\"headerlink\" title=\"什么时候使用 _xxx\"></a>什么时候使用 _xxx</h3><ul>\n<li>折中方案，读的时候使用 _xxx，写的时候使用 self.xxx</li>\n<li>父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错</li>\n<li>如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性</li>\n<li>使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!_str)</span><br><span class=\"line\">\t\t_str = [[<span class=\"built_in\">NSString</span> alloc] init];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"第8条：理解“对象等同性”这一概念\"><a href=\"#第8条：理解“对象等同性”这一概念\" class=\"headerlink\" title=\"第8条：理解“对象等同性”这一概念\"></a>第8条：理解“对象等同性”这一概念</h2><h2 id=\"第9条：以“类族模式”隐藏实现细节\"><a href=\"#第9条：以“类族模式”隐藏实现细节\" class=\"headerlink\" title=\"第9条：以“类族模式”隐藏实现细节\"></a>第9条：以“类族模式”隐藏实现细节</h2><h2 id=\"第10条：在既有类中使用关联对象存放自定义数据\"><a href=\"#第10条：在既有类中使用关联对象存放自定义数据\" class=\"headerlink\" title=\"第10条：在既有类中使用关联对象存放自定义数据\"></a>第10条：在既有类中使用关联对象存放自定义数据</h2><p>“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> objc_setAssociatedObject (<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> objc_getAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> objc_removeAssociatedObject(<span class=\"keyword\">id</span> object);    <span class=\"comment\">// 移除object上的所有关联对象</span></span><br></pre></td></tr></table></figure>\n<p>其中 objc_AssociationPolicy 是关联对象的属性，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_ASSOCIATION_ASSIGN             --- <span class=\"keyword\">assign</span></span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN_NONATOMIC   --- <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span></span><br><span class=\"line\">OBJC_ASSOCIATION_COPY_NONATOMIC     --- <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span></span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN             --- <span class=\"keyword\">retain</span></span><br><span class=\"line\">OBJC_ASSOCIATION_COPY               --- <span class=\"keyword\">copy</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"与-NSDictionary-的区别\"><a href=\"#与-NSDictionary-的区别\" class=\"headerlink\" title=\"与 NSDictionary 的区别\"></a>与 NSDictionary 的区别</h3><p>设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。</p>\n<p>所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @”xxx”</p>\n<h3 id=\"例子1\"><a href=\"#例子1\" class=\"headerlink\" title=\"例子1\"></a>例子1</h3><p>假如一个页面有2个弹窗，那么代码可能是这样写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)askUserAQuestion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]</span><br><span class=\"line\">            initWithTitle:<span class=\"string\">@\"Question\"</span></span><br><span class=\"line\">                  message:<span class=\"string\">@\"What do you want to do?\"</span></span><br><span class=\"line\">                 delegate:<span class=\"keyword\">self</span></span><br><span class=\"line\">        cancelButtonTitle:<span class=\"string\">@\"Cancel\"</span></span><br><span class=\"line\">        otherButtonTitles:<span class=\"string\">@\"Continue\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [alert show];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UIAlertViewDelegate protocol method</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)alertView:(<span class=\"built_in\">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class=\"built_in\">NSInteger</span>)buttonIndex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buttonIndex == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doCancel];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doContinue];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *EOCMyAlertViewKey = <span class=\"string\">\"EOCMyAlertViewKey\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)askUserAQuestion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]</span><br><span class=\"line\">\t        initWithTitle:<span class=\"string\">@\"Question\"</span></span><br><span class=\"line\">\t              message:<span class=\"string\">@\"What do you want to do?\"</span></span><br><span class=\"line\">\t             delegate:<span class=\"keyword\">self</span></span><br><span class=\"line\">\t    cancelButtonTitle:<span class=\"string\">@\"Cancel\"</span></span><br><span class=\"line\">\t    otherButtonTitles:<span class=\"string\">@\"Continue\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (^block)(<span class=\"built_in\">NSInteger</span>) = ^(<span class=\"built_in\">NSInteger</span> buttonIndex) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (buttonIndex == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\t    [<span class=\"keyword\">self</span> doCancel];</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"keyword\">else</span></span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\t    [<span class=\"keyword\">self</span> doContinue];</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tobjc_setAssociatedObject(alert,</span><br><span class=\"line\">                             EOCMyAlertViewKey,</span><br><span class=\"line\">                             block,</span><br><span class=\"line\">                             OBJC_ASSOCIATION_COPY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t[alert show];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UIAlertViewDelegate protocol method</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)alertView:(<span class=\"built_in\">UIAlertView</span> *)alertView</span><br><span class=\"line\">    clickedButtonAtIndex:(<span class=\"built_in\">NSInteger</span>)buttonIndex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (^block)(<span class=\"built_in\">NSInteger</span>) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);</span><br><span class=\"line\">\tblock(buttonIndex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView</p>\n<h3 id=\"例子2-为协议文件添加属性\"><a href=\"#例子2-为协议文件添加属性\" class=\"headerlink\" title=\"例子2 为协议文件添加属性\"></a>例子2 为协议文件添加属性</h3><p>.h</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"QLJCEONAVRSSFeed.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">QLJCEONAVRSSFeed</span> (<span class=\"title\">contentOffset</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>)<span class=\"built_in\">CGPoint</span> savedOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"QLJCEONAVRSSFeed+contentOffset.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define feed_saved_Off_set_x_key @<span class=\"meta-string\">\"feed_saved_Off_set_x_key\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#define feed_saved_Off_set_y_key @<span class=\"meta-string\">\"feed_saved_Off_set_y_key\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">QLJCEONAVRSSFeed</span> (<span class=\"title\">contentOffset</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> savedOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGPoint</span>)savedOffset</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *xObj = objc_getAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_x_key);</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *yObj = objc_getAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_y_key);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> point = <span class=\"built_in\">CGPointMake</span>([xObj floatValue], [yObj floatValue]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> point;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSavedOffset:(<span class=\"built_in\">CGPoint</span>)savedOffset</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第11条：理解objc-msgSend的作用\"><a href=\"#第11条：理解objc-msgSend的作用\" class=\"headerlink\" title=\"第11条：理解objc_msgSend的作用\"></a>第11条：理解objc_msgSend的作用</h2><p>见 <a href=\"http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">Objective-C中的消息转发机制</a></p>\n<h2 id=\"第12条：理解消息转发机制\"><a href=\"#第12条：理解消息转发机制\" class=\"headerlink\" title=\"第12条：理解消息转发机制\"></a>第12条：理解消息转发机制</h2><p>见 <a href=\"http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">Objective-C中的消息转发机制</a></p>\n<h2 id=\"第13条：用“方法调配技术”调试“黑盒方法”\"><a href=\"#第13条：用“方法调配技术”调试“黑盒方法”\" class=\"headerlink\" title=\"第13条：用“方法调配技术”调试“黑盒方法”\"></a>第13条：用“方法调配技术”调试“黑盒方法”</h2><p>创建自己的方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSString+MyAdditions.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSString</span> (<span class=\"title\">MyAdditions</span>)</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)myLowercaseString</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *lowercase = [<span class=\"keyword\">self</span> myLowercaseString];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"This is my own method: %@\"</span>, lowercase);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lowercase;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>替换</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method originalMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(lowercaseString));</span><br><span class=\"line\">Method swappedMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(myLowercaseString));</span><br><span class=\"line\">method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure>\n<h2 id=\"第14条：理解“类对象”的用意\"><a href=\"#第14条：理解“类对象”的用意\" class=\"headerlink\" title=\"第14条：理解“类对象”的用意\"></a>第14条：理解“类对象”的用意</h2><h3 id=\"我们所说的-Objective-C-对象究竟是什么\"><a href=\"#我们所说的-Objective-C-对象究竟是什么\" class=\"headerlink\" title=\"我们所说的 Objective-C 对象究竟是什么\"></a>我们所说的 Objective-C 对象究竟是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object&#123;</span><br><span class=\"line\">  Class isa;  <span class=\"comment\">//=&gt; 指向对象所属的类</span></span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>结论：Objective-C 对象 = id = objc_object</p>\n<h3 id=\"那么-Class-是什么\"><a href=\"#那么-Class-是什么\" class=\"headerlink\" title=\"那么 Class 是什么\"></a>那么 Class 是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>\n<h3 id=\"那么-objc-class-又是什么\"><a href=\"#那么-objc-class-又是什么\" class=\"headerlink\" title=\"那么 objc_class 又是什么\"></a>那么 objc_class 又是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;  </span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class super_class;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> version;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> info;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类的继承体系\"><a href=\"#类的继承体系\" class=\"headerlink\" title=\"类的继承体系\"></a>类的继承体系</h3><p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/isa.png\" alt=\"\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"Hello\"</span>;</span><br></pre></td></tr></table></figure>\n<p>str 是一个对象，is a NSString</p>\n<p>NSString 是类，is a NSString metaclass</p>\n<p>NSString metaclass 是元类，类方法就定义在这里</p>\n<h1 id=\"第3章-接口与API设计\"><a href=\"#第3章-接口与API设计\" class=\"headerlink\" title=\"第3章 接口与API设计\"></a>第3章 接口与API设计</h1><h2 id=\"done-第15条：用前缀避免命名空间冲突\"><a href=\"#done-第15条：用前缀避免命名空间冲突\" class=\"headerlink\" title=\"done 第15条：用前缀避免命名空间冲突\"></a>done 第15条：用前缀避免命名空间冲突</h2><h2 id=\"done-第16条：提供“全能初始化方法”\"><a href=\"#done-第16条：提供“全能初始化方法”\" class=\"headerlink\" title=\"done 第16条：提供“全能初始化方法”\"></a>done 第16条：提供“全能初始化方法”</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/4870303.html\" target=\"_blank\" rel=\"noopener\">Designated Initializer</a></p>\n<h2 id=\"done-第17条：实现description方法\"><a href=\"#done-第17条：实现description方法\" class=\"headerlink\" title=\"done 第17条：实现description方法\"></a>done 第17条：实现description方法</h2><h2 id=\"done-第18条：尽量使用不可变对象\"><a href=\"#done-第18条：尽量使用不可变对象\" class=\"headerlink\" title=\"done 第18条：尽量使用不可变对象\"></a>done 第18条：尽量使用不可变对象</h2><ul>\n<li>如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite</li>\n<li>不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法</li>\n</ul>\n<h2 id=\"done-第19条：使用清晰而协调的命名方式\"><a href=\"#done-第19条：使用清晰而协调的命名方式\" class=\"headerlink\" title=\"done 第19条：使用清晰而协调的命名方式:\"></a>done 第19条：使用清晰而协调的命名方式:</h2><h3 id=\"如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了\"><a href=\"#如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了\" class=\"headerlink\" title=\"如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了\"></a>如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了</h3><h3 id=\"对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX\"><a href=\"#对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX\" class=\"headerlink\" title=\"对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX\"></a>对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX</h3><pre><code>@property (nonatomic, assign, getter = isOn) on;\n</code></pre><h2 id=\"done-第20条：为私有方法名加前缀\"><a href=\"#done-第20条：为私有方法名加前缀\" class=\"headerlink\" title=\"done 第20条：为私有方法名加前缀\"></a>done 第20条：为私有方法名加前缀</h2><h2 id=\"done-第21条：理解Objective—C错误模型\"><a href=\"#done-第21条：理解Objective—C错误模型\" class=\"headerlink\" title=\"done 第21条：理解Objective—C错误模型\"></a>done 第21条：理解Objective—C错误模型</h2><h2 id=\"done-第22条：理解NSCopying协议\"><a href=\"#done-第22条：理解NSCopying协议\" class=\"headerlink\" title=\"done 第22条：理解NSCopying协议\"></a>done 第22条：理解NSCopying协议</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/5167194.html\" target=\"_blank\" rel=\"noopener\">浅析Objective-C的copy</a></p>\n<h1 id=\"第4章-协议与分类\"><a href=\"#第4章-协议与分类\" class=\"headerlink\" title=\"第4章 协议与分类\"></a>第4章 协议与分类</h1><h2 id=\"第23条：通过委托与数据源协议进行对象间通信\"><a href=\"#第23条：通过委托与数据源协议进行对象间通信\" class=\"headerlink\" title=\"第23条：通过委托与数据源协议进行对象间通信\"></a>第23条：通过委托与数据源协议进行对象间通信</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>([_delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didReceiveData:)])</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [_delegate networkFetcher:<span class=\"keyword\">self</span> didReceiveData:data];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果上面的代码写了很多次，则可以考虑以下优化：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在扩展中定义结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span>(</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> didReceiveData : <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> didFailWithError : <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125; _delegateFlags; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> </span></span><br><span class=\"line\">EOCNetworkFetcher </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setDelegate:(<span class=\"keyword\">id</span>)delegate</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    _delegate = delegate; <span class=\"comment\">// 缓存委托对象相应方法能力 </span></span><br><span class=\"line\">    _delegateFlags.didReceiveData = [delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didReceiveData:)]; </span><br><span class=\"line\">    _delegateFlags.didFailWithError = [delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didFailWithError:)]; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\">这样每次调用delegate相关方法之前就只需要直接查询标志：</span><br><span class=\"line\"><span class=\"keyword\">if</span>(_delegateFlags.didReceiveData)</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [_delegate networkFetcher:<span class=\"keyword\">self</span> didReceiveData:data]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"done-第24条：将类的实现代码分散到便于管理的数个分类之中\"><a href=\"#done-第24条：将类的实现代码分散到便于管理的数个分类之中\" class=\"headerlink\" title=\"done 第24条：将类的实现代码分散到便于管理的数个分类之中\"></a>done 第24条：将类的实现代码分散到便于管理的数个分类之中</h2><h2 id=\"第25条：总是为第三方类的分类名称加前缀\"><a href=\"#第25条：总是为第三方类的分类名称加前缀\" class=\"headerlink\" title=\"第25条：总是为第三方类的分类名称加前缀\"></a>第25条：总是为第三方类的分类名称加前缀</h2><ol>\n<li>为第三方类添加分类时，总应给其名称加上你专用的前缀</li>\n<li>为第三方类添加分类时，总应给方法名加上你专用的前缀</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">ABC_HTTP</span>)</span></span><br><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)abc_urlEncodedString;</span><br><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)abc_urlDecodedString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"第26条：勿在分类中声明属性\"><a href=\"#第26条：勿在分类中声明属性\" class=\"headerlink\" title=\"第26条：勿在分类中声明属性\"></a>第26条：勿在分类中声明属性</h2><p>属性应该在主类中声明</p>\n<p>如果分类中声明属性需要自己重写 setter 和 getter</p>\n<p>方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *kFriendsPropertyKey = <span class=\"string\">\"kFriendsPropertyKey\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span>(<span class=\"title\">Friendship</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> friends;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"built_in\">NSArray</span>*)friends </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setFriends:(<span class=\"built_in\">NSArray</span>*)friends </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　objc_setAssociaedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>缺点如下</p>\n<ol>\n<li>相似的代码要写很多遍</li>\n<li>极易忽略属性定义的内存管理语义，且不好维护</li>\n</ol>\n<h2 id=\"第27条：使用“class—continuation分类”隐藏实现细节\"><a href=\"#第27条：使用“class—continuation分类”隐藏实现细节\" class=\"headerlink\" title=\"第27条：使用“class—continuation分类”隐藏实现细节\"></a>第27条：使用“class—continuation分类”隐藏实现细节</h2><p>声明私有实例变量的3种方法</p>\n<ul>\n<li><p>方法1：对外暴露，声明为 private（暴露了细节，不建议）</p>\n<p>  .h</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>:<span class=\"title\">NSObject</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">@private</span></span><br><span class=\"line\">    XYZ *_xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>把私有变量放在头文件，暴露了细节，不好</li>\n<li>假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题</li>\n<li>所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>方法2：不对外暴露</p>\n<p>  .m</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *_xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) XYZ *xyz2;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法3：对外只读，对内读写</p>\n<p>  .h</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) XYZ *xyz;</span><br></pre></td></tr></table></figure>\n<p>  .m</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readwrite</span>) XYZ *xyz;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"done-第28条：通过协议提供匿名对象\"><a href=\"#done-第28条：通过协议提供匿名对象\" class=\"headerlink\" title=\"done 第28条：通过协议提供匿名对象\"></a>done 第28条：通过协议提供匿名对象</h2><h1 id=\"第5章-内存管理\"><a href=\"#第5章-内存管理\" class=\"headerlink\" title=\"第5章 内存管理\"></a>第5章 内存管理</h1><h2 id=\"第29条：理解引用计数\"><a href=\"#第29条：理解引用计数\" class=\"headerlink\" title=\"第29条：理解引用计数\"></a>第29条：理解引用计数</h2><h3 id=\"悬浮指针\"><a href=\"#悬浮指针\" class=\"headerlink\" title=\"悬浮指针\"></a>悬浮指针</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number = [[<span class=\"built_in\">NSNumber</span> alloc] initWithInt:<span class=\"number\">1</span>];</span><br><span class=\"line\">[array addObject:number];</span><br><span class=\"line\">[number release];</span><br><span class=\"line\">number = <span class=\"literal\">nil</span>;   <span class=\"comment\">//如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"autorelease\"><a href=\"#autorelease\" class=\"headerlink\" title=\"autorelease\"></a>autorelease</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringValue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"Hello\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放</p>\n<p>但是，这是十分不合理的，因为从方法名上看（不含<code>alloc/new/copy/mutableCopy</code>），调用者并不知道它需要负责释放该对象</p>\n<p>所以此时，autorelease 就应运而生了</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringValue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"Hello\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [str autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>str 对象会在其所在的释放池释放的时候被释放</p>\n<p>如果外部需要 retain 该返回值，则需要这样做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = [[<span class=\"keyword\">self</span> stringValue] <span class=\"keyword\">retain</span>];</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">[str release];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间</p>\n</blockquote>\n<h2 id=\"第30条：以ARC简化引用计数\"><a href=\"#第30条：以ARC简化引用计数\" class=\"headerlink\" title=\"第30条：以ARC简化引用计数\"></a>第30条：以ARC简化引用计数</h2><h3 id=\"ARC-的本质是自动添加-release-retian-autorelease-等\"><a href=\"#ARC-的本质是自动添加-release-retian-autorelease-等\" class=\"headerlink\" title=\"ARC 的本质是自动添加 release/retian/autorelease 等\"></a>ARC 的本质是自动添加 release/retian/autorelease 等</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (XYZ *)newXYZ</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (XYZ *)createXYZ</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">/*ARC自动添加</span></span><br><span class=\"line\"><span class=\"comment\">    xyz = [xyz autorelease];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)f</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz1 = [XYZ newXYZ];</span><br><span class=\"line\">    XYZ *xyz2 = [XYZ createXYZ];</span><br><span class=\"line\">    <span class=\"comment\">/*ARC自动添加</span></span><br><span class=\"line\"><span class=\"comment\">    [xyz1 release];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展阅读：iOS开发ARC内存管理技术要点\"><a href=\"#扩展阅读：iOS开发ARC内存管理技术要点\" class=\"headerlink\" title=\"扩展阅读：iOS开发ARC内存管理技术要点\"></a>扩展阅读：<a href=\"http://www.cnblogs.com/flyFreeZn/p/4264220.html\" target=\"_blank\" rel=\"noopener\">iOS开发ARC内存管理技术要点</a></h3><h2 id=\"done-第31条：在dealloc方法中只释放引用并解除监听\"><a href=\"#done-第31条：在dealloc方法中只释放引用并解除监听\" class=\"headerlink\" title=\"done 第31条：在dealloc方法中只释放引用并解除监听\"></a>done 第31条：在dealloc方法中只释放引用并解除监听</h2><h2 id=\"done-第32条：编写“异常安全代码”时留意内存管理问题\"><a href=\"#done-第32条：编写“异常安全代码”时留意内存管理问题\" class=\"headerlink\" title=\"done 第32条：编写“异常安全代码”时留意内存管理问题\"></a>done 第32条：编写“异常安全代码”时留意内存管理问题</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];</span><br><span class=\"line\"> [object release];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏</p>\n<p>解决方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EOCSomeClass *object;</span><br><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@finally</span> &#123;</span><br><span class=\"line\"> [object release];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理，ARC 下也会发生这个问题</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题</p>\n<p>总结：</p>\n<ol>\n<li>当捕获到异常,应该注意确保@try中创建的对象被清理完成.</li>\n<li>ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.</li>\n</ol>\n<h2 id=\"done-第33条：以弱引用避免保留环\"><a href=\"#done-第33条：以弱引用避免保留环\" class=\"headerlink\" title=\"done 第33条：以弱引用避免保留环\"></a>done 第33条：以弱引用避免保留环</h2><h2 id=\"done-第34条：以“自动释放池块”降低内存峰值\"><a href=\"#done-第34条：以“自动释放池块”降低内存峰值\" class=\"headerlink\" title=\"done 第34条：以“自动释放池块”降低内存峰值\"></a>done 第34条：以“自动释放池块”降低内存峰值</h2><p>ARC下，可以使用 @autoreleasepool 来降低内存峰值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9999</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span>&#123;</span><br><span class=\"line\">        A *a = [[A alloc] init];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> handle:a];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>a 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值</p>\n<p>使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用</p>\n<p>另外，关于降低内存峰值的之前也有学习过，见<a href=\"http://www.cnblogs.com/chenyg32/p/3859110.html\" target=\"_blank\" rel=\"noopener\">Objective-C 内存管理</a></p>\n<h2 id=\"done-第35条：用“僵尸对象”调试内存管理问题\"><a href=\"#done-第35条：用“僵尸对象”调试内存管理问题\" class=\"headerlink\" title=\"done 第35条：用“僵尸对象”调试内存管理问题\"></a>done 第35条：用“僵尸对象”调试内存管理问题</h2><p>僵尸对象是调试内存管理问题的最佳方式</p>\n<p>被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。</p>\n<p>打开僵尸对象的方法：</p>\n<p>Xcode -&gt; Run -&gt; Diagnostics -&gt; Enable Zombie Objects<br><img src=\"http://img.blog.csdn.net/20150803102818758\" alt=\"\"></p>\n<p>僵尸对象的原理：</p>\n<p>替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存</p>\n<p>原理代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Obtain the class of the object being deallocated</span></span><br><span class=\"line\">Class cls = object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the class's name</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *clsName = class_getName(cls);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prepend _NSZombie_ to the class name</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *zombieClsName = <span class=\"string\">@\"_NSZombie_\"</span> + clsName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// See if the specific zombie class exists</span></span><br><span class=\"line\">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If the specific zombie class doesn't exists,</span></span><br><span class=\"line\"><span class=\"comment\">// then it needs to be created</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!zombieCls)&#123;</span><br><span class=\"line\"><span class=\"comment\">// Obtain the template  zombie class, where the new class's </span></span><br><span class=\"line\"><span class=\"comment\">// name is the prepended string from above</span></span><br><span class=\"line\">   zombieCls = objc_duplicateClass(baseZombieCls,   </span><br><span class=\"line\">   zombieClsName,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Perform normal destruction of the object being deallocated</span></span><br><span class=\"line\">objc_destructInstance(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set the class of the object being deallocated</span></span><br><span class=\"line\"><span class=\"comment\">// to the zombie class</span></span><br><span class=\"line\">objc_setClass(<span class=\"keyword\">self</span>, zombieCls) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The class of \"self\" is now _NSZombie_OriginalClass</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"done-第36条：不要使用retainCount\"><a href=\"#done-第36条：不要使用retainCount\" class=\"headerlink\" title=\"done 第36条：不要使用retainCount\"></a>done 第36条：不要使用retainCount</h2><h1 id=\"第6章-块与大中枢派发\"><a href=\"#第6章-块与大中枢派发\" class=\"headerlink\" title=\"第6章 块与大中枢派发\"></a>第6章 块与大中枢派发</h1><h2 id=\"done-第37条：理解“块”这一概念\"><a href=\"#done-第37条：理解“块”这一概念\" class=\"headerlink\" title=\"done 第37条：理解“块”这一概念\"></a>done 第37条：理解“块”这一概念</h2><pre><code>在Objective-C语言中，一共有3种类型的block：\n_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。\n_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。\n_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。\n</code></pre><ul>\n<li><p>全局 Block：_NSConcreteGlobalBlock</p>\n<ul>\n<li>定义在函数外面的 block 是全局静态的，没有访问任何外部变量</li>\n<li><p>定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的</p>\n<p>问题：那么定义在函数外部的，捕获变量的，是 global 吗？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ^&#123; printf(<span class=\"string\">\"Hello, World!\\n\"</span>); &#125; ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>栈 Block：_NSConcreteStackBlock</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    ^&#123; printf(<span class=\"string\">\"%c\\n\"</span>,a); &#125; ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>堆 Block：_NSConcreteMallocBlock</p>\n<p>  NSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = [^&#123; printf(<span class=\"string\">\"%c\\n\"</span>,a); &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>对全局 Block 进行 copy 后，什么事也不会发生\n对栈 Block 进行 copy 后，会得到一个堆 Block\n对堆 Block 进行 copy 后，其引用计数会加1\n</code></pre></li>\n<li><p>例子</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^blcok)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    block = ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n<p>  block执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放</p>\n<p>  正确做法是</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^blcok)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    block = [^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更多细节见<a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/\" target=\"_blank\" rel=\"noopener\">《谈Objective-C block的实现》</a></p>\n</li>\n</ul>\n<h2 id=\"done-第38条：为常用的块类型创建typedef\"><a href=\"#done-第38条：为常用的块类型创建typedef\" class=\"headerlink\" title=\"done 第38条：为常用的块类型创建typedef\"></a>done 第38条：为常用的块类型创建typedef</h2><h2 id=\"done-第39条：用handler块降低代码分散程度\"><a href=\"#done-第39条：用handler块降低代码分散程度\" class=\"headerlink\" title=\"done 第39条：用handler块降低代码分散程度\"></a>done 第39条：用handler块降低代码分散程度</h2><h2 id=\"第40条：用块引用其所属对象时不要出现保留环\"><a href=\"#第40条：用块引用其所属对象时不要出现保留环\" class=\"headerlink\" title=\"第40条：用块引用其所属对象时不要出现保留环\"></a>第40条：用块引用其所属对象时不要出现保留环</h2><p>例子1</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOCNetworkFetcher.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class=\"built_in\">NSData</span> *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSURL</span> *url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithURL:(<span class=\"built_in\">NSURL</span>*)url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOCNetworkFetcher.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCNetworkFetcher.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readwrite</span>) <span class=\"built_in\">NSURL</span> *url;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) EOCNetworkFetcherCompletionHandler completionHandler;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSData</span> *downloadedData;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCNetworkFetcher</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithURL:(<span class=\"built_in\">NSURL</span>*)url</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])) &#123;</span><br><span class=\"line\">\t\t\t\t_url = url;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">self</span>.completionHandler = completion;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Start the request</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Request sets downloadedData property</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// When request is finished, p_requestCompleted is called</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)p_requestCompleted &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_completionHandler) &#123;</span><br><span class=\"line\">\t\t\t\t_completionHandler(_downloadedData);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCClass</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EOCNetworkFetcher* _networkFetcher;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span>* _fetchedData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span>* url = [[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"http://www.example.com/something.dat\"</span>];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t[_networkFetcher startWithCompletionHandler:^(<span class=\"built_in\">NSData</span> *data)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Request URL %@ finished\"</span>, _networkFetcher.url);</span><br><span class=\"line\">\t\t\t\t_fetchedData = data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>EoCClass -&gt; networkFetcher -&gt; block -&gt; self(通过_fetchedData)</p>\n<p>例子2</p>\n<p>将 networkFetcher 变为局部变量，修改如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadData &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSURL</span> *url = [[<span class=\"built_in\">NSURL</span> alloc] initWithString:</span><br><span class=\"line\"> <span class=\"string\">@\"http://www.example.com/something.dat\"</span>];</span><br><span class=\"line\"> EOCNetworkFetcher *networkFetcher =</span><br><span class=\"line\"> [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class=\"line\"> [networkFetcher startWithCompletionHandler:^(<span class=\"built_in\">NSData</span> *data)&#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Request URL %@ finished\"</span>, networkFetcher.url);</span><br><span class=\"line\"> _fetchedData = data;</span><br><span class=\"line\"> &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>networkFetcher -&gt; block -&gt; networkFetcher(通过url)</p>\n<h2 id=\"第41条：多用派发队列，少用同步锁\"><a href=\"#第41条：多用派发队列，少用同步锁\" class=\"headerlink\" title=\"第41条：多用派发队列，少用同步锁\"></a>第41条：多用派发队列，少用同步锁</h2><h2 id=\"第42条：多用GCD，少用performSelector系列方法\"><a href=\"#第42条：多用GCD，少用performSelector系列方法\" class=\"headerlink\" title=\"第42条：多用GCD，少用performSelector系列方法\"></a>第42条：多用GCD，少用performSelector系列方法</h2><h3 id=\"如何延迟执行一个方法\"><a href=\"#如何延迟执行一个方法\" class=\"headerlink\" title=\"如何延迟执行一个方法\"></a>如何延迟执行一个方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1：使用 performSelector</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(foo) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">5.0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2：使用 dispatch_after</span></span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">5.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> foo];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>\n<p>当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消</p>\n<h3 id=\"如何让一个方法在主线程执行\"><a href=\"#如何让一个方法在主线程执行\" class=\"headerlink\" title=\"如何让一个方法在主线程执行\"></a>如何让一个方法在主线程执行</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1：使用 performSelector</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(foo) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2：使用 dispatch_after</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> foo];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>\n<h2 id=\"第43条：掌握GCD及操作队列的使用时机\"><a href=\"#第43条：掌握GCD及操作队列的使用时机\" class=\"headerlink\" title=\"第43条：掌握GCD及操作队列的使用时机\"></a>第43条：掌握GCD及操作队列的使用时机</h2><p>要知道有个东西叫做 NSOperationQueue 就行了</p>\n<h2 id=\"第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务\"><a href=\"#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务\" class=\"headerlink\" title=\"第44条：通过Dispatch Group机制，根据系统资源状况来执行任务\"></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务</h2><h2 id=\"第45条：使用dispatch-once来执行只需运行一次的线程安全代码\"><a href=\"#第45条：使用dispatch-once来执行只需运行一次的线程安全代码\" class=\"headerlink\" title=\"第45条：使用dispatch_once来执行只需运行一次的线程安全代码\"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h2><p>以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once</p>\n<p>比如单例的书写方式<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"第46条：不要使用dispatch-get-current-queue\"><a href=\"#第46条：不要使用dispatch-get-current-queue\" class=\"headerlink\" title=\"第46条：不要使用dispatch_get_current_queue\"></a>第46条：不要使用<code>dispatch_get_current_queue</code></h2><p>尽量别用，该接口已废弃</p>\n<h1 id=\"第7章-系统框架\"><a href=\"#第7章-系统框架\" class=\"headerlink\" title=\"第7章 系统框架\"></a>第7章 系统框架</h1><h2 id=\"第47条：熟悉系统框架\"><a href=\"#第47条：熟悉系统框架\" class=\"headerlink\" title=\"第47条：熟悉系统框架\"></a>第47条：熟悉系统框架</h2><ul>\n<li>CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）</li>\n<li>CoreAudio:音频处理 API（C语言）</li>\n<li>AVFoundation:视频处理接口（Objective-C）</li>\n<li>CoreData:数据库接口（Objective-C）</li>\n<li>CoreText:文字渲染排版接口（C语言）</li>\n</ul>\n<h2 id=\"done-第48条：多用块枚举，少用for循环\"><a href=\"#done-第48条：多用块枚举，少用for循环\" class=\"headerlink\" title=\"done 第48条：多用块枚举，少用for循环\"></a>done 第48条：多用块枚举，少用for循环</h2><h2 id=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"><a href=\"#第49条：对自定义其内存管理语义的collection使用无缝桥接\" class=\"headerlink\" title=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h2><h3 id=\"使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构\"><a href=\"#使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构\" class=\"headerlink\" title=\"使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构\"></a>使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ count: %li\"</span>, cfArray, <span class=\"built_in\">CFArrayGetCount</span>(cfArray));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray</li>\n<li>CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数</li>\n</ul>\n<h3 id=\"桥式转换\"><a href=\"#桥式转换\" class=\"headerlink\" title=\"桥式转换\"></a>桥式转换</h3><ul>\n<li><code>__bridge</code>：只做类型转换，不修改对象（内存）管理权；</li>\n<li><code>__bridge_retained</code>：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；</li>\n<li><code>__bridge_transfer</code>：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge_retained <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(cfArray);  <span class=\"comment\">// 因为是 __bridge_retained，所以需要调用 CFRelease</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge_retained <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array2 = (__bridge_transfer <span class=\"built_in\">NSArray</span> *)cfArray;</span><br><span class=\"line\"><span class=\"comment\">//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用无缝桥接修改-Collection-的内存管理语义\"><a href=\"#使用无缝桥接修改-Collection-的内存管理语义\" class=\"headerlink\" title=\"使用无缝桥接修改 Collection 的内存管理语义\"></a>使用无缝桥接修改 Collection 的内存管理语义</h3><p>NSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error</p>\n<p>关于拷贝协议可以查看：<a href=\"http://www.cnblogs.com/chenyg32/p/5167194.html\" target=\"_blank\" rel=\"noopener\">浅析Objective-C的copy</a></p>\n<p>无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典</p>\n<p>创建函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> <span class=\"built_in\">CFDictionaryCreateMutable</span>(</span><br><span class=\"line\">    <span class=\"built_in\">CFAllocatorRef</span> allocator,  <span class=\"comment\">// 一般传NULL，采用系统默认的内存分配器</span></span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span> capacity,          <span class=\"comment\">// 初始大小，并非最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFDictionaryKeyCallBacks</span> *keyCallBacks,    <span class=\"comment\">// 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFDictionaryValueCallBacks</span> *valueCallBacks <span class=\"comment\">// 回调</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>键值回调</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span>\t\t\t\tversion;    <span class=\"comment\">//一般为0</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRetainCallBack</span>\t\t<span class=\"keyword\">retain</span>; <span class=\"comment\">//遇到retain的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryReleaseCallBack</span>\t\trelease;<span class=\"comment\">//遇到release的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryCopyDescriptionCallBack</span>\tcopyDescription;<span class=\"comment\">//一般传NULL，采用系统默认</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryEqualCallBack</span>\t\tequal;  <span class=\"comment\">//一般传CFEqual</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryHashCallBack</span>\t\thash;   <span class=\"comment\">//一般传CFHash</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">CFDictionaryKeyCallBacks</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span>\t\t\t\tversion;    <span class=\"comment\">//一般为0</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRetainCallBack</span>\t\t<span class=\"keyword\">retain</span>; <span class=\"comment\">//遇到retain的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryReleaseCallBack</span>\t\trelease;<span class=\"comment\">//遇到release的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryCopyDescriptionCallBack</span>\tcopyDescription;    <span class=\"comment\">//一般传NULL，采用系统默认</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryEqualCallBack</span>\t\tequal;  <span class=\"comment\">//一般传CFEqual</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">CFDictionaryValueCallBacks</span>;</span><br></pre></td></tr></table></figure>\n<p>创建“保留”键，“保留”值的 NSDictionary</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* EOCRetainCallback (<span class=\"built_in\">CFAllocatorRef</span> allocator , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CFRetain</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> EOCReleaseCallback(<span class=\"built_in\">CFAllocatorRef</span> allocator , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryKeyCallBacks</span> keyCallbacks = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCRetainCallback,</span><br><span class=\"line\">    EOCReleaseCallback,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFEqual</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFHash</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryValueCallBacks</span> valueCallbacks = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCRetainCallback,</span><br><span class=\"line\">    EOCReleaseCallback,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFEqual</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> aCFDictionary = <span class=\"built_in\">CFDictionaryCreateMutable</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, &amp;keyCallbacks, &amp;valueCallbacks);</span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *anNSdictionary = (__bridge_transfer <span class=\"built_in\">NSMutableDictionary</span> *)aCFDictionary;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第50条：构建缓存时选用NSCache而非NSDictionary\"><a href=\"#第50条：构建缓存时选用NSCache而非NSDictionary\" class=\"headerlink\" title=\"第50条：构建缓存时选用NSCache而非NSDictionary\"></a>第50条：构建缓存时选用NSCache而非NSDictionary</h2><ul>\n<li>实现缓存时应选用 NSCache 而非 NSDictionary</li>\n<li>可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据</li>\n<li>NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）</li>\n<li>NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）</li>\n<li>使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除</li>\n</ul>\n<p>扩展阅读：<a href=\"https://www.ganlvji.com/nscache/\" target=\"_blank\" rel=\"noopener\">利用NSCache提升效率</a></p>\n<h2 id=\"第51条：精简initialize与load的实现代码\"><a href=\"#第51条：精简initialize与load的实现代码\" class=\"headerlink\" title=\"第51条：精简initialize与load的实现代码\"></a>第51条：精简initialize与load的实现代码</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">load</th>\n<th style=\"text-align:center\">initialize</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">执行次数</td>\n<td style=\"text-align:center\">1次</td>\n<td style=\"text-align:center\">1次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">执行时机</td>\n<td style=\"text-align:center\">app启动时所有运行时需要用到的类</td>\n<td style=\"text-align:center\">惰性调用，需要使用到具体类的时候才调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">作用</td>\n<td style=\"text-align:center\">调试 现基本不用</td>\n<td style=\"text-align:center\">初始化全局oc对象（普通对象可以在声明的时候初始化）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">执行时环境</td>\n<td style=\"text-align:center\">系统不稳定，许多东西尚未初始化</td>\n<td style=\"text-align:center\">系统处于正常状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">调用顺序</td>\n<td style=\"text-align:center\">1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类</td>\n<td style=\"text-align:center\">跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">相同点</td>\n<td style=\"text-align:center\">1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁</td>\n<td style=\"text-align:center\">同左</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\"><a href=\"#initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\" class=\"headerlink\" title=\"initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\"></a>initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）</h3><p>假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">A</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">A</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">B</span> : <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>此时创建一个B对象，输出是</p>\n<blockquote>\n<p>A<br>B</p>\n</blockquote>\n<p>初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B</p>\n<p>所以 A 的 initialize 方法应该这样写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [A <span class=\"keyword\">class</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时创建一个B对象，输出是</p>\n<blockquote>\n<p>B</p>\n</blockquote>\n<h2 id=\"第52条：别忘了NSTimer会保留其目标对象\"><a href=\"#第52条：别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"第52条：别忘了NSTimer会保留其目标对象\"></a>第52条：别忘了NSTimer会保留其目标对象</h2><p>参见：<a href=\"http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">NSTimer 会保留目标对象</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第1章-熟悉Objective—C\"><a href=\"#第1章-熟悉Objective—C\" class=\"headerlink\" title=\"第1章 熟悉Objective—C\"></a>第1章 熟悉Objective—C</h1><h2 id=\"第1条：了解Objective—C语言的起源\"><a href=\"#第1条：了解Objective—C语言的起源\" class=\"headerlink\" title=\"第1条：了解Objective—C语言的起源\"></a>第1条：了解Objective—C语言的起源</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *s1 = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *s2 = s1;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>s1 和s2 的内存分配在栈上</li>\n<li>@”Hello”的内存分配在堆上</li>\n<li>s1 和 s2 指向同一块内存</li>\n</ul>\n<h2 id=\"第2条：在类的头文件中尽量少引入其他头文件\"><a href=\"#第2条：在类的头文件中尽量少引入其他头文件\" class=\"headerlink\" title=\"第2条：在类的头文件中尽量少引入其他头文件\"></a>第2条：在类的头文件中尽量少引入其他头文件</h2><h2 id=\"第3条：多用字面量语法，少用与之等价的方法\"><a href=\"#第3条：多用字面量语法，少用与之等价的方法\" class=\"headerlink\" title=\"第3条：多用字面量语法，少用与之等价的方法\"></a>第3条：多用字面量语法，少用与之等价的方法</h2><h3 id=\"使用字面量语法，它是一种语法糖：\"><a href=\"#使用字面量语法，它是一种语法糖：\" class=\"headerlink\" title=\"使用字面量语法，它是一种语法糖：\"></a>使用字面量语法，它是一种语法糖：</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *intNum = @<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *doubleNum = @<span class=\"number\">2.5</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *charNum = @<span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *boolNum = @YES;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"hello\"</span>, @<span class=\"number\">1</span>, @<span class=\"number\">2.5</span>, @<span class=\"string\">'a'</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *str2 = array[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dic = @&#123;<span class=\"string\">@\"1\"</span>:@<span class=\"number\">1</span>, <span class=\"string\">@\"2\"</span>:@<span class=\"number\">2</span>&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"这个语法糖更容易暴露隐藏的问题\"><a href=\"#这个语法糖更容易暴露隐藏的问题\" class=\"headerlink\" title=\"这个语法糖更容易暴露隐藏的问题\"></a>这个语法糖更容易暴露隐藏的问题</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array1 = [<span class=\"built_in\">NSArray</span> arrayWithObjects: obj1, obj2, obj3, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array2 = @[obj1, obj2, obj3];</span><br></pre></td></tr></table></figure>\n<p>如果 obj1 和 obj3 非空，而 obj2 是 nil</p>\n<p>那么 array1 只有一个对象，不会出错；而 array2 在插入的时候会抛出异常</p>\n<h3 id=\"使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\"><a href=\"#使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\" class=\"headerlink\" title=\"使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：\"></a>使用字面量语法创建的对象是不可变的，若想要创建一个可变的对象，需要复制一份：</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMuatableArray</span> *mArray = [@[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>] mutableCopy];</span><br></pre></td></tr></table></figure>\n<h2 id=\"第4条：多用类型常量，少用-define预处理指令\"><a href=\"#第4条：多用类型常量，少用-define预处理指令\" class=\"headerlink\" title=\"第4条：多用类型常量，少用#define预处理指令\"></a>第4条：多用类型常量，少用#define预处理指令</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/5080301.html\" target=\"_blank\" rel=\"noopener\">NSNotification Name 最佳写法</a></p>\n<h2 id=\"第5条：用枚举表示状态、选项、状态码\"><a href=\"#第5条：用枚举表示状态、选项、状态码\" class=\"headerlink\" title=\"第5条：用枚举表示状态、选项、状态码\"></a>第5条：用枚举表示状态、选项、状态码</h2><h3 id=\"使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，\"><a href=\"#使用-NS-ENUM-和-NS-OPTIONS-来表示状态机，\" class=\"headerlink\" title=\"使用 NS_ENUM 和 NS_OPTIONS 来表示状态机，\"></a>使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 来表示<code>状态机</code>，</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NS_ENUM，定义状态等普通枚举</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, TTGState) &#123;</span><br><span class=\"line\">    TTGStateOK = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGStateError,</span><br><span class=\"line\">    TTGStateUnknow</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NS_OPTIONS，定义选项</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, TTGDirection) &#123;</span><br><span class=\"line\">    TTGDirectionNone = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGDirectionTop = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGDirectionLeft = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">    TTGDirectionRight = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">    TTGDirectionBottom = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示\"><a href=\"#如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用-NS-OPTIONS，而且各个选项的值应定义为2的-N-次幂，如上代码，这样就可以用或操作将其组合起来进行表示\" class=\"headerlink\" title=\"如果一个枚举变量可以同时表示一个或多个选项的集合，那么应当使用 NS_OPTIONS，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用或操作将其组合起来进行表示\"></a>如果一个<code>枚举变量</code>可以同时表示一个或多个选项的集合，那么应当使用 <code>NS_OPTIONS</code>，而且各个选项的值应定义为2的 N 次幂，如上代码，这样就可以用<code>或操作</code>将其组合起来进行表示</h3><h3 id=\"相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\"><a href=\"#相比较-C-语言中的枚举，使用-NS-ENUM-和-NS-OPTIONS-的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\" class=\"headerlink\" title=\"相比较 C 语言中的枚举，使用 NS_ENUM 和 NS_OPTIONS 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型\"></a>相比较 C 语言中的枚举，使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 的好处是，可以确保实现枚举值的数据类型是开发者所指定的，而不会默认采用编译器所选的类型</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> _TTGState &#123;</span><br><span class=\"line\">    TTGStateOK  = <span class=\"number\">0</span>,</span><br><span class=\"line\">    TTGStateError,</span><br><span class=\"line\">    TTGStateUnknow</span><br><span class=\"line\">&#125; TTGState;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举\"><a href=\"#处理枚举类型的-switch-分支中，不要实现-default-分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch-语句并未处理所有枚举\" class=\"headerlink\" title=\"处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举\"></a>处理枚举类型的 switch 分支中，不要实现 default 分支。这样的话，加入新的枚举值之后，编译器就会给出提示：switch 语句并未处理所有枚举</h3><h3 id=\"参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\"><a href=\"#参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\" class=\"headerlink\" title=\"参考链接：Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5\"></a>参考链接：<a href=\"http://tutuge.me/2015/03/21/effective-objective-c-5-enum/\" target=\"_blank\" rel=\"noopener\">Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5</a></h3><h1 id=\"第2章-对象、消息、运行期\"><a href=\"#第2章-对象、消息、运行期\" class=\"headerlink\" title=\"第2章 对象、消息、运行期\"></a>第2章 对象、消息、运行期</h1><h2 id=\"第6条：理解“属性”这一概念\"><a href=\"#第6条：理解“属性”这一概念\" class=\"headerlink\" title=\"第6条：理解“属性”这一概念\"></a>第6条：理解“属性”这一概念</h2><h3 id=\"理解好属性和实例变量的区别\"><a href=\"#理解好属性和实例变量的区别\" class=\"headerlink\" title=\"理解好属性和实例变量的区别\"></a>理解好<code>属性</code>和<code>实例变量</code>的区别</h3><p>属性 = 实例变量 + setter + getter</p>\n<p>如果声明属性</p>\n<pre><code>@property (nonatomic, copy) NSString *str;\n</code></pre><p>则编译器会默认实现</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setStr:(<span class=\"built_in\">NSString</span> *)str;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setStr:(<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_str = [str <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>_str</code> 就是<code>实例变量</code></p>\n<h3 id=\"使用点语法访问属性-调用-setter-getter-方法\"><a href=\"#使用点语法访问属性-调用-setter-getter-方法\" class=\"headerlink\" title=\"使用点语法访问属性 = 调用 setter/getter 方法\"></a>使用<code>点语法</code>访问属性 = 调用 setter/getter 方法</h3><h3 id=\"Property-的4种-attribute\"><a href=\"#Property-的4种-attribute\" class=\"headerlink\" title=\"Property 的4种 attribute\"></a>Property 的4种 attribute</h3><ul>\n<li>原子性(atomic, nonatomic)</li>\n<li>读写权限(readonly, readwrite)</li>\n<li>内存管理(strong, weak, unsafe_unretained, retain, assign, copy)</li>\n<li>存取方法(getter, setter)</li>\n</ul>\n<h3 id=\"非-ARC-下，没有-weak\"><a href=\"#非-ARC-下，没有-weak\" class=\"headerlink\" title=\"非 ARC 下，没有 weak\"></a>非 ARC 下，没有 weak</h3><h3 id=\"ARC下，修饰指针的内存修饰符\"><a href=\"#ARC下，修饰指针的内存修饰符\" class=\"headerlink\" title=\"ARC下，修饰指针的内存修饰符\"></a>ARC下，修饰指针的内存修饰符</h3><ul>\n<li><code>__weak</code>:不retain，如果对象被回收，该指针会被置nil</li>\n<li><code>__strong</code>:默认，如果对象被回收，需要手动将指针置为nil？</li>\n<li><code>__unsafe__unretained</code>:不retain，如果对象被回收，该指针不会被置nil（为了在ARC刚发布时兼容iOS 4以及版本，现可废弃）</li>\n<li><code>__autoreleasing</code>:实现把对象”按引用传递”给方法，变量在方法返回时自动释放</li>\n</ul>\n<p>编译器在为一个 property 合成实例变量的时候，也会使用相应的修饰符来修饰这个实例变量</p>\n<h3 id=\"常见数据类型的内存修饰符（待补充）\"><a href=\"#常见数据类型的内存修饰符（待补充）\" class=\"headerlink\" title=\"常见数据类型的内存修饰符（待补充）\"></a>常见数据类型的内存修饰符（待补充）</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">内存修饰符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">基本数据类型(int, NSInteger)</td>\n<td style=\"text-align:center\">assign</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">block</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSString</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableString</td>\n<td style=\"text-align:center\">strong</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSArray</td>\n<td style=\"text-align:center\">copy</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableArray</td>\n<td style=\"text-align:center\">strong</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"NSArray-用-strong-还是-copy-修饰\"><a href=\"#NSArray-用-strong-还是-copy-修饰\" class=\"headerlink\" title=\"NSArray 用 strong 还是 copy 修饰\"></a>NSArray 用 strong 还是 copy 修饰</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> *strongArray;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>)   <span class=\"built_in\">NSArray</span> *copyedArray;</span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongArray = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyedArray = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableArray = [@[<span class=\"string\">@\"1\"</span>] mutableCopy];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.strongArray = mutableArray;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.copyedArray = mutableArray;</span><br><span class=\"line\">    </span><br><span class=\"line\">[mutableArray addObject:<span class=\"string\">@\"2\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\\n%@\\n%@\"</span>, mutableArray, <span class=\"keyword\">self</span>.strongArray, <span class=\"keyword\">self</span>.copyedArray); <span class=\"comment\">//输出 (1,2) (1,2) (1)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到使用 strong 修饰 NSArray 非常不安全，数组元素被外部修改了。原因是执行其 setter 操作的时候，假如将一个可变数组赋值给 NSArray，那么 NSArray 的指针会直接指向一个可变对象，然后就可以通过这个可变对象来修改 NSArray。而使用 copy 就不会有这个问题。所以 NSArray 建议使用 copy 修饰，而 NSMutableArray 没有这个问题，可以用 strong 修饰。</p>\n<h2 id=\"第7条：在对象内部尽量直接访问实例变量\"><a href=\"#第7条：在对象内部尽量直接访问实例变量\" class=\"headerlink\" title=\"第7条：在对象内部尽量直接访问实例变量\"></a>第7条：在对象内部尽量直接访问实例变量</h2><h3 id=\"类内使用-self-xxx-和-xxx-的区别\"><a href=\"#类内使用-self-xxx-和-xxx-的区别\" class=\"headerlink\" title=\"类内使用 self.xxx 和 _xxx 的区别\"></a>类内使用 self.xxx 和 _xxx 的区别</h3><ul>\n<li>访问 _xxx 不经过 setter/getter 方法，速度更快</li>\n<li>访问 _xxx 不经过 setter 方法，绕过了 property 定义的内存管理逻辑。比如 ARC 下直接访问一个声明为 copy 的属性的实例变量，那赋值过程中，并没有 copy 操作</li>\n<li>访问 _xxx 不经过 setter/getter 方法，无法触发 KVO</li>\n<li>访问 _xxx 不经过 setter/getter 方法，无法断点</li>\n</ul>\n<h3 id=\"什么时候使用-xxx\"><a href=\"#什么时候使用-xxx\" class=\"headerlink\" title=\"什么时候使用 _xxx\"></a>什么时候使用 _xxx</h3><ul>\n<li>折中方案，读的时候使用 _xxx，写的时候使用 self.xxx</li>\n<li>父类的 init 和 dealloc 尽量使用 _xxx 来访问，因为如果子类覆盖了 setter 方法并做了某些非空检查，那么父类初始化的时候会调用子类的 setter 方法，由于是在 init/dealloc，参数可能都是空的，此时报错</li>\n<li>如果实例变量在父类中声明，那么子类只能使用 self.xxx 来访问属性</li>\n<li>使用 lazy initialization 的情况下，必须通过 self.xxx 来访问属性，否则初始化失败<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!_str)</span><br><span class=\"line\">\t\t_str = [[<span class=\"built_in\">NSString</span> alloc] init];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"第8条：理解“对象等同性”这一概念\"><a href=\"#第8条：理解“对象等同性”这一概念\" class=\"headerlink\" title=\"第8条：理解“对象等同性”这一概念\"></a>第8条：理解“对象等同性”这一概念</h2><h2 id=\"第9条：以“类族模式”隐藏实现细节\"><a href=\"#第9条：以“类族模式”隐藏实现细节\" class=\"headerlink\" title=\"第9条：以“类族模式”隐藏实现细节\"></a>第9条：以“类族模式”隐藏实现细节</h2><h2 id=\"第10条：在既有类中使用关联对象存放自定义数据\"><a href=\"#第10条：在既有类中使用关联对象存放自定义数据\" class=\"headerlink\" title=\"第10条：在既有类中使用关联对象存放自定义数据\"></a>第10条：在既有类中使用关联对象存放自定义数据</h2><p>“关联对象”（Associated Object）是用来为对象关联其他对象的，比如不定义子类的前提下为 UIAlertView 添加一个 Block 属性；比如为一些无法更改其属性（比如工作中的协议文件）的类添加属性</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> objc_setAssociatedObject (<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> objc_getAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> objc_removeAssociatedObject(<span class=\"keyword\">id</span> object);    <span class=\"comment\">// 移除object上的所有关联对象</span></span><br></pre></td></tr></table></figure>\n<p>其中 objc_AssociationPolicy 是关联对象的属性，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_ASSOCIATION_ASSIGN             --- <span class=\"keyword\">assign</span></span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN_NONATOMIC   --- <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span></span><br><span class=\"line\">OBJC_ASSOCIATION_COPY_NONATOMIC     --- <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span></span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN             --- <span class=\"keyword\">retain</span></span><br><span class=\"line\">OBJC_ASSOCIATION_COPY               --- <span class=\"keyword\">copy</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"与-NSDictionary-的区别\"><a href=\"#与-NSDictionary-的区别\" class=\"headerlink\" title=\"与 NSDictionary 的区别\"></a>与 NSDictionary 的区别</h3><p>设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。</p>\n<p>所以 key 值（一般为 NSString）最好定义为一个全局静态变量，而不能每次都用 @”xxx”</p>\n<h3 id=\"例子1\"><a href=\"#例子1\" class=\"headerlink\" title=\"例子1\"></a>例子1</h3><p>假如一个页面有2个弹窗，那么代码可能是这样写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)askUserAQuestion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]</span><br><span class=\"line\">            initWithTitle:<span class=\"string\">@\"Question\"</span></span><br><span class=\"line\">                  message:<span class=\"string\">@\"What do you want to do?\"</span></span><br><span class=\"line\">                 delegate:<span class=\"keyword\">self</span></span><br><span class=\"line\">        cancelButtonTitle:<span class=\"string\">@\"Cancel\"</span></span><br><span class=\"line\">        otherButtonTitles:<span class=\"string\">@\"Continue\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [alert show];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UIAlertViewDelegate protocol method</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)alertView:(<span class=\"built_in\">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class=\"built_in\">NSInteger</span>)buttonIndex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buttonIndex == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doCancel];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doContinue];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点是alertView的处理逻辑和初始化逻辑分离，不易阅读。有一种解决方法是为 UIAlertView 添加一个 block 属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *EOCMyAlertViewKey = <span class=\"string\">\"EOCMyAlertViewKey\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)askUserAQuestion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]</span><br><span class=\"line\">\t        initWithTitle:<span class=\"string\">@\"Question\"</span></span><br><span class=\"line\">\t              message:<span class=\"string\">@\"What do you want to do?\"</span></span><br><span class=\"line\">\t             delegate:<span class=\"keyword\">self</span></span><br><span class=\"line\">\t    cancelButtonTitle:<span class=\"string\">@\"Cancel\"</span></span><br><span class=\"line\">\t    otherButtonTitles:<span class=\"string\">@\"Continue\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (^block)(<span class=\"built_in\">NSInteger</span>) = ^(<span class=\"built_in\">NSInteger</span> buttonIndex) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (buttonIndex == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\t    [<span class=\"keyword\">self</span> doCancel];</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"keyword\">else</span></span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\t    [<span class=\"keyword\">self</span> doContinue];</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tobjc_setAssociatedObject(alert,</span><br><span class=\"line\">                             EOCMyAlertViewKey,</span><br><span class=\"line\">                             block,</span><br><span class=\"line\">                             OBJC_ASSOCIATION_COPY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t[alert show];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UIAlertViewDelegate protocol method</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)alertView:(<span class=\"built_in\">UIAlertView</span> *)alertView</span><br><span class=\"line\">    clickedButtonAtIndex:(<span class=\"built_in\">NSInteger</span>)buttonIndex</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (^block)(<span class=\"built_in\">NSInteger</span>) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);</span><br><span class=\"line\">\tblock(buttonIndex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优点就是处理逻辑和初始化逻辑不再分离，但是使用 block 一不小心可能会引起保留环。一种更好的方法是弄个子类，比如 SIAlertView</p>\n<h3 id=\"例子2-为协议文件添加属性\"><a href=\"#例子2-为协议文件添加属性\" class=\"headerlink\" title=\"例子2 为协议文件添加属性\"></a>例子2 为协议文件添加属性</h3><p>.h</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"QLJCEONAVRSSFeed.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">QLJCEONAVRSSFeed</span> (<span class=\"title\">contentOffset</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>)<span class=\"built_in\">CGPoint</span> savedOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"QLJCEONAVRSSFeed+contentOffset.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define feed_saved_Off_set_x_key @<span class=\"meta-string\">\"feed_saved_Off_set_x_key\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#define feed_saved_Off_set_y_key @<span class=\"meta-string\">\"feed_saved_Off_set_y_key\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">QLJCEONAVRSSFeed</span> (<span class=\"title\">contentOffset</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> savedOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGPoint</span>)savedOffset</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *xObj = objc_getAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_x_key);</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *yObj = objc_getAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_y_key);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGPoint</span> point = <span class=\"built_in\">CGPointMake</span>([xObj floatValue], [yObj floatValue]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> point;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSavedOffset:(<span class=\"built_in\">CGPoint</span>)savedOffset</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_x_key, @(savedOffset.x), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, feed_saved_Off_set_y_key, @(savedOffset.y), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第11条：理解objc-msgSend的作用\"><a href=\"#第11条：理解objc-msgSend的作用\" class=\"headerlink\" title=\"第11条：理解objc_msgSend的作用\"></a>第11条：理解objc_msgSend的作用</h2><p>见 <a href=\"http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">Objective-C中的消息转发机制</a></p>\n<h2 id=\"第12条：理解消息转发机制\"><a href=\"#第12条：理解消息转发机制\" class=\"headerlink\" title=\"第12条：理解消息转发机制\"></a>第12条：理解消息转发机制</h2><p>见 <a href=\"http://norcy.github.io/2016/09/25/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">Objective-C中的消息转发机制</a></p>\n<h2 id=\"第13条：用“方法调配技术”调试“黑盒方法”\"><a href=\"#第13条：用“方法调配技术”调试“黑盒方法”\" class=\"headerlink\" title=\"第13条：用“方法调配技术”调试“黑盒方法”\"></a>第13条：用“方法调配技术”调试“黑盒方法”</h2><p>创建自己的方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSString+MyAdditions.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSString</span> (<span class=\"title\">MyAdditions</span>)</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)myLowercaseString</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *lowercase = [<span class=\"keyword\">self</span> myLowercaseString];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"This is my own method: %@\"</span>, lowercase);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lowercase;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>替换</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method originalMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(lowercaseString));</span><br><span class=\"line\">Method swappedMethod = class_getInstanceMethod([<span class=\"built_in\">NSString</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(myLowercaseString));</span><br><span class=\"line\">method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure>\n<h2 id=\"第14条：理解“类对象”的用意\"><a href=\"#第14条：理解“类对象”的用意\" class=\"headerlink\" title=\"第14条：理解“类对象”的用意\"></a>第14条：理解“类对象”的用意</h2><h3 id=\"我们所说的-Objective-C-对象究竟是什么\"><a href=\"#我们所说的-Objective-C-对象究竟是什么\" class=\"headerlink\" title=\"我们所说的 Objective-C 对象究竟是什么\"></a>我们所说的 Objective-C 对象究竟是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object&#123;</span><br><span class=\"line\">  Class isa;  <span class=\"comment\">//=&gt; 指向对象所属的类</span></span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>结论：Objective-C 对象 = id = objc_object</p>\n<h3 id=\"那么-Class-是什么\"><a href=\"#那么-Class-是什么\" class=\"headerlink\" title=\"那么 Class 是什么\"></a>那么 Class 是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>\n<h3 id=\"那么-objc-class-又是什么\"><a href=\"#那么-objc-class-又是什么\" class=\"headerlink\" title=\"那么 objc_class 又是什么\"></a>那么 objc_class 又是什么</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;  </span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class super_class;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> version;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> info;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache;  </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类的继承体系\"><a href=\"#类的继承体系\" class=\"headerlink\" title=\"类的继承体系\"></a>类的继承体系</h3><p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/isa.png\" alt=\"\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"Hello\"</span>;</span><br></pre></td></tr></table></figure>\n<p>str 是一个对象，is a NSString</p>\n<p>NSString 是类，is a NSString metaclass</p>\n<p>NSString metaclass 是元类，类方法就定义在这里</p>\n<h1 id=\"第3章-接口与API设计\"><a href=\"#第3章-接口与API设计\" class=\"headerlink\" title=\"第3章 接口与API设计\"></a>第3章 接口与API设计</h1><h2 id=\"done-第15条：用前缀避免命名空间冲突\"><a href=\"#done-第15条：用前缀避免命名空间冲突\" class=\"headerlink\" title=\"done 第15条：用前缀避免命名空间冲突\"></a>done 第15条：用前缀避免命名空间冲突</h2><h2 id=\"done-第16条：提供“全能初始化方法”\"><a href=\"#done-第16条：提供“全能初始化方法”\" class=\"headerlink\" title=\"done 第16条：提供“全能初始化方法”\"></a>done 第16条：提供“全能初始化方法”</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/4870303.html\" target=\"_blank\" rel=\"noopener\">Designated Initializer</a></p>\n<h2 id=\"done-第17条：实现description方法\"><a href=\"#done-第17条：实现description方法\" class=\"headerlink\" title=\"done 第17条：实现description方法\"></a>done 第17条：实现description方法</h2><h2 id=\"done-第18条：尽量使用不可变对象\"><a href=\"#done-第18条：尽量使用不可变对象\" class=\"headerlink\" title=\"done 第18条：尽量使用不可变对象\"></a>done 第18条：尽量使用不可变对象</h2><ul>\n<li>如果某个属性只是内部可修改，则在 .h 中应该声明为 readonly，然后再在扩展里面声明为 readwrite</li>\n<li>不要把可变的 Collection 对象(NSMutableSet/NSMutableDictionary/NSMutableArray 等)作为属性公开，应该提供 readonly 版本以及读写方法</li>\n</ul>\n<h2 id=\"done-第19条：使用清晰而协调的命名方式\"><a href=\"#done-第19条：使用清晰而协调的命名方式\" class=\"headerlink\" title=\"done 第19条：使用清晰而协调的命名方式:\"></a>done 第19条：使用清晰而协调的命名方式:</h2><h3 id=\"如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了\"><a href=\"#如果一个方法返回了某个变量，该方法命名不要使用-getXXX，直接使用-XXX-就行了\" class=\"headerlink\" title=\"如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了\"></a>如果一个方法返回了某个变量，该方法命名不要使用 getXXX，直接使用 XXX 就行了</h3><h3 id=\"对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX\"><a href=\"#对于-BOOL-类型，可以在属性声明的时候，指定其-getter-为-isXXX\" class=\"headerlink\" title=\"对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX\"></a>对于 BOOL 类型，可以在属性声明的时候，指定其 getter 为 isXXX</h3><pre><code>@property (nonatomic, assign, getter = isOn) on;\n</code></pre><h2 id=\"done-第20条：为私有方法名加前缀\"><a href=\"#done-第20条：为私有方法名加前缀\" class=\"headerlink\" title=\"done 第20条：为私有方法名加前缀\"></a>done 第20条：为私有方法名加前缀</h2><h2 id=\"done-第21条：理解Objective—C错误模型\"><a href=\"#done-第21条：理解Objective—C错误模型\" class=\"headerlink\" title=\"done 第21条：理解Objective—C错误模型\"></a>done 第21条：理解Objective—C错误模型</h2><h2 id=\"done-第22条：理解NSCopying协议\"><a href=\"#done-第22条：理解NSCopying协议\" class=\"headerlink\" title=\"done 第22条：理解NSCopying协议\"></a>done 第22条：理解NSCopying协议</h2><p>详见<a href=\"http://www.cnblogs.com/chenyg32/p/5167194.html\" target=\"_blank\" rel=\"noopener\">浅析Objective-C的copy</a></p>\n<h1 id=\"第4章-协议与分类\"><a href=\"#第4章-协议与分类\" class=\"headerlink\" title=\"第4章 协议与分类\"></a>第4章 协议与分类</h1><h2 id=\"第23条：通过委托与数据源协议进行对象间通信\"><a href=\"#第23条：通过委托与数据源协议进行对象间通信\" class=\"headerlink\" title=\"第23条：通过委托与数据源协议进行对象间通信\"></a>第23条：通过委托与数据源协议进行对象间通信</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>([_delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didReceiveData:)])</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [_delegate networkFetcher:<span class=\"keyword\">self</span> didReceiveData:data];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果上面的代码写了很多次，则可以考虑以下优化：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在扩展中定义结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span>(</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> didReceiveData : <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> didFailWithError : <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125; _delegateFlags; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> </span></span><br><span class=\"line\">EOCNetworkFetcher </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setDelegate:(<span class=\"keyword\">id</span>)delegate</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    _delegate = delegate; <span class=\"comment\">// 缓存委托对象相应方法能力 </span></span><br><span class=\"line\">    _delegateFlags.didReceiveData = [delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didReceiveData:)]; </span><br><span class=\"line\">    _delegateFlags.didFailWithError = [delegate respondsToSelector:<span class=\"keyword\">@selector</span>(networkFetcher:didFailWithError:)]; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\">这样每次调用delegate相关方法之前就只需要直接查询标志：</span><br><span class=\"line\"><span class=\"keyword\">if</span>(_delegateFlags.didReceiveData)</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    [_delegate networkFetcher:<span class=\"keyword\">self</span> didReceiveData:data]; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"done-第24条：将类的实现代码分散到便于管理的数个分类之中\"><a href=\"#done-第24条：将类的实现代码分散到便于管理的数个分类之中\" class=\"headerlink\" title=\"done 第24条：将类的实现代码分散到便于管理的数个分类之中\"></a>done 第24条：将类的实现代码分散到便于管理的数个分类之中</h2><h2 id=\"第25条：总是为第三方类的分类名称加前缀\"><a href=\"#第25条：总是为第三方类的分类名称加前缀\" class=\"headerlink\" title=\"第25条：总是为第三方类的分类名称加前缀\"></a>第25条：总是为第三方类的分类名称加前缀</h2><ol>\n<li>为第三方类添加分类时，总应给其名称加上你专用的前缀</li>\n<li>为第三方类添加分类时，总应给方法名加上你专用的前缀</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">ABC_HTTP</span>)</span></span><br><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)abc_urlEncodedString;</span><br><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)abc_urlDecodedString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"第26条：勿在分类中声明属性\"><a href=\"#第26条：勿在分类中声明属性\" class=\"headerlink\" title=\"第26条：勿在分类中声明属性\"></a>第26条：勿在分类中声明属性</h2><p>属性应该在主类中声明</p>\n<p>如果分类中声明属性需要自己重写 setter 和 getter</p>\n<p>方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *kFriendsPropertyKey = <span class=\"string\">\"kFriendsPropertyKey\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span>(<span class=\"title\">Friendship</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> friends;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"built_in\">NSArray</span>*)friends </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setFriends:(<span class=\"built_in\">NSArray</span>*)friends </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">　　objc_setAssociaedObject(<span class=\"keyword\">self</span>, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>缺点如下</p>\n<ol>\n<li>相似的代码要写很多遍</li>\n<li>极易忽略属性定义的内存管理语义，且不好维护</li>\n</ol>\n<h2 id=\"第27条：使用“class—continuation分类”隐藏实现细节\"><a href=\"#第27条：使用“class—continuation分类”隐藏实现细节\" class=\"headerlink\" title=\"第27条：使用“class—continuation分类”隐藏实现细节\"></a>第27条：使用“class—continuation分类”隐藏实现细节</h2><p>声明私有实例变量的3种方法</p>\n<ul>\n<li><p>方法1：对外暴露，声明为 private（暴露了细节，不建议）</p>\n<p>  .h</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>:<span class=\"title\">NSObject</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">@private</span></span><br><span class=\"line\">    XYZ *_xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>把私有变量放在头文件，暴露了细节，不好</li>\n<li>假如该实例变量是 objective-c++ 类，则所有引入该头文件的类都要编译为 objective-c++，即使使用 @class 也无法解决这个问题</li>\n<li>所以既然是私有变量，干嘛不放在 .m 中，偏偏要放到 .h 中作死呢？</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>方法2：不对外暴露</p>\n<p>  .m</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *_xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) XYZ *xyz2;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法3：对外只读，对内读写</p>\n<p>  .h</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) XYZ *xyz;</span><br></pre></td></tr></table></figure>\n<p>  .m</p>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ABC</span>()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readwrite</span>) XYZ *xyz;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"done-第28条：通过协议提供匿名对象\"><a href=\"#done-第28条：通过协议提供匿名对象\" class=\"headerlink\" title=\"done 第28条：通过协议提供匿名对象\"></a>done 第28条：通过协议提供匿名对象</h2><h1 id=\"第5章-内存管理\"><a href=\"#第5章-内存管理\" class=\"headerlink\" title=\"第5章 内存管理\"></a>第5章 内存管理</h1><h2 id=\"第29条：理解引用计数\"><a href=\"#第29条：理解引用计数\" class=\"headerlink\" title=\"第29条：理解引用计数\"></a>第29条：理解引用计数</h2><h3 id=\"悬浮指针\"><a href=\"#悬浮指针\" class=\"headerlink\" title=\"悬浮指针\"></a>悬浮指针</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number = [[<span class=\"built_in\">NSNumber</span> alloc] initWithInt:<span class=\"number\">1</span>];</span><br><span class=\"line\">[array addObject:number];</span><br><span class=\"line\">[number release];</span><br><span class=\"line\">number = <span class=\"literal\">nil</span>;   <span class=\"comment\">//如果 release 后不及时置为 nil，则 number 成为悬浮指针，指向的内存未知</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"autorelease\"><a href=\"#autorelease\" class=\"headerlink\" title=\"autorelease\"></a>autorelease</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringValue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"Hello\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况下，str 如果在方法内部 release，则调用者得到的一定是一个空对象；所以只能由调用者来负责释放</p>\n<p>但是，这是十分不合理的，因为从方法名上看（不含<code>alloc/new/copy/mutableCopy</code>），调用者并不知道它需要负责释放该对象</p>\n<p>所以此时，autorelease 就应运而生了</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringValue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"Hello\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [str autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>str 对象会在其所在的释放池释放的时候被释放</p>\n<p>如果外部需要 retain 该返回值，则需要这样做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = [[<span class=\"keyword\">self</span> stringValue] <span class=\"keyword\">retain</span>];</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">[str release];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>autorelease 能延长对象生命周期，使对象在方法结束后依然存活一段时间</p>\n</blockquote>\n<h2 id=\"第30条：以ARC简化引用计数\"><a href=\"#第30条：以ARC简化引用计数\" class=\"headerlink\" title=\"第30条：以ARC简化引用计数\"></a>第30条：以ARC简化引用计数</h2><h3 id=\"ARC-的本质是自动添加-release-retian-autorelease-等\"><a href=\"#ARC-的本质是自动添加-release-retian-autorelease-等\" class=\"headerlink\" title=\"ARC 的本质是自动添加 release/retian/autorelease 等\"></a>ARC 的本质是自动添加 release/retian/autorelease 等</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (XYZ *)newXYZ</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (XYZ *)createXYZ</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz = [[XYZ alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">/*ARC自动添加</span></span><br><span class=\"line\"><span class=\"comment\">    xyz = [xyz autorelease];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> xyz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)f</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    XYZ *xyz1 = [XYZ newXYZ];</span><br><span class=\"line\">    XYZ *xyz2 = [XYZ createXYZ];</span><br><span class=\"line\">    <span class=\"comment\">/*ARC自动添加</span></span><br><span class=\"line\"><span class=\"comment\">    [xyz1 release];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展阅读：iOS开发ARC内存管理技术要点\"><a href=\"#扩展阅读：iOS开发ARC内存管理技术要点\" class=\"headerlink\" title=\"扩展阅读：iOS开发ARC内存管理技术要点\"></a>扩展阅读：<a href=\"http://www.cnblogs.com/flyFreeZn/p/4264220.html\" target=\"_blank\" rel=\"noopener\">iOS开发ARC内存管理技术要点</a></h3><h2 id=\"done-第31条：在dealloc方法中只释放引用并解除监听\"><a href=\"#done-第31条：在dealloc方法中只释放引用并解除监听\" class=\"headerlink\" title=\"done 第31条：在dealloc方法中只释放引用并解除监听\"></a>done 第31条：在dealloc方法中只释放引用并解除监听</h2><h2 id=\"done-第32条：编写“异常安全代码”时留意内存管理问题\"><a href=\"#done-第32条：编写“异常安全代码”时留意内存管理问题\" class=\"headerlink\" title=\"done 第32条：编写“异常安全代码”时留意内存管理问题\"></a>done 第32条：编写“异常安全代码”时留意内存管理问题</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];</span><br><span class=\"line\"> [object release];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假如在执行 doSomethingThatMayThrow 方法中抛出异常，则 release 方法不会执行，会发生内存泄漏</p>\n<p>解决方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EOCSomeClass *object;</span><br><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@finally</span> &#123;</span><br><span class=\"line\"> [object release];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理，ARC 下也会发生这个问题</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\"> EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class=\"line\"> [object doSomethingThatMayThrow];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可通过打开 -fobjc-arc-exceptions 标记来解决这个问题，不过这个标记会带来性能问题</p>\n<p>总结：</p>\n<ol>\n<li>当捕获到异常,应该注意确保@try中创建的对象被清理完成.</li>\n<li>ARC在默认情况下不会清理抛出异常时的代码,但是可以通过打开一个编译器标记来完成.不过会产生大量的代码和运行时的成本.</li>\n</ol>\n<h2 id=\"done-第33条：以弱引用避免保留环\"><a href=\"#done-第33条：以弱引用避免保留环\" class=\"headerlink\" title=\"done 第33条：以弱引用避免保留环\"></a>done 第33条：以弱引用避免保留环</h2><h2 id=\"done-第34条：以“自动释放池块”降低内存峰值\"><a href=\"#done-第34条：以“自动释放池块”降低内存峰值\" class=\"headerlink\" title=\"done 第34条：以“自动释放池块”降低内存峰值\"></a>done 第34条：以“自动释放池块”降低内存峰值</h2><p>ARC下，可以使用 @autoreleasepool 来降低内存峰值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9999</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span>&#123;</span><br><span class=\"line\">        A *a = [[A alloc] init];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> handle:a];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>a 是临时对象，handle 方法中也可能创建一些临时对象，ARC 下，这些临时对象可能没有及时 release 而是放到自动释放池里，那么此时使用 @autoreleasepool 就能及时回收这些临时对象，从而降低内存峰值</p>\n<p>使用 enumerateObjectsUsingBlock 时，内部会自动添加一个 AutoreleasePool，而普通for循环和for in循环中没有<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[array enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>另外，@autoreleasepool 跟是否 ARC 无关，MRC 下也可以使用</p>\n<p>另外，关于降低内存峰值的之前也有学习过，见<a href=\"http://www.cnblogs.com/chenyg32/p/3859110.html\" target=\"_blank\" rel=\"noopener\">Objective-C 内存管理</a></p>\n<h2 id=\"done-第35条：用“僵尸对象”调试内存管理问题\"><a href=\"#done-第35条：用“僵尸对象”调试内存管理问题\" class=\"headerlink\" title=\"done 第35条：用“僵尸对象”调试内存管理问题\"></a>done 第35条：用“僵尸对象”调试内存管理问题</h2><p>僵尸对象是调试内存管理问题的最佳方式</p>\n<p>被回收对象的内存可能会被系统回收，也可能不会，这样调试起来就很困难，此时可以使用僵尸对象来调试。</p>\n<p>打开僵尸对象的方法：</p>\n<p>Xcode -&gt; Run -&gt; Diagnostics -&gt; Enable Zombie Objects<br><img src=\"http://img.blog.csdn.net/20150803102818758\" alt=\"\"></p>\n<p>僵尸对象的原理：</p>\n<p>替换 dealloc 方法，创建一个僵尸对象替换回收对象，从而达到不释放回收对象的内存</p>\n<p>原理代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Obtain the class of the object being deallocated</span></span><br><span class=\"line\">Class cls = object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the class's name</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *clsName = class_getName(cls);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prepend _NSZombie_ to the class name</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *zombieClsName = <span class=\"string\">@\"_NSZombie_\"</span> + clsName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// See if the specific zombie class exists</span></span><br><span class=\"line\">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If the specific zombie class doesn't exists,</span></span><br><span class=\"line\"><span class=\"comment\">// then it needs to be created</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!zombieCls)&#123;</span><br><span class=\"line\"><span class=\"comment\">// Obtain the template  zombie class, where the new class's </span></span><br><span class=\"line\"><span class=\"comment\">// name is the prepended string from above</span></span><br><span class=\"line\">   zombieCls = objc_duplicateClass(baseZombieCls,   </span><br><span class=\"line\">   zombieClsName,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Perform normal destruction of the object being deallocated</span></span><br><span class=\"line\">objc_destructInstance(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set the class of the object being deallocated</span></span><br><span class=\"line\"><span class=\"comment\">// to the zombie class</span></span><br><span class=\"line\">objc_setClass(<span class=\"keyword\">self</span>, zombieCls) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The class of \"self\" is now _NSZombie_OriginalClass</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"done-第36条：不要使用retainCount\"><a href=\"#done-第36条：不要使用retainCount\" class=\"headerlink\" title=\"done 第36条：不要使用retainCount\"></a>done 第36条：不要使用retainCount</h2><h1 id=\"第6章-块与大中枢派发\"><a href=\"#第6章-块与大中枢派发\" class=\"headerlink\" title=\"第6章 块与大中枢派发\"></a>第6章 块与大中枢派发</h1><h2 id=\"done-第37条：理解“块”这一概念\"><a href=\"#done-第37条：理解“块”这一概念\" class=\"headerlink\" title=\"done 第37条：理解“块”这一概念\"></a>done 第37条：理解“块”这一概念</h2><pre><code>在Objective-C语言中，一共有3种类型的block：\n_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。\n_NSConcreteStackBlock 保存在栈中的block，当函数返回时会被销毁。\n_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。\n</code></pre><ul>\n<li><p>全局 Block：_NSConcreteGlobalBlock</p>\n<ul>\n<li>定义在函数外面的 block 是全局静态的，没有访问任何外部变量</li>\n<li><p>定义在函数内部的 block，但是没有捕获任何自动变量，那么它也是全局的</p>\n<p>问题：那么定义在函数外部的，捕获变量的，是 global 吗？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ^&#123; printf(<span class=\"string\">\"Hello, World!\\n\"</span>); &#125; ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>栈 Block：_NSConcreteStackBlock</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    ^&#123; printf(<span class=\"string\">\"%c\\n\"</span>,a); &#125; ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>堆 Block：_NSConcreteMallocBlock</p>\n<p>  NSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，当一个栈 block 被 copy 的时候，才会将这个 block 复制到堆中</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> f()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = [^&#123; printf(<span class=\"string\">\"%c\\n\"</span>,a); &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>对全局 Block 进行 copy 后，什么事也不会发生\n对栈 Block 进行 copy 后，会得到一个堆 Block\n对堆 Block 进行 copy 后，其引用计数会加1\n</code></pre></li>\n<li><p>例子</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^blcok)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    block = ^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n<p>  block执行时，其内存可能已经被释放，因为它是一个栈 block，if 体结束时可能会被释放</p>\n<p>  正确做法是</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^blcok)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    block = [^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更多细节见<a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/\" target=\"_blank\" rel=\"noopener\">《谈Objective-C block的实现》</a></p>\n</li>\n</ul>\n<h2 id=\"done-第38条：为常用的块类型创建typedef\"><a href=\"#done-第38条：为常用的块类型创建typedef\" class=\"headerlink\" title=\"done 第38条：为常用的块类型创建typedef\"></a>done 第38条：为常用的块类型创建typedef</h2><h2 id=\"done-第39条：用handler块降低代码分散程度\"><a href=\"#done-第39条：用handler块降低代码分散程度\" class=\"headerlink\" title=\"done 第39条：用handler块降低代码分散程度\"></a>done 第39条：用handler块降低代码分散程度</h2><h2 id=\"第40条：用块引用其所属对象时不要出现保留环\"><a href=\"#第40条：用块引用其所属对象时不要出现保留环\" class=\"headerlink\" title=\"第40条：用块引用其所属对象时不要出现保留环\"></a>第40条：用块引用其所属对象时不要出现保留环</h2><p>例子1</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOCNetworkFetcher.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class=\"built_in\">NSData</span> *data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSURL</span> *url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithURL:(<span class=\"built_in\">NSURL</span>*)url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOCNetworkFetcher.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCNetworkFetcher.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCNetworkFetcher</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readwrite</span>) <span class=\"built_in\">NSURL</span> *url;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) EOCNetworkFetcherCompletionHandler completionHandler;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSData</span> *downloadedData;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCNetworkFetcher</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithURL:(<span class=\"built_in\">NSURL</span>*)url</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])) &#123;</span><br><span class=\"line\">\t\t\t\t_url = url;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">self</span>.completionHandler = completion;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Start the request</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Request sets downloadedData property</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// When request is finished, p_requestCompleted is called</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)p_requestCompleted &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_completionHandler) &#123;</span><br><span class=\"line\">\t\t\t\t_completionHandler(_downloadedData);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCClass</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EOCNetworkFetcher* _networkFetcher;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span>* _fetchedData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span>* url = [[<span class=\"built_in\">NSURL</span> alloc] initWithString:<span class=\"string\">@\"http://www.example.com/something.dat\"</span>];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t[_networkFetcher startWithCompletionHandler:^(<span class=\"built_in\">NSData</span> *data)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Request URL %@ finished\"</span>, _networkFetcher.url);</span><br><span class=\"line\">\t\t\t\t_fetchedData = data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>EoCClass -&gt; networkFetcher -&gt; block -&gt; self(通过_fetchedData)</p>\n<p>例子2</p>\n<p>将 networkFetcher 变为局部变量，修改如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)downloadData &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSURL</span> *url = [[<span class=\"built_in\">NSURL</span> alloc] initWithString:</span><br><span class=\"line\"> <span class=\"string\">@\"http://www.example.com/something.dat\"</span>];</span><br><span class=\"line\"> EOCNetworkFetcher *networkFetcher =</span><br><span class=\"line\"> [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class=\"line\"> [networkFetcher startWithCompletionHandler:^(<span class=\"built_in\">NSData</span> *data)&#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Request URL %@ finished\"</span>, networkFetcher.url);</span><br><span class=\"line\"> _fetchedData = data;</span><br><span class=\"line\"> &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>networkFetcher -&gt; block -&gt; networkFetcher(通过url)</p>\n<h2 id=\"第41条：多用派发队列，少用同步锁\"><a href=\"#第41条：多用派发队列，少用同步锁\" class=\"headerlink\" title=\"第41条：多用派发队列，少用同步锁\"></a>第41条：多用派发队列，少用同步锁</h2><h2 id=\"第42条：多用GCD，少用performSelector系列方法\"><a href=\"#第42条：多用GCD，少用performSelector系列方法\" class=\"headerlink\" title=\"第42条：多用GCD，少用performSelector系列方法\"></a>第42条：多用GCD，少用performSelector系列方法</h2><h3 id=\"如何延迟执行一个方法\"><a href=\"#如何延迟执行一个方法\" class=\"headerlink\" title=\"如何延迟执行一个方法\"></a>如何延迟执行一个方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1：使用 performSelector</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(foo) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">5.0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2：使用 dispatch_after</span></span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">5.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> foo];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>\n<p>当然，如果需要取消定时任务，则只能使用 performSelector，dispatch_after 无法取消</p>\n<h3 id=\"如何让一个方法在主线程执行\"><a href=\"#如何让一个方法在主线程执行\" class=\"headerlink\" title=\"如何让一个方法在主线程执行\"></a>如何让一个方法在主线程执行</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1：使用 performSelector</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(foo) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2：使用 dispatch_after</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> foo];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_after 比使用 performSelector 更好，因为 performSelector 可能引起内存问题</p>\n<h2 id=\"第43条：掌握GCD及操作队列的使用时机\"><a href=\"#第43条：掌握GCD及操作队列的使用时机\" class=\"headerlink\" title=\"第43条：掌握GCD及操作队列的使用时机\"></a>第43条：掌握GCD及操作队列的使用时机</h2><p>要知道有个东西叫做 NSOperationQueue 就行了</p>\n<h2 id=\"第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务\"><a href=\"#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务\" class=\"headerlink\" title=\"第44条：通过Dispatch Group机制，根据系统资源状况来执行任务\"></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务</h2><h2 id=\"第45条：使用dispatch-once来执行只需运行一次的线程安全代码\"><a href=\"#第45条：使用dispatch-once来执行只需运行一次的线程安全代码\" class=\"headerlink\" title=\"第45条：使用dispatch_once来执行只需运行一次的线程安全代码\"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h2><p>以后只要遇到“只需要执行一次的（线程安全）代码”，就应该想到 dispatch_once</p>\n<p>比如单例的书写方式<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"第46条：不要使用dispatch-get-current-queue\"><a href=\"#第46条：不要使用dispatch-get-current-queue\" class=\"headerlink\" title=\"第46条：不要使用dispatch_get_current_queue\"></a>第46条：不要使用<code>dispatch_get_current_queue</code></h2><p>尽量别用，该接口已废弃</p>\n<h1 id=\"第7章-系统框架\"><a href=\"#第7章-系统框架\" class=\"headerlink\" title=\"第7章 系统框架\"></a>第7章 系统框架</h1><h2 id=\"第47条：熟悉系统框架\"><a href=\"#第47条：熟悉系统框架\" class=\"headerlink\" title=\"第47条：熟悉系统框架\"></a>第47条：熟悉系统框架</h2><ul>\n<li>CFNetWork:网络接口，Foundation 框架将其部分内容封装为 Objective-C 接口（C语言）</li>\n<li>CoreAudio:音频处理 API（C语言）</li>\n<li>AVFoundation:视频处理接口（Objective-C）</li>\n<li>CoreData:数据库接口（Objective-C）</li>\n<li>CoreText:文字渲染排版接口（C语言）</li>\n</ul>\n<h2 id=\"done-第48条：多用块枚举，少用for循环\"><a href=\"#done-第48条：多用块枚举，少用for循环\" class=\"headerlink\" title=\"done 第48条：多用块枚举，少用for循环\"></a>done 第48条：多用块枚举，少用for循环</h2><h2 id=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"><a href=\"#第49条：对自定义其内存管理语义的collection使用无缝桥接\" class=\"headerlink\" title=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h2><h3 id=\"使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构\"><a href=\"#使用无缝桥接技术，转换-Foundation-框架的-Objective-C-对象和-CoreFoundation-框架的-C-语言数据结构\" class=\"headerlink\" title=\"使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构\"></a>使用无缝桥接技术，转换 Foundation 框架的 Objective-C 对象和 CoreFoundation 框架的 C 语言数据结构</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ count: %li\"</span>, cfArray, <span class=\"built_in\">CFArrayGetCount</span>(cfArray));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSArray 在 CoreFoundation 框架对应的数据结构是 CFArray，但是只能通过 CFArrayRef 指针来操纵 CFArray</li>\n<li>CFArrayGetCount 是 CoreFoundation 框架里获取数组大小的函数</li>\n</ul>\n<h3 id=\"桥式转换\"><a href=\"#桥式转换\" class=\"headerlink\" title=\"桥式转换\"></a>桥式转换</h3><ul>\n<li><code>__bridge</code>：只做类型转换，不修改对象（内存）管理权；</li>\n<li><code>__bridge_retained</code>：将 Objective-C 的对象转换为 CoreFoundation 的对象，同时 ARC 交出对象（内存）的管理权，后续需要使用 CFRelease 或者相关方法来释放对象；</li>\n<li><code>__bridge_transfer</code>：将 CoreFoundation 的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给 ARC</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge_retained <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(cfArray);  <span class=\"comment\">// 因为是 __bridge_retained，所以需要调用 CFRelease</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> cfArray = (__bridge_retained <span class=\"built_in\">CFArrayRef</span>)array;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *array2 = (__bridge_transfer <span class=\"built_in\">NSArray</span> *)cfArray;</span><br><span class=\"line\"><span class=\"comment\">//CFRelease(cfArray);  // 不需要 CFRelease，因为对象内存已经归 ARC 管理</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用无缝桥接修改-Collection-的内存管理语义\"><a href=\"#使用无缝桥接修改-Collection-的内存管理语义\" class=\"headerlink\" title=\"使用无缝桥接修改 Collection 的内存管理语义\"></a>使用无缝桥接修改 Collection 的内存管理语义</h3><p>NSMutableDictionary 加入键值对的时候，字典会自动“拷贝”键并“保留”值，如果键的对象不支持拷贝操作（没有实现 NSCopying 协议）呢？就会出现 Runtime Error</p>\n<p>关于拷贝协议可以查看：<a href=\"http://www.cnblogs.com/chenyg32/p/5167194.html\" target=\"_blank\" rel=\"noopener\">浅析Objective-C的copy</a></p>\n<p>无缝桥接可以从 CoreFoundation 层创建一个不拷贝键的字典</p>\n<p>创建函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> <span class=\"built_in\">CFDictionaryCreateMutable</span>(</span><br><span class=\"line\">    <span class=\"built_in\">CFAllocatorRef</span> allocator,  <span class=\"comment\">// 一般传NULL，采用系统默认的内存分配器</span></span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span> capacity,          <span class=\"comment\">// 初始大小，并非最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFDictionaryKeyCallBacks</span> *keyCallBacks,    <span class=\"comment\">// 回调</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">CFDictionaryValueCallBacks</span> *valueCallBacks <span class=\"comment\">// 回调</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>键值回调</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span>\t\t\t\tversion;    <span class=\"comment\">//一般为0</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRetainCallBack</span>\t\t<span class=\"keyword\">retain</span>; <span class=\"comment\">//遇到retain的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryReleaseCallBack</span>\t\trelease;<span class=\"comment\">//遇到release的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryCopyDescriptionCallBack</span>\tcopyDescription;<span class=\"comment\">//一般传NULL，采用系统默认</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryEqualCallBack</span>\t\tequal;  <span class=\"comment\">//一般传CFEqual</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryHashCallBack</span>\t\thash;   <span class=\"comment\">//一般传CFHash</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">CFDictionaryKeyCallBacks</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFIndex</span>\t\t\t\tversion;    <span class=\"comment\">//一般为0</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryRetainCallBack</span>\t\t<span class=\"keyword\">retain</span>; <span class=\"comment\">//遇到retain的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryReleaseCallBack</span>\t\trelease;<span class=\"comment\">//遇到release的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryCopyDescriptionCallBack</span>\tcopyDescription;    <span class=\"comment\">//一般传NULL，采用系统默认</span></span><br><span class=\"line\">    <span class=\"built_in\">CFDictionaryEqualCallBack</span>\t\tequal;  <span class=\"comment\">//一般传CFEqual</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">CFDictionaryValueCallBacks</span>;</span><br></pre></td></tr></table></figure>\n<p>创建“保留”键，“保留”值的 NSDictionary</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* EOCRetainCallback (<span class=\"built_in\">CFAllocatorRef</span> allocator , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CFRetain</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> EOCReleaseCallback(<span class=\"built_in\">CFAllocatorRef</span> allocator , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryKeyCallBacks</span> keyCallbacks = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCRetainCallback,</span><br><span class=\"line\">    EOCReleaseCallback,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFEqual</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFHash</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFDictionaryValueCallBacks</span> valueCallbacks = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    EOCRetainCallback,</span><br><span class=\"line\">    EOCReleaseCallback,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"built_in\">CFEqual</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">CFMutableDictionaryRef</span> aCFDictionary = <span class=\"built_in\">CFDictionaryCreateMutable</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, &amp;keyCallbacks, &amp;valueCallbacks);</span><br><span class=\"line\"><span class=\"built_in\">NSMutableDictionary</span> *anNSdictionary = (__bridge_transfer <span class=\"built_in\">NSMutableDictionary</span> *)aCFDictionary;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第50条：构建缓存时选用NSCache而非NSDictionary\"><a href=\"#第50条：构建缓存时选用NSCache而非NSDictionary\" class=\"headerlink\" title=\"第50条：构建缓存时选用NSCache而非NSDictionary\"></a>第50条：构建缓存时选用NSCache而非NSDictionary</h2><ul>\n<li>实现缓存时应选用 NSCache 而非 NSDictionary</li>\n<li>可以给 NSCache 设置缓存数量上限 countLimit 或缓存总和 totalCostLimit（单位 bytes），超过限制的时候系统会自动剔除部分缓存数据</li>\n<li>NSCache 收到系统低内存警告的时候会被系统自动删除，且是线程安全的（多线程环境下不需要对 NSCache 加锁）</li>\n<li>NSCache 不会像 NSDictionary 那样，拷贝对象（只会 retain，不会新建一个）</li>\n<li>使用 NSPurgeableData 作为 NSCache 的缓存时，系统收到低内存警告的时候，NSPurgeableData 对象所在内存会被系统释放，此时 NSCache 也会将其自动移除</li>\n</ul>\n<p>扩展阅读：<a href=\"https://www.ganlvji.com/nscache/\" target=\"_blank\" rel=\"noopener\">利用NSCache提升效率</a></p>\n<h2 id=\"第51条：精简initialize与load的实现代码\"><a href=\"#第51条：精简initialize与load的实现代码\" class=\"headerlink\" title=\"第51条：精简initialize与load的实现代码\"></a>第51条：精简initialize与load的实现代码</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">load</th>\n<th style=\"text-align:center\">initialize</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">执行次数</td>\n<td style=\"text-align:center\">1次</td>\n<td style=\"text-align:center\">1次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">执行时机</td>\n<td style=\"text-align:center\">app启动时所有运行时需要用到的类</td>\n<td style=\"text-align:center\">惰性调用，需要使用到具体类的时候才调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">作用</td>\n<td style=\"text-align:center\">调试 现基本不用</td>\n<td style=\"text-align:center\">初始化全局oc对象（普通对象可以在声明的时候初始化）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">执行时环境</td>\n<td style=\"text-align:center\">系统不稳定，许多东西尚未初始化</td>\n<td style=\"text-align:center\">系统处于正常状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">调用顺序</td>\n<td style=\"text-align:center\">1. 先调用本类的load，再调用其分类（如果有的话）2. 本类没写 系统不会调用其父类</td>\n<td style=\"text-align:center\">跟其它方法一样 本类没写 会自动调用父类，所以需要先判断类的类名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">相同点</td>\n<td style=\"text-align:center\">1. 调用的时候其它类不一定准备好 2. 代码要精简，只初始化变量，不调用方法 3. 线程安全，不必加锁</td>\n<td style=\"text-align:center\">同左</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\"><a href=\"#initialize-方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\" class=\"headerlink\" title=\"initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）\"></a>initialize 方法的正确写法（重要！！！不然有子类的情况下可能会调用多次）</h3><p>假设我想要在 A 的 initialize 方法中打印出自己，如果这样写：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">A</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">A</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">B</span> : <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>此时创建一个B对象，输出是</p>\n<blockquote>\n<p>A<br>B</p>\n</blockquote>\n<p>初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B</p>\n<p>所以 A 的 initialize 方法应该这样写</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [A <span class=\"keyword\">class</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时创建一个B对象，输出是</p>\n<blockquote>\n<p>B</p>\n</blockquote>\n<h2 id=\"第52条：别忘了NSTimer会保留其目标对象\"><a href=\"#第52条：别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"第52条：别忘了NSTimer会保留其目标对象\"></a>第52条：别忘了NSTimer会保留其目标对象</h2><p>参见：<a href=\"http://norcy.github.io/2016/06/20/NSTimer%20%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">NSTimer 会保留目标对象</a></p>\n","sticky":0},{"title":"别忘了NSTimer会保留其目标对象","date":"2016-06-19T16:00:00.000Z","keywords":"NSTimer;循环引用;self","_content":"\n# 别忘了NSTimer会保留其目标对象\n```objc\nself.timer = [NSTimer scheduledTimerWithTimeInterval:3\n                                              target:self\n                                            selector:@selector(f)\n                                            userInfo:nil\n                                             repeats:YES];\n\n- (void)dealloc\n{\n    [self.timer invalidate];\n}\n```\n由于 NSTimer 会引用住 self，而 self 又持有 NSTimer 对象，所以形成循环引用，dealloc 永远不会被执行，timer 也永远不会被释放，定时任务会一直执行下去\n# 在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器\n这种方法将 NSTimer 的停止时机提前到 viewWillDisappear，所以不会出现循环引用的问题，只是维护起来比较麻烦\n\n# 为什么不直接使用 weakself\n我的第一直觉是像解决 Block 的循环引用一样，所以尝试 weakself 方案\n\n```objc\n__weak typeof(self) weakSelf = self;\nself.timer = [NSTimer scheduledTimerWithTimeInterval:3\n                                              target:weakSelf\n                                            selector:@selector(f)\n                                            userInfo:nil\n                                             repeats:YES];\n```\n实验发现这种方案是无法解决循环引用的问题，这个问题其实很经典，新手很容易混淆，以为用 weakSelf 就可以解决所有循环引用问题\n\n回顾下，Block 中只是对变量 weakSelf 拷贝了一份，是拷贝变量而不是拷贝对象。即 Block 中也新定义了一个 weakSelf 对象，内部实现代码类似这样`__weak blockWeakSelf = weakSelf;`，对象的 retainCount 没有变化。如果拷贝的是 self，那么 Block 内部实现代码类似这样`__strong blockStrongSelf = self;`，strong 类型的拷贝操作是会使对象的 retainCount 加1的\n\n回到 NSTimer\n>   The timer maintains a strong reference to this object until it (the timer) is invalidated\n\nNSTimer 内部拿到 target 之后，就对其进行强引用，此时即使传入的是 weakSelf，但是 self 仍然会被引用住！因为是对对象本身进行引用，weakSelf 指向的跟 self 指向的都是同个对象，所以这里传 self 和 weakSelf 是没区别的。这也是为什么 block 里面用 strongSelf 强引用住 weakSelf，就可以让 self 不释放的原因\n\n# 使用 Block 来解决循环引用\n```objc\n//.h\n@interface NSTimer (NCYTimer)\n+ (NSTimer *)ncy_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;\n@end\n\n//.m\n@implementation NSTimer (NCYTimer)\n+ (NSTimer *)ncy_scheduledTimerWithTimeInterval:(NSTimeInterval)interval\n                                          block:(void(^)())block\n                                        repeats:(BOOL)repeats\n{\n    return [self scheduledTimerWithTimeInterval:interval\n                                         target:self\n                                       selector:@selector(ncy_blockHandle:)\n                                       userInfo:[block copy]    //记得使用 copy\n                                        repeats:repeats];\n}\n\n+ (void)ncy_blockHandle:(NSTimer *)timer\n{\n    void (^block)() = timer.userInfo;\n    if (block)\n    {\n        block();\n    }\n}\n@end\n```\n\n调用过程注意循环引用\n\n```objc\n__weak typeof(self) weakSelf = self;    //避免 block 强引用 self\nself.timer = [NSTimer ncy_scheduledTimerWithTimeInterval:3\n                                                   block:^{\n                                                       typeof(weakSelf) strongSelf = weakSelf;\n                                                       [strongSelf f];\n                                                   }\n                                                 repeats:YES];\n\n```\n+ 这套方案将计时器应执行的任务封装成 block，然后再放到 userInfo 传给计时器，block 作为参数传递时要 copy 到堆上，否则等到真正执行的时候很可能会被释放\n+ 这套方法依然存在循环引用的问题，但因为现在 NSTimer 引用的 target 是类对象，__类对象本身是个单例__，无需回收，而不是调用者，所以循环引用了也没关系\n+ 调用的时候记得 block 里面要用 weakSelf，然后使用的时候再将 weakSelf 转为 strongSelf，防止 block 执行过程中，self 被释放\n+ 疑问点：为什么类方法可以使用 self？\n    1. 类方法可以调用类方法\n    2. 类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法\n    3. 类方法不可以使用实例变量，类方法可以使用self，因为self不是实例变量\n    \t1. 实例方法里面的self，是对象的首地址\n    \t2. 类方法里面的self，是Class\n+ 疑问点：全部定时器执行的代码放到一个单例去做，不会冲突吗？定时器每执行一个任务就是新建一个线程吗\n\n    定时器每执行一个任务并没有新建一个线程，都是在当前线程，所以冲突是有可能的，假如某个任务很耗时，是会影响其他任务的执行的，更多线程问题可以参考[NSTimer和实现弱引用的timer的方式][1]\n\n# 使用 NSProxy 来解决循环引用\n引入一个对象 NSProxy，NSProxy 弱引用 self，然后 NSProxy 传入 NSTimer。即，self 强引用 NSTimer，NSTimer 强引用 NSProxy，NSProxy 弱引用 self，此时不会形成环。\n\n这个 NSProxy 可参考 [YYWeakProxy](https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m) 的实现\n\n# 参考资料\n+ 《Effective-Objective-C-读书笔记》之《第52条：别忘了NSTimer会保留其目标对象》\n+ [NSTimer和实现弱引用的timer的方式][1]\n[1]:http://www.jianshu.com/p/8121e4aadb4f","source":"_posts/NSTimer 会保留目标对象.md","raw":"---\ntitle: 别忘了NSTimer会保留其目标对象\ndate: 2016-06-20\ncategories:\n- iOS\nkeywords: NSTimer;循环引用;self\n---\n\n# 别忘了NSTimer会保留其目标对象\n```objc\nself.timer = [NSTimer scheduledTimerWithTimeInterval:3\n                                              target:self\n                                            selector:@selector(f)\n                                            userInfo:nil\n                                             repeats:YES];\n\n- (void)dealloc\n{\n    [self.timer invalidate];\n}\n```\n由于 NSTimer 会引用住 self，而 self 又持有 NSTimer 对象，所以形成循环引用，dealloc 永远不会被执行，timer 也永远不会被释放，定时任务会一直执行下去\n# 在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器\n这种方法将 NSTimer 的停止时机提前到 viewWillDisappear，所以不会出现循环引用的问题，只是维护起来比较麻烦\n\n# 为什么不直接使用 weakself\n我的第一直觉是像解决 Block 的循环引用一样，所以尝试 weakself 方案\n\n```objc\n__weak typeof(self) weakSelf = self;\nself.timer = [NSTimer scheduledTimerWithTimeInterval:3\n                                              target:weakSelf\n                                            selector:@selector(f)\n                                            userInfo:nil\n                                             repeats:YES];\n```\n实验发现这种方案是无法解决循环引用的问题，这个问题其实很经典，新手很容易混淆，以为用 weakSelf 就可以解决所有循环引用问题\n\n回顾下，Block 中只是对变量 weakSelf 拷贝了一份，是拷贝变量而不是拷贝对象。即 Block 中也新定义了一个 weakSelf 对象，内部实现代码类似这样`__weak blockWeakSelf = weakSelf;`，对象的 retainCount 没有变化。如果拷贝的是 self，那么 Block 内部实现代码类似这样`__strong blockStrongSelf = self;`，strong 类型的拷贝操作是会使对象的 retainCount 加1的\n\n回到 NSTimer\n>   The timer maintains a strong reference to this object until it (the timer) is invalidated\n\nNSTimer 内部拿到 target 之后，就对其进行强引用，此时即使传入的是 weakSelf，但是 self 仍然会被引用住！因为是对对象本身进行引用，weakSelf 指向的跟 self 指向的都是同个对象，所以这里传 self 和 weakSelf 是没区别的。这也是为什么 block 里面用 strongSelf 强引用住 weakSelf，就可以让 self 不释放的原因\n\n# 使用 Block 来解决循环引用\n```objc\n//.h\n@interface NSTimer (NCYTimer)\n+ (NSTimer *)ncy_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;\n@end\n\n//.m\n@implementation NSTimer (NCYTimer)\n+ (NSTimer *)ncy_scheduledTimerWithTimeInterval:(NSTimeInterval)interval\n                                          block:(void(^)())block\n                                        repeats:(BOOL)repeats\n{\n    return [self scheduledTimerWithTimeInterval:interval\n                                         target:self\n                                       selector:@selector(ncy_blockHandle:)\n                                       userInfo:[block copy]    //记得使用 copy\n                                        repeats:repeats];\n}\n\n+ (void)ncy_blockHandle:(NSTimer *)timer\n{\n    void (^block)() = timer.userInfo;\n    if (block)\n    {\n        block();\n    }\n}\n@end\n```\n\n调用过程注意循环引用\n\n```objc\n__weak typeof(self) weakSelf = self;    //避免 block 强引用 self\nself.timer = [NSTimer ncy_scheduledTimerWithTimeInterval:3\n                                                   block:^{\n                                                       typeof(weakSelf) strongSelf = weakSelf;\n                                                       [strongSelf f];\n                                                   }\n                                                 repeats:YES];\n\n```\n+ 这套方案将计时器应执行的任务封装成 block，然后再放到 userInfo 传给计时器，block 作为参数传递时要 copy 到堆上，否则等到真正执行的时候很可能会被释放\n+ 这套方法依然存在循环引用的问题，但因为现在 NSTimer 引用的 target 是类对象，__类对象本身是个单例__，无需回收，而不是调用者，所以循环引用了也没关系\n+ 调用的时候记得 block 里面要用 weakSelf，然后使用的时候再将 weakSelf 转为 strongSelf，防止 block 执行过程中，self 被释放\n+ 疑问点：为什么类方法可以使用 self？\n    1. 类方法可以调用类方法\n    2. 类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法\n    3. 类方法不可以使用实例变量，类方法可以使用self，因为self不是实例变量\n    \t1. 实例方法里面的self，是对象的首地址\n    \t2. 类方法里面的self，是Class\n+ 疑问点：全部定时器执行的代码放到一个单例去做，不会冲突吗？定时器每执行一个任务就是新建一个线程吗\n\n    定时器每执行一个任务并没有新建一个线程，都是在当前线程，所以冲突是有可能的，假如某个任务很耗时，是会影响其他任务的执行的，更多线程问题可以参考[NSTimer和实现弱引用的timer的方式][1]\n\n# 使用 NSProxy 来解决循环引用\n引入一个对象 NSProxy，NSProxy 弱引用 self，然后 NSProxy 传入 NSTimer。即，self 强引用 NSTimer，NSTimer 强引用 NSProxy，NSProxy 弱引用 self，此时不会形成环。\n\n这个 NSProxy 可参考 [YYWeakProxy](https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m) 的实现\n\n# 参考资料\n+ 《Effective-Objective-C-读书笔记》之《第52条：别忘了NSTimer会保留其目标对象》\n+ [NSTimer和实现弱引用的timer的方式][1]\n[1]:http://www.jianshu.com/p/8121e4aadb4f","slug":"NSTimer 会保留目标对象","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje87q0950007tjqwz2zhyzqa","content":"<h1 id=\"别忘了NSTimer会保留其目标对象\"><a href=\"#别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"别忘了NSTimer会保留其目标对象\"></a>别忘了NSTimer会保留其目标对象</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                              target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                            selector:<span class=\"keyword\">@selector</span>(f)</span><br><span class=\"line\">                                            userInfo:<span class=\"literal\">nil</span></span><br><span class=\"line\">                                             repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.timer invalidate];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 NSTimer 会引用住 self，而 self 又持有 NSTimer 对象，所以形成循环引用，dealloc 永远不会被执行，timer 也永远不会被释放，定时任务会一直执行下去</p>\n<h1 id=\"在-viewWillAppear-启动定时器，在-viewWillDisappear-停止定时器\"><a href=\"#在-viewWillAppear-启动定时器，在-viewWillDisappear-停止定时器\" class=\"headerlink\" title=\"在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器\"></a>在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器</h1><p>这种方法将 NSTimer 的停止时机提前到 viewWillDisappear，所以不会出现循环引用的问题，只是维护起来比较麻烦</p>\n<h1 id=\"为什么不直接使用-weakself\"><a href=\"#为什么不直接使用-weakself\" class=\"headerlink\" title=\"为什么不直接使用 weakself\"></a>为什么不直接使用 weakself</h1><p>我的第一直觉是像解决 Block 的循环引用一样，所以尝试 weakself 方案</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                              target:weakSelf</span><br><span class=\"line\">                                            selector:<span class=\"keyword\">@selector</span>(f)</span><br><span class=\"line\">                                            userInfo:<span class=\"literal\">nil</span></span><br><span class=\"line\">                                             repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>实验发现这种方案是无法解决循环引用的问题，这个问题其实很经典，新手很容易混淆，以为用 weakSelf 就可以解决所有循环引用问题</p>\n<p>回顾下，Block 中只是对变量 weakSelf 拷贝了一份，是拷贝变量而不是拷贝对象。即 Block 中也新定义了一个 weakSelf 对象，内部实现代码类似这样<code>__weak blockWeakSelf = weakSelf;</code>，对象的 retainCount 没有变化。如果拷贝的是 self，那么 Block 内部实现代码类似这样<code>__strong blockStrongSelf = self;</code>，strong 类型的拷贝操作是会使对象的 retainCount 加1的</p>\n<p>回到 NSTimer</p>\n<blockquote>\n<p>  The timer maintains a strong reference to this object until it (the timer) is invalidated</p>\n</blockquote>\n<p>NSTimer 内部拿到 target 之后，就对其进行强引用，此时即使传入的是 weakSelf，但是 self 仍然会被引用住！因为是对对象本身进行引用，weakSelf 指向的跟 self 指向的都是同个对象，所以这里传 self 和 weakSelf 是没区别的。这也是为什么 block 里面用 strongSelf 强引用住 weakSelf，就可以让 self 不释放的原因</p>\n<h1 id=\"使用-Block-来解决循环引用\"><a href=\"#使用-Block-来解决循环引用\" class=\"headerlink\" title=\"使用 Block 来解决循环引用\"></a>使用 Block 来解决循环引用</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">NCYTimer</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ncy_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval block:(<span class=\"keyword\">void</span>(^)())block repeats:(<span class=\"built_in\">BOOL</span>)repeats;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">NCYTimer</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ncy_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval</span><br><span class=\"line\">                                          block:(<span class=\"keyword\">void</span>(^)())block</span><br><span class=\"line\">                                        repeats:(<span class=\"built_in\">BOOL</span>)repeats</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> scheduledTimerWithTimeInterval:interval</span><br><span class=\"line\">                                         target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                       selector:<span class=\"keyword\">@selector</span>(ncy_blockHandle:)</span><br><span class=\"line\">                                       userInfo:[block <span class=\"keyword\">copy</span>]    <span class=\"comment\">//记得使用 copy</span></span><br><span class=\"line\">                                        repeats:repeats];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)ncy_blockHandle:(<span class=\"built_in\">NSTimer</span> *)timer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = timer.userInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>调用过程注意循环引用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;    <span class=\"comment\">//避免 block 强引用 self</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> ncy_scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                                   block:^&#123;</span><br><span class=\"line\">                                                       <span class=\"keyword\">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">                                                       [strongSelf f];</span><br><span class=\"line\">                                                   &#125;</span><br><span class=\"line\">                                                 repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这套方案将计时器应执行的任务封装成 block，然后再放到 userInfo 传给计时器，block 作为参数传递时要 copy 到堆上，否则等到真正执行的时候很可能会被释放</li>\n<li>这套方法依然存在循环引用的问题，但因为现在 NSTimer 引用的 target 是类对象，<strong>类对象本身是个单例</strong>，无需回收，而不是调用者，所以循环引用了也没关系</li>\n<li>调用的时候记得 block 里面要用 weakSelf，然后使用的时候再将 weakSelf 转为 strongSelf，防止 block 执行过程中，self 被释放</li>\n<li>疑问点：为什么类方法可以使用 self？<ol>\n<li>类方法可以调用类方法</li>\n<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法</li>\n<li>类方法不可以使用实例变量，类方法可以使用self，因为self不是实例变量<ol>\n<li>实例方法里面的self，是对象的首地址</li>\n<li>类方法里面的self，是Class</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>疑问点：全部定时器执行的代码放到一个单例去做，不会冲突吗？定时器每执行一个任务就是新建一个线程吗</p>\n<p>  定时器每执行一个任务并没有新建一个线程，都是在当前线程，所以冲突是有可能的，假如某个任务很耗时，是会影响其他任务的执行的，更多线程问题可以参考<a href=\"http://www.jianshu.com/p/8121e4aadb4f\" target=\"_blank\" rel=\"noopener\">NSTimer和实现弱引用的timer的方式</a></p>\n</li>\n</ul>\n<h1 id=\"使用-NSProxy-来解决循环引用\"><a href=\"#使用-NSProxy-来解决循环引用\" class=\"headerlink\" title=\"使用 NSProxy 来解决循环引用\"></a>使用 NSProxy 来解决循环引用</h1><p>引入一个对象 NSProxy，NSProxy 弱引用 self，然后 NSProxy 传入 NSTimer。即，self 强引用 NSTimer，NSTimer 强引用 NSProxy，NSProxy 弱引用 self，此时不会形成环。</p>\n<p>这个 NSProxy 可参考 <a href=\"https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m\" target=\"_blank\" rel=\"noopener\">YYWeakProxy</a> 的实现</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>《Effective-Objective-C-读书笔记》之《第52条：别忘了NSTimer会保留其目标对象》</li>\n<li><a href=\"http://www.jianshu.com/p/8121e4aadb4f\" target=\"_blank\" rel=\"noopener\">NSTimer和实现弱引用的timer的方式</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"别忘了NSTimer会保留其目标对象\"><a href=\"#别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"别忘了NSTimer会保留其目标对象\"></a>别忘了NSTimer会保留其目标对象</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                              target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                            selector:<span class=\"keyword\">@selector</span>(f)</span><br><span class=\"line\">                                            userInfo:<span class=\"literal\">nil</span></span><br><span class=\"line\">                                             repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.timer invalidate];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 NSTimer 会引用住 self，而 self 又持有 NSTimer 对象，所以形成循环引用，dealloc 永远不会被执行，timer 也永远不会被释放，定时任务会一直执行下去</p>\n<h1 id=\"在-viewWillAppear-启动定时器，在-viewWillDisappear-停止定时器\"><a href=\"#在-viewWillAppear-启动定时器，在-viewWillDisappear-停止定时器\" class=\"headerlink\" title=\"在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器\"></a>在 viewWillAppear 启动定时器，在 viewWillDisappear 停止定时器</h1><p>这种方法将 NSTimer 的停止时机提前到 viewWillDisappear，所以不会出现循环引用的问题，只是维护起来比较麻烦</p>\n<h1 id=\"为什么不直接使用-weakself\"><a href=\"#为什么不直接使用-weakself\" class=\"headerlink\" title=\"为什么不直接使用 weakself\"></a>为什么不直接使用 weakself</h1><p>我的第一直觉是像解决 Block 的循环引用一样，所以尝试 weakself 方案</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                              target:weakSelf</span><br><span class=\"line\">                                            selector:<span class=\"keyword\">@selector</span>(f)</span><br><span class=\"line\">                                            userInfo:<span class=\"literal\">nil</span></span><br><span class=\"line\">                                             repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>实验发现这种方案是无法解决循环引用的问题，这个问题其实很经典，新手很容易混淆，以为用 weakSelf 就可以解决所有循环引用问题</p>\n<p>回顾下，Block 中只是对变量 weakSelf 拷贝了一份，是拷贝变量而不是拷贝对象。即 Block 中也新定义了一个 weakSelf 对象，内部实现代码类似这样<code>__weak blockWeakSelf = weakSelf;</code>，对象的 retainCount 没有变化。如果拷贝的是 self，那么 Block 内部实现代码类似这样<code>__strong blockStrongSelf = self;</code>，strong 类型的拷贝操作是会使对象的 retainCount 加1的</p>\n<p>回到 NSTimer</p>\n<blockquote>\n<p>  The timer maintains a strong reference to this object until it (the timer) is invalidated</p>\n</blockquote>\n<p>NSTimer 内部拿到 target 之后，就对其进行强引用，此时即使传入的是 weakSelf，但是 self 仍然会被引用住！因为是对对象本身进行引用，weakSelf 指向的跟 self 指向的都是同个对象，所以这里传 self 和 weakSelf 是没区别的。这也是为什么 block 里面用 strongSelf 强引用住 weakSelf，就可以让 self 不释放的原因</p>\n<h1 id=\"使用-Block-来解决循环引用\"><a href=\"#使用-Block-来解决循环引用\" class=\"headerlink\" title=\"使用 Block 来解决循环引用\"></a>使用 Block 来解决循环引用</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">NCYTimer</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ncy_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval block:(<span class=\"keyword\">void</span>(^)())block repeats:(<span class=\"built_in\">BOOL</span>)repeats;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//.m</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">NCYTimer</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ncy_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval</span><br><span class=\"line\">                                          block:(<span class=\"keyword\">void</span>(^)())block</span><br><span class=\"line\">                                        repeats:(<span class=\"built_in\">BOOL</span>)repeats</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> scheduledTimerWithTimeInterval:interval</span><br><span class=\"line\">                                         target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                       selector:<span class=\"keyword\">@selector</span>(ncy_blockHandle:)</span><br><span class=\"line\">                                       userInfo:[block <span class=\"keyword\">copy</span>]    <span class=\"comment\">//记得使用 copy</span></span><br><span class=\"line\">                                        repeats:repeats];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)ncy_blockHandle:(<span class=\"built_in\">NSTimer</span> *)timer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (^block)() = timer.userInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>调用过程注意循环引用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;    <span class=\"comment\">//避免 block 强引用 self</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> ncy_scheduledTimerWithTimeInterval:<span class=\"number\">3</span></span><br><span class=\"line\">                                                   block:^&#123;</span><br><span class=\"line\">                                                       <span class=\"keyword\">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">                                                       [strongSelf f];</span><br><span class=\"line\">                                                   &#125;</span><br><span class=\"line\">                                                 repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这套方案将计时器应执行的任务封装成 block，然后再放到 userInfo 传给计时器，block 作为参数传递时要 copy 到堆上，否则等到真正执行的时候很可能会被释放</li>\n<li>这套方法依然存在循环引用的问题，但因为现在 NSTimer 引用的 target 是类对象，<strong>类对象本身是个单例</strong>，无需回收，而不是调用者，所以循环引用了也没关系</li>\n<li>调用的时候记得 block 里面要用 weakSelf，然后使用的时候再将 weakSelf 转为 strongSelf，防止 block 执行过程中，self 被释放</li>\n<li>疑问点：为什么类方法可以使用 self？<ol>\n<li>类方法可以调用类方法</li>\n<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法</li>\n<li>类方法不可以使用实例变量，类方法可以使用self，因为self不是实例变量<ol>\n<li>实例方法里面的self，是对象的首地址</li>\n<li>类方法里面的self，是Class</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>疑问点：全部定时器执行的代码放到一个单例去做，不会冲突吗？定时器每执行一个任务就是新建一个线程吗</p>\n<p>  定时器每执行一个任务并没有新建一个线程，都是在当前线程，所以冲突是有可能的，假如某个任务很耗时，是会影响其他任务的执行的，更多线程问题可以参考<a href=\"http://www.jianshu.com/p/8121e4aadb4f\" target=\"_blank\" rel=\"noopener\">NSTimer和实现弱引用的timer的方式</a></p>\n</li>\n</ul>\n<h1 id=\"使用-NSProxy-来解决循环引用\"><a href=\"#使用-NSProxy-来解决循环引用\" class=\"headerlink\" title=\"使用 NSProxy 来解决循环引用\"></a>使用 NSProxy 来解决循环引用</h1><p>引入一个对象 NSProxy，NSProxy 弱引用 self，然后 NSProxy 传入 NSTimer。即，self 强引用 NSTimer，NSTimer 强引用 NSProxy，NSProxy 弱引用 self，此时不会形成环。</p>\n<p>这个 NSProxy 可参考 <a href=\"https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m\" target=\"_blank\" rel=\"noopener\">YYWeakProxy</a> 的实现</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>《Effective-Objective-C-读书笔记》之《第52条：别忘了NSTimer会保留其目标对象》</li>\n<li><a href=\"http://www.jianshu.com/p/8121e4aadb4f\" target=\"_blank\" rel=\"noopener\">NSTimer和实现弱引用的timer的方式</a></li>\n</ul>\n","sticky":0},{"title":"NSUserdefaults与NSMutableArray的坑","date":"2016-06-11T16:00:00.000Z","keywords":"NSUserdefaults;NSMutableArray;死锁;mutex lock;immutable","_content":"\n# 需求\nApp 本地记录用户看过的视频记录\n# 方案\n很简单的需求，我们可以使用 NSUserDefaults 来维护一个数组，每次有新的视频记录产生的时候，如果该视频记录不存在，则添加进数组，并更新 NSUserDefaults，否则不做任何操作\n\n# 代码与坑\n## 版本一\n很直观地，我写出了下面这段代码\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] objectForKey:VIDEOKEY]; \nif (![videoArray containsObject:item])  //nil at first time\n{\n    [videoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n问题来了\n\n+ 如果是首次运行这段代码，videoArray 将会是空的，之后对 videoArray 做的一切操作都是没用的\n\n## 版本二\n\n好，继续修改我们的代码，确保 videoArray 不空\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] objectForKey:VIDEOKEY];\nif (!videoArray)\n    videoArray = [NSMutableArray array];\nif (![videoArray containsObject:item])\n{\n    [videoArray addObject:item];    //crash\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n问题来了\n\n+ 第一次插入元素没问题，但是第二次插入的时候在`[videoArray addObject:item];`就 Crash 了\n\nCrash信息：\n\n```objectivec\nTerminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'\n```\n\n为什么？因为我对 NSUserDefaults 的理解出错了，其实\n\n```objectivec\nNSUserDefaults 的 objectForKey 方法永远返回不可变对象\n(NSUserDefaults will always return an immutable version of the object you pass in)\n```\n\n+ 第一次运行，videoArray 是一个 NSMutableArray（__NSArrayM），往 NSUserDefaults 里塞 NSMutableArray 也不会出错\n+ 第二次运行，videoArray 已经存在，它是一个 NSArray（__NSCFArray），NSArray 执行 addObject，必挂无疑！\n\n## 版本三\n好啊，那 NSUserDefaults 会不会有可以返回可变对象的接口呢，比如\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];\nif (![videoArray containsObject:item])\n{\n    [videoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n这样看起来好像很完美，但是要明白的是\n\n+ `mutableArrayValueForKey` 是 KVC 里面的内容，而不是 NSUserDefaults 里的\n+ 即使 key 没找到，`mutableArrayValueForKey` 也不会返回 nil，所以这一段代码不需要做非空判断\n+ videoArray 打印出来是一个 `NSKeyValueSlowMutableArray`\n+ 其实如果直接修改 KVC 获取的这个可变对象而不写入 NSUserDefaults，其实是会影响 NSUserDefaults 里的内容，所以删除最后一行代码运行结果也是对的\n+ NSUserdefaults 返回不可变对象一定有它的原因（比如不想返回的对象被别人直接修改，而是必须通过自身的`setObject:forKey:`接口来修改），这里其实是借 KVC 的手实现了获得一个可变对象，这其实是违背了 NSUserdefaults 的初衷的，这种做法不可取\n\n但是，这里还有个最大最大的问题，**死锁**，留到后面讲。\n\n## 版本四\n最终版本出炉，使用`arrayForKey:`获取数组，并新建一个可变数组来执行增删操作\n\n```objectivec\nNSMutableArray *mutableVideoArray;\nNSArray *videoArray = [[NSUserDefaults standardUserDefaults] arrayForKey:VIDEOKEY];\nif (videoArray)\n    mutableVideoArray = [videoArray mutableCopy];\nelse\n    mutableVideoArray = [NSMutableArray array];\n    \nif (![mutableVideoArray containsObject:item])\n{\n    [mutableVideoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:mutableVideoArray forKey:VIDEOKEY];\n}\n```\n+ 这里使用`arrayForKey`而不是`objectForKey`，这样更贴切。\n\n# 关于死锁\n经实验，下面是发生死锁需要的最少行的代码\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];\n[videoArray addObject:item];\n[[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n```\n1. 如果删除`[videoArray addObject:item];`这一行，直接 Crash，因此要研究死锁问题，必须先保证数组非空，所以这里是最少代码\n2. 发生死锁是在最后一行代码里，是 iOS8 及以后版本的系统 bug（不过这种使用方法根本不对，也可以不算是 bug）\n3. 如果断点在最后一行，则不会死锁，而断点在第二行还是会死锁。因为断点错开了代码之间执行的时间，所以我们有理由推测，死锁是 KVC 里面的 addObject: 与 setObject: 同时进行的时候而产生的\n4. [StackOverFlow](http://stackoverflow.com/questions/26004892/ios-8-freezes-at-updating-userdefaults-object)上有类似问题\n\n# 结论\n+ 使用 NSUserDefaults 的时候注意非空判断\n+ NSUserDefaults 的 objectForKey 方法永远返回不可变对象，但 setObject:forKey: 的 object 参数可以是可变对象\n+ mutableArrayValueForKey 是 KVC 里面的内容，而不是 NSUserDefaults 里的，不建议使用它来获取 NSUserDefaults 的内容\n+ NSUserDefaults+KVC 的组合在 iOS8 及其之后是会有死锁的问题\n\n","source":"_posts/NSUserdefaults与NSMutableArray的坑.md","raw":"---\ntitle: NSUserdefaults与NSMutableArray的坑\ndate: 2016-06-12\ncategories:\n- iOS\nkeywords: NSUserdefaults;NSMutableArray;死锁;mutex lock;immutable\n---\n\n# 需求\nApp 本地记录用户看过的视频记录\n# 方案\n很简单的需求，我们可以使用 NSUserDefaults 来维护一个数组，每次有新的视频记录产生的时候，如果该视频记录不存在，则添加进数组，并更新 NSUserDefaults，否则不做任何操作\n\n# 代码与坑\n## 版本一\n很直观地，我写出了下面这段代码\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] objectForKey:VIDEOKEY]; \nif (![videoArray containsObject:item])  //nil at first time\n{\n    [videoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n问题来了\n\n+ 如果是首次运行这段代码，videoArray 将会是空的，之后对 videoArray 做的一切操作都是没用的\n\n## 版本二\n\n好，继续修改我们的代码，确保 videoArray 不空\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] objectForKey:VIDEOKEY];\nif (!videoArray)\n    videoArray = [NSMutableArray array];\nif (![videoArray containsObject:item])\n{\n    [videoArray addObject:item];    //crash\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n问题来了\n\n+ 第一次插入元素没问题，但是第二次插入的时候在`[videoArray addObject:item];`就 Crash 了\n\nCrash信息：\n\n```objectivec\nTerminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'\n```\n\n为什么？因为我对 NSUserDefaults 的理解出错了，其实\n\n```objectivec\nNSUserDefaults 的 objectForKey 方法永远返回不可变对象\n(NSUserDefaults will always return an immutable version of the object you pass in)\n```\n\n+ 第一次运行，videoArray 是一个 NSMutableArray（__NSArrayM），往 NSUserDefaults 里塞 NSMutableArray 也不会出错\n+ 第二次运行，videoArray 已经存在，它是一个 NSArray（__NSCFArray），NSArray 执行 addObject，必挂无疑！\n\n## 版本三\n好啊，那 NSUserDefaults 会不会有可以返回可变对象的接口呢，比如\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];\nif (![videoArray containsObject:item])\n{\n    [videoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n}\n```\n\n这样看起来好像很完美，但是要明白的是\n\n+ `mutableArrayValueForKey` 是 KVC 里面的内容，而不是 NSUserDefaults 里的\n+ 即使 key 没找到，`mutableArrayValueForKey` 也不会返回 nil，所以这一段代码不需要做非空判断\n+ videoArray 打印出来是一个 `NSKeyValueSlowMutableArray`\n+ 其实如果直接修改 KVC 获取的这个可变对象而不写入 NSUserDefaults，其实是会影响 NSUserDefaults 里的内容，所以删除最后一行代码运行结果也是对的\n+ NSUserdefaults 返回不可变对象一定有它的原因（比如不想返回的对象被别人直接修改，而是必须通过自身的`setObject:forKey:`接口来修改），这里其实是借 KVC 的手实现了获得一个可变对象，这其实是违背了 NSUserdefaults 的初衷的，这种做法不可取\n\n但是，这里还有个最大最大的问题，**死锁**，留到后面讲。\n\n## 版本四\n最终版本出炉，使用`arrayForKey:`获取数组，并新建一个可变数组来执行增删操作\n\n```objectivec\nNSMutableArray *mutableVideoArray;\nNSArray *videoArray = [[NSUserDefaults standardUserDefaults] arrayForKey:VIDEOKEY];\nif (videoArray)\n    mutableVideoArray = [videoArray mutableCopy];\nelse\n    mutableVideoArray = [NSMutableArray array];\n    \nif (![mutableVideoArray containsObject:item])\n{\n    [mutableVideoArray addObject:item];\n    [[NSUserDefaults standardUserDefaults] setObject:mutableVideoArray forKey:VIDEOKEY];\n}\n```\n+ 这里使用`arrayForKey`而不是`objectForKey`，这样更贴切。\n\n# 关于死锁\n经实验，下面是发生死锁需要的最少行的代码\n\n```objectivec\nNSMutableArray *videoArray = [[NSUserDefaults standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];\n[videoArray addObject:item];\n[[NSUserDefaults standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];\n```\n1. 如果删除`[videoArray addObject:item];`这一行，直接 Crash，因此要研究死锁问题，必须先保证数组非空，所以这里是最少代码\n2. 发生死锁是在最后一行代码里，是 iOS8 及以后版本的系统 bug（不过这种使用方法根本不对，也可以不算是 bug）\n3. 如果断点在最后一行，则不会死锁，而断点在第二行还是会死锁。因为断点错开了代码之间执行的时间，所以我们有理由推测，死锁是 KVC 里面的 addObject: 与 setObject: 同时进行的时候而产生的\n4. [StackOverFlow](http://stackoverflow.com/questions/26004892/ios-8-freezes-at-updating-userdefaults-object)上有类似问题\n\n# 结论\n+ 使用 NSUserDefaults 的时候注意非空判断\n+ NSUserDefaults 的 objectForKey 方法永远返回不可变对象，但 setObject:forKey: 的 object 参数可以是可变对象\n+ mutableArrayValueForKey 是 KVC 里面的内容，而不是 NSUserDefaults 里的，不建议使用它来获取 NSUserDefaults 的内容\n+ NSUserDefaults+KVC 的组合在 iOS8 及其之后是会有死锁的问题\n\n","slug":"NSUserdefaults与NSMutableArray的坑","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje87q0950008tjqwz4l5hdml","content":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>App 本地记录用户看过的视频记录</p>\n<h1 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h1><p>很简单的需求，我们可以使用 NSUserDefaults 来维护一个数组，每次有新的视频记录产生的时候，如果该视频记录不存在，则添加进数组，并更新 NSUserDefaults，否则不做任何操作</p>\n<h1 id=\"代码与坑\"><a href=\"#代码与坑\" class=\"headerlink\" title=\"代码与坑\"></a>代码与坑</h1><h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>很直观地，我写出了下面这段代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:VIDEOKEY]; </span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])  <span class=\"comment\">//nil at first time</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了</p>\n<ul>\n<li>如果是首次运行这段代码，videoArray 将会是空的，之后对 videoArray 做的一切操作都是没用的</li>\n</ul>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>好，继续修改我们的代码，确保 videoArray 不空</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!videoArray)</span><br><span class=\"line\">    videoArray = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];    <span class=\"comment\">//crash</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了</p>\n<ul>\n<li>第一次插入元素没问题，但是第二次插入的时候在<code>[videoArray addObject:item];</code>就 Crash 了</li>\n</ul>\n<p>Crash信息：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'</span><br></pre></td></tr></table></figure>\n<p>为什么？因为我对 NSUserDefaults 的理解出错了，其实</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUserDefaults</span> 的 objectForKey 方法永远返回不可变对象</span><br><span class=\"line\">(<span class=\"built_in\">NSUserDefaults</span> will always <span class=\"keyword\">return</span> an immutable version of the object you pass <span class=\"keyword\">in</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一次运行，videoArray 是一个 NSMutableArray（__NSArrayM），往 NSUserDefaults 里塞 NSMutableArray 也不会出错</li>\n<li>第二次运行，videoArray 已经存在，它是一个 NSArray（__NSCFArray），NSArray 执行 addObject，必挂无疑！</li>\n</ul>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><p>好啊，那 NSUserDefaults 会不会有可以返回可变对象的接口呢，比如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来好像很完美，但是要明白的是</p>\n<ul>\n<li><code>mutableArrayValueForKey</code> 是 KVC 里面的内容，而不是 NSUserDefaults 里的</li>\n<li>即使 key 没找到，<code>mutableArrayValueForKey</code> 也不会返回 nil，所以这一段代码不需要做非空判断</li>\n<li>videoArray 打印出来是一个 <code>NSKeyValueSlowMutableArray</code></li>\n<li>其实如果直接修改 KVC 获取的这个可变对象而不写入 NSUserDefaults，其实是会影响 NSUserDefaults 里的内容，所以删除最后一行代码运行结果也是对的</li>\n<li>NSUserdefaults 返回不可变对象一定有它的原因（比如不想返回的对象被别人直接修改，而是必须通过自身的<code>setObject:forKey:</code>接口来修改），这里其实是借 KVC 的手实现了获得一个可变对象，这其实是违背了 NSUserdefaults 的初衷的，这种做法不可取</li>\n</ul>\n<p>但是，这里还有个最大最大的问题，<strong>死锁</strong>，留到后面讲。</p>\n<h2 id=\"版本四\"><a href=\"#版本四\" class=\"headerlink\" title=\"版本四\"></a>版本四</h2><p>最终版本出炉，使用<code>arrayForKey:</code>获取数组，并新建一个可变数组来执行增删操作</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableVideoArray;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] arrayForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (videoArray)</span><br><span class=\"line\">    mutableVideoArray = [videoArray mutableCopy];</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    mutableVideoArray = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> (![mutableVideoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [mutableVideoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:mutableVideoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里使用<code>arrayForKey</code>而不是<code>objectForKey</code>，这样更贴切。</li>\n</ul>\n<h1 id=\"关于死锁\"><a href=\"#关于死锁\" class=\"headerlink\" title=\"关于死锁\"></a>关于死锁</h1><p>经实验，下面是发生死锁需要的最少行的代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];</span><br><span class=\"line\">[videoArray addObject:item];</span><br><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果删除<code>[videoArray addObject:item];</code>这一行，直接 Crash，因此要研究死锁问题，必须先保证数组非空，所以这里是最少代码</li>\n<li>发生死锁是在最后一行代码里，是 iOS8 及以后版本的系统 bug（不过这种使用方法根本不对，也可以不算是 bug）</li>\n<li>如果断点在最后一行，则不会死锁，而断点在第二行还是会死锁。因为断点错开了代码之间执行的时间，所以我们有理由推测，死锁是 KVC 里面的 addObject: 与 setObject: 同时进行的时候而产生的</li>\n<li><a href=\"http://stackoverflow.com/questions/26004892/ios-8-freezes-at-updating-userdefaults-object\" target=\"_blank\" rel=\"noopener\">StackOverFlow</a>上有类似问题</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><ul>\n<li>使用 NSUserDefaults 的时候注意非空判断</li>\n<li>NSUserDefaults 的 objectForKey 方法永远返回不可变对象，但 setObject:forKey: 的 object 参数可以是可变对象</li>\n<li>mutableArrayValueForKey 是 KVC 里面的内容，而不是 NSUserDefaults 里的，不建议使用它来获取 NSUserDefaults 的内容</li>\n<li>NSUserDefaults+KVC 的组合在 iOS8 及其之后是会有死锁的问题</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>App 本地记录用户看过的视频记录</p>\n<h1 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h1><p>很简单的需求，我们可以使用 NSUserDefaults 来维护一个数组，每次有新的视频记录产生的时候，如果该视频记录不存在，则添加进数组，并更新 NSUserDefaults，否则不做任何操作</p>\n<h1 id=\"代码与坑\"><a href=\"#代码与坑\" class=\"headerlink\" title=\"代码与坑\"></a>代码与坑</h1><h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>很直观地，我写出了下面这段代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:VIDEOKEY]; </span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])  <span class=\"comment\">//nil at first time</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了</p>\n<ul>\n<li>如果是首次运行这段代码，videoArray 将会是空的，之后对 videoArray 做的一切操作都是没用的</li>\n</ul>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>好，继续修改我们的代码，确保 videoArray 不空</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!videoArray)</span><br><span class=\"line\">    videoArray = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];    <span class=\"comment\">//crash</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了</p>\n<ul>\n<li>第一次插入元素没问题，但是第二次插入的时候在<code>[videoArray addObject:item];</code>就 Crash 了</li>\n</ul>\n<p>Crash信息：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[__NSCFArray insertObject:atIndex:]: mutating method sent to immutable object'</span><br></pre></td></tr></table></figure>\n<p>为什么？因为我对 NSUserDefaults 的理解出错了，其实</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUserDefaults</span> 的 objectForKey 方法永远返回不可变对象</span><br><span class=\"line\">(<span class=\"built_in\">NSUserDefaults</span> will always <span class=\"keyword\">return</span> an immutable version of the object you pass <span class=\"keyword\">in</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一次运行，videoArray 是一个 NSMutableArray（__NSArrayM），往 NSUserDefaults 里塞 NSMutableArray 也不会出错</li>\n<li>第二次运行，videoArray 已经存在，它是一个 NSArray（__NSCFArray），NSArray 执行 addObject，必挂无疑！</li>\n</ul>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><p>好啊，那 NSUserDefaults 会不会有可以返回可变对象的接口呢，比如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (![videoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [videoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来好像很完美，但是要明白的是</p>\n<ul>\n<li><code>mutableArrayValueForKey</code> 是 KVC 里面的内容，而不是 NSUserDefaults 里的</li>\n<li>即使 key 没找到，<code>mutableArrayValueForKey</code> 也不会返回 nil，所以这一段代码不需要做非空判断</li>\n<li>videoArray 打印出来是一个 <code>NSKeyValueSlowMutableArray</code></li>\n<li>其实如果直接修改 KVC 获取的这个可变对象而不写入 NSUserDefaults，其实是会影响 NSUserDefaults 里的内容，所以删除最后一行代码运行结果也是对的</li>\n<li>NSUserdefaults 返回不可变对象一定有它的原因（比如不想返回的对象被别人直接修改，而是必须通过自身的<code>setObject:forKey:</code>接口来修改），这里其实是借 KVC 的手实现了获得一个可变对象，这其实是违背了 NSUserdefaults 的初衷的，这种做法不可取</li>\n</ul>\n<p>但是，这里还有个最大最大的问题，<strong>死锁</strong>，留到后面讲。</p>\n<h2 id=\"版本四\"><a href=\"#版本四\" class=\"headerlink\" title=\"版本四\"></a>版本四</h2><p>最终版本出炉，使用<code>arrayForKey:</code>获取数组，并新建一个可变数组来执行增删操作</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *mutableVideoArray;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] arrayForKey:VIDEOKEY];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (videoArray)</span><br><span class=\"line\">    mutableVideoArray = [videoArray mutableCopy];</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    mutableVideoArray = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> (![mutableVideoArray containsObject:item])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [mutableVideoArray addObject:item];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:mutableVideoArray forKey:VIDEOKEY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里使用<code>arrayForKey</code>而不是<code>objectForKey</code>，这样更贴切。</li>\n</ul>\n<h1 id=\"关于死锁\"><a href=\"#关于死锁\" class=\"headerlink\" title=\"关于死锁\"></a>关于死锁</h1><p>经实验，下面是发生死锁需要的最少行的代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> *videoArray = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] mutableArrayValueForKey:VIDEOKEY];</span><br><span class=\"line\">[videoArray addObject:item];</span><br><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:videoArray forKey:VIDEOKEY];</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果删除<code>[videoArray addObject:item];</code>这一行，直接 Crash，因此要研究死锁问题，必须先保证数组非空，所以这里是最少代码</li>\n<li>发生死锁是在最后一行代码里，是 iOS8 及以后版本的系统 bug（不过这种使用方法根本不对，也可以不算是 bug）</li>\n<li>如果断点在最后一行，则不会死锁，而断点在第二行还是会死锁。因为断点错开了代码之间执行的时间，所以我们有理由推测，死锁是 KVC 里面的 addObject: 与 setObject: 同时进行的时候而产生的</li>\n<li><a href=\"http://stackoverflow.com/questions/26004892/ios-8-freezes-at-updating-userdefaults-object\" target=\"_blank\" rel=\"noopener\">StackOverFlow</a>上有类似问题</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><ul>\n<li>使用 NSUserDefaults 的时候注意非空判断</li>\n<li>NSUserDefaults 的 objectForKey 方法永远返回不可变对象，但 setObject:forKey: 的 object 参数可以是可变对象</li>\n<li>mutableArrayValueForKey 是 KVC 里面的内容，而不是 NSUserDefaults 里的，不建议使用它来获取 NSUserDefaults 的内容</li>\n<li>NSUserDefaults+KVC 的组合在 iOS8 及其之后是会有死锁的问题</li>\n</ul>\n","sticky":0},{"title":"Objective-C中的消息转发机制","date":"2016-09-24T16:00:00.000Z","photos":[],"keywords":"Objective-C;objc_msgSend;消息转发;runtime;dynamic;","_content":"\n# Objective-C 中函数调用的实质\n\n```objc\nid returnValue = [someObj messageName:params];\n\n// 运行时转化为\nid returnValue = objc_msgSend(someObj, @selector(messageName:), params);\n```\n注意：\n\n从该接收者所属的类的方法列表中寻找（每次找到都会缓存下，以供下次查找用），找不到就沿着继承树向上搜索，最后还是没找到，就执行消息转发\n\n# 消息转发分为三大阶段\n第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做__动态方法解析__（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。\n\n第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。\n\n第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/msgSend.png)\n\n## 动态方法解析\n对象在收到无法响应的消息后，会调用其所属类的下列方法\n\n```objc\n/**\n *  如果尚未实现的方法是实例方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增实例方法用以处理selector\n */\n+ (BOOL)resolveInstanceMethod:(SEL)selector;\n/**\n *  如果尚未实现的方法是类方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增类方法用以处理selector\n */\n+ (BOOL)resolveClassMethod:(SEL)selector;\n```\n\n## 备援接收者\n如果无法动态解析方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为\n\n```objc\n/**\n *  此方法询问是否能将消息转给其他接收者来处理\n *\n *  @param aSelector 未处理的方法\n *\n *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；\n */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n```\n\n## 完整的消息转发机制\n如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为\n\n```objc\n/**\n *  消息派发系统通过此方法，将消息派发给目标对象\n *\n *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容\n */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n\n# 例子：利用消息转发机制实现@dynamic属性\n.h\n\n```objc\n#import <Foundation/Foundation.h>\n\n@interface NCYAutoDictionary : NSObject\n@property (nonatomic,strong) NSString *myName;\n@end\n```\n.m\n\n```objc\n#import \"NCYAutoDictionary.h\"\n#import <objc/message.h>\n\nid autoDictionaryGetter(id self, SEL _cmd);\nvoid autoDictionarySetter(id self, SEL _cmd, id value);\n\n@interface NCYAutoDictionary ()\n@property (nonatomic, strong) NSMutableDictionary *backingStore;\n@end\n\n@implementation NCYAutoDictionary\n@dynamic myName;\n\n- (instancetype)init\n{\n\tif (self = [super init])\n\t{\n\t\t_backingStore = [NSMutableDictionary new];\n\t}\n\treturn self;\n}\n\nid autoDictionaryGetter(id self, SEL _cmd)\n{\n\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)self;\n\tNSMutableDictionary *backingStore = typeSelf.backingStore;\n\n\tNSString *key = NSStringFromSelector(_cmd);\n\n\treturn [backingStore objectForKey:key];\n}\n\nvoid autoDictionarySetter(id self, SEL _cmd, id value)\n{\n\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)self;\n\tNSMutableDictionary *backingStore = typeSelf.backingStore;\n\n\tNSString *seletorString = NSStringFromSelector(_cmd);\n\n\tNSMutableString *key = [seletorString mutableCopy];\n\n\t// 将 \"setSomething:\" 转为 \"something\"\n\t// remove :\n\t[key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];\n\n\t// remove set\n\t[key deleteCharactersInRange:NSMakeRange(0, 3)];\n\n\t// lowercase the first character\n\tNSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];\n\n\t[key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];\n\n\tif (value)\n\t{\n\t\t[backingStore setObject:value forKey:key];\n\t}\n\telse\n\t{\n\t\t[backingStore removeObjectForKey:key];\n\t}\n}\n\n// 运行时动态添加方法，对于同一个SEL，执行完该函数后，就不会再次走到这里，因为方法已经添加到类中去了（程序运行时都有效）\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n\tNSString *selectorString = NSStringFromSelector(sel);\n\tif ([selectorString hasPrefix:@\"set\"])\n\t{\n\t\tclass_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");\n\t}\n\telse\n\t{\n\t\tclass_addMethod(self, sel, (IMP)autoDictionaryGetter, \"@@:\");\n\t}\n\treturn true;\n}\n@end\n```\n\n测试\n\n```objc\nNCYAutoDictionary *myDic = [[NCYAutoDictionary alloc] init];\nmyDic.myName = @\"Norcy\";\nNSLog(@\"%@\", myDic.myName);   // 打印\"Norcy\"\n```\n## 注意\n1. 对于同一个SEL，执行完 `resolveInstanceMethod:` 后，下次调用该SEL的方法时，就不会再次执行 `resolveInstanceMethod:`，因为方法已经添加到类中去了（程序运行时都有效）\n2. `class_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");`\n\n    最后一个参数是编码格式，详见[苹果官方文档](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)\n3. `autoDictionarySetter`的参数是怎么确定的？\n\n    因为外部调用的时候其实是 `[myDic setMyName:@\"Norcy\"]`\n    \n    即 `objc_msgSend(myDic, @selector(setMyName:), @\"Norcy\")`\n    \n    经过 `resolveInstanceMethod:` 替换之后，`setMyName:` 的消息都会转发给 `autoDictionarySetter` 来实现\n    \n    `autoDictionarySetter` 是一个 IMP，默认的参数就有2个，id self 和 SEL _cmd，最后一个参数 value 是 `setMyName:` 带过来的参数，以此确定\n\n# 参考文章\n+ 《Effective Objective-C 2.0》第11条和第12条\n","source":"_posts/Objective-C中的消息转发机制.md","raw":"---\ntitle: Objective-C中的消息转发机制\ndate: 2016-09-25\ncategories:\n- iOS\nphotos: \nkeywords: Objective-C;objc_msgSend;消息转发;runtime;dynamic;\n---\n\n# Objective-C 中函数调用的实质\n\n```objc\nid returnValue = [someObj messageName:params];\n\n// 运行时转化为\nid returnValue = objc_msgSend(someObj, @selector(messageName:), params);\n```\n注意：\n\n从该接收者所属的类的方法列表中寻找（每次找到都会缓存下，以供下次查找用），找不到就沿着继承树向上搜索，最后还是没找到，就执行消息转发\n\n# 消息转发分为三大阶段\n第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做__动态方法解析__（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。\n\n第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。\n\n第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/msgSend.png)\n\n## 动态方法解析\n对象在收到无法响应的消息后，会调用其所属类的下列方法\n\n```objc\n/**\n *  如果尚未实现的方法是实例方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增实例方法用以处理selector\n */\n+ (BOOL)resolveInstanceMethod:(SEL)selector;\n/**\n *  如果尚未实现的方法是类方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增类方法用以处理selector\n */\n+ (BOOL)resolveClassMethod:(SEL)selector;\n```\n\n## 备援接收者\n如果无法动态解析方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为\n\n```objc\n/**\n *  此方法询问是否能将消息转给其他接收者来处理\n *\n *  @param aSelector 未处理的方法\n *\n *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；\n */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n```\n\n## 完整的消息转发机制\n如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为\n\n```objc\n/**\n *  消息派发系统通过此方法，将消息派发给目标对象\n *\n *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容\n */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n\n# 例子：利用消息转发机制实现@dynamic属性\n.h\n\n```objc\n#import <Foundation/Foundation.h>\n\n@interface NCYAutoDictionary : NSObject\n@property (nonatomic,strong) NSString *myName;\n@end\n```\n.m\n\n```objc\n#import \"NCYAutoDictionary.h\"\n#import <objc/message.h>\n\nid autoDictionaryGetter(id self, SEL _cmd);\nvoid autoDictionarySetter(id self, SEL _cmd, id value);\n\n@interface NCYAutoDictionary ()\n@property (nonatomic, strong) NSMutableDictionary *backingStore;\n@end\n\n@implementation NCYAutoDictionary\n@dynamic myName;\n\n- (instancetype)init\n{\n\tif (self = [super init])\n\t{\n\t\t_backingStore = [NSMutableDictionary new];\n\t}\n\treturn self;\n}\n\nid autoDictionaryGetter(id self, SEL _cmd)\n{\n\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)self;\n\tNSMutableDictionary *backingStore = typeSelf.backingStore;\n\n\tNSString *key = NSStringFromSelector(_cmd);\n\n\treturn [backingStore objectForKey:key];\n}\n\nvoid autoDictionarySetter(id self, SEL _cmd, id value)\n{\n\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)self;\n\tNSMutableDictionary *backingStore = typeSelf.backingStore;\n\n\tNSString *seletorString = NSStringFromSelector(_cmd);\n\n\tNSMutableString *key = [seletorString mutableCopy];\n\n\t// 将 \"setSomething:\" 转为 \"something\"\n\t// remove :\n\t[key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];\n\n\t// remove set\n\t[key deleteCharactersInRange:NSMakeRange(0, 3)];\n\n\t// lowercase the first character\n\tNSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];\n\n\t[key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];\n\n\tif (value)\n\t{\n\t\t[backingStore setObject:value forKey:key];\n\t}\n\telse\n\t{\n\t\t[backingStore removeObjectForKey:key];\n\t}\n}\n\n// 运行时动态添加方法，对于同一个SEL，执行完该函数后，就不会再次走到这里，因为方法已经添加到类中去了（程序运行时都有效）\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n\tNSString *selectorString = NSStringFromSelector(sel);\n\tif ([selectorString hasPrefix:@\"set\"])\n\t{\n\t\tclass_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");\n\t}\n\telse\n\t{\n\t\tclass_addMethod(self, sel, (IMP)autoDictionaryGetter, \"@@:\");\n\t}\n\treturn true;\n}\n@end\n```\n\n测试\n\n```objc\nNCYAutoDictionary *myDic = [[NCYAutoDictionary alloc] init];\nmyDic.myName = @\"Norcy\";\nNSLog(@\"%@\", myDic.myName);   // 打印\"Norcy\"\n```\n## 注意\n1. 对于同一个SEL，执行完 `resolveInstanceMethod:` 后，下次调用该SEL的方法时，就不会再次执行 `resolveInstanceMethod:`，因为方法已经添加到类中去了（程序运行时都有效）\n2. `class_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");`\n\n    最后一个参数是编码格式，详见[苹果官方文档](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)\n3. `autoDictionarySetter`的参数是怎么确定的？\n\n    因为外部调用的时候其实是 `[myDic setMyName:@\"Norcy\"]`\n    \n    即 `objc_msgSend(myDic, @selector(setMyName:), @\"Norcy\")`\n    \n    经过 `resolveInstanceMethod:` 替换之后，`setMyName:` 的消息都会转发给 `autoDictionarySetter` 来实现\n    \n    `autoDictionarySetter` 是一个 IMP，默认的参数就有2个，id self 和 SEL _cmd，最后一个参数 value 是 `setMyName:` 带过来的参数，以此确定\n\n# 参考文章\n+ 《Effective Objective-C 2.0》第11条和第12条\n","slug":"Objective-C中的消息转发机制","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","link":"","_id":"cje87q097000atjqweawpdx0t","content":"<h1 id=\"Objective-C-中函数调用的实质\"><a href=\"#Objective-C-中函数调用的实质\" class=\"headerlink\" title=\"Objective-C 中函数调用的实质\"></a>Objective-C 中函数调用的实质</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> returnValue = [someObj messageName:params];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时转化为</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> returnValue = objc_msgSend(someObj, <span class=\"keyword\">@selector</span>(messageName:), params);</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p>从该接收者所属的类的方法列表中寻找（每次找到都会缓存下，以供下次查找用），找不到就沿着继承树向上搜索，最后还是没找到，就执行消息转发</p>\n<h1 id=\"消息转发分为三大阶段\"><a href=\"#消息转发分为三大阶段\" class=\"headerlink\" title=\"消息转发分为三大阶段\"></a>消息转发分为三大阶段</h1><p>第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做<strong>动态方法解析</strong>（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。</p>\n<p>第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。</p>\n<p>第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/msgSend.png\" alt=\"\"></p>\n<h2 id=\"动态方法解析\"><a href=\"#动态方法解析\" class=\"headerlink\" title=\"动态方法解析\"></a>动态方法解析</h2><p>对象在收到无法响应的消息后，会调用其所属类的下列方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果尚未实现的方法是实例方法，则调用此函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param selector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 返回布尔值，表示是否能新增实例方法用以处理selector</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)selector;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果尚未实现的方法是类方法，则调用此函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param selector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 返回布尔值，表示是否能新增类方法用以处理selector</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)selector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"备援接收者\"><a href=\"#备援接收者\" class=\"headerlink\" title=\"备援接收者\"></a>备援接收者</h2><p>如果无法动态解析方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  此方法询问是否能将消息转给其他接收者来处理</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param aSelector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整的消息转发机制\"><a href=\"#完整的消息转发机制\" class=\"headerlink\" title=\"完整的消息转发机制\"></a>完整的消息转发机制</h2><p>如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  消息派发系统通过此方法，将消息派发给目标对象</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure>\n<h1 id=\"例子：利用消息转发机制实现-dynamic属性\"><a href=\"#例子：利用消息转发机制实现-dynamic属性\" class=\"headerlink\" title=\"例子：利用消息转发机制实现@dynamic属性\"></a>例子：利用消息转发机制实现@dynamic属性</h1><p>.h</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NCYAutoDictionary</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *myName;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NCYAutoDictionary.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> autoDictionaryGetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd);</span><br><span class=\"line\"><span class=\"keyword\">void</span> autoDictionarySetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> value);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NCYAutoDictionary</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *backingStore;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NCYAutoDictionary</span></span></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> myName;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_backingStore = [<span class=\"built_in\">NSMutableDictionary</span> new];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> autoDictionaryGetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)<span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableDictionary</span> *backingStore = typeSelf.backingStore;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *key = <span class=\"built_in\">NSStringFromSelector</span>(_cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> [backingStore objectForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> autoDictionarySetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)<span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableDictionary</span> *backingStore = typeSelf.backingStore;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *seletorString = <span class=\"built_in\">NSStringFromSelector</span>(_cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> *key = [seletorString mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将 \"setSomething:\" 转为 \"something\"</span></span><br><span class=\"line\">\t<span class=\"comment\">// remove :</span></span><br><span class=\"line\">\t[key deleteCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(key.length - <span class=\"number\">1</span>, <span class=\"number\">1</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// remove set</span></span><br><span class=\"line\">\t[key deleteCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// lowercase the first character</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *lowercaseFirstChar = [[key substringToIndex:<span class=\"number\">1</span>] lowercaseString];</span><br><span class=\"line\"></span><br><span class=\"line\">\t[key replaceCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>) withString:lowercaseFirstChar];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (value)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t[backingStore setObject:value forKey:key];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t[backingStore removeObjectForKey:key];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时动态添加方法，对于同一个SEL，执行完该函数后，就不会再次走到这里，因为方法已经添加到类中去了（程序运行时都有效）</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *selectorString = <span class=\"built_in\">NSStringFromSelector</span>(sel);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ([selectorString hasPrefix:<span class=\"string\">@\"set\"</span>])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tclass_addMethod(<span class=\"keyword\">self</span>, sel, (IMP)autoDictionarySetter, <span class=\"string\">\"v@:@\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tclass_addMethod(<span class=\"keyword\">self</span>, sel, (IMP)autoDictionaryGetter, <span class=\"string\">\"@@:\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NCYAutoDictionary *myDic = [[NCYAutoDictionary alloc] init];</span><br><span class=\"line\">myDic.myName = <span class=\"string\">@\"Norcy\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myDic.myName);   <span class=\"comment\">// 打印\"Norcy\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>对于同一个SEL，执行完 <code>resolveInstanceMethod:</code> 后，下次调用该SEL的方法时，就不会再次执行 <code>resolveInstanceMethod:</code>，因为方法已经添加到类中去了（程序运行时都有效）</li>\n<li><p><code>class_addMethod(self, sel, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</code></p>\n<p> 最后一个参数是编码格式，详见<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"noopener\">苹果官方文档</a></p>\n</li>\n<li><p><code>autoDictionarySetter</code>的参数是怎么确定的？</p>\n<p> 因为外部调用的时候其实是 <code>[myDic setMyName:@&quot;Norcy&quot;]</code></p>\n<p> 即 <code>objc_msgSend(myDic, @selector(setMyName:), @&quot;Norcy&quot;)</code></p>\n<p> 经过 <code>resolveInstanceMethod:</code> 替换之后，<code>setMyName:</code> 的消息都会转发给 <code>autoDictionarySetter</code> 来实现</p>\n<p> <code>autoDictionarySetter</code> 是一个 IMP，默认的参数就有2个，id self 和 SEL _cmd，最后一个参数 value 是 <code>setMyName:</code> 带过来的参数，以此确定</p>\n</li>\n</ol>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li>《Effective Objective-C 2.0》第11条和第12条</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objective-C-中函数调用的实质\"><a href=\"#Objective-C-中函数调用的实质\" class=\"headerlink\" title=\"Objective-C 中函数调用的实质\"></a>Objective-C 中函数调用的实质</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> returnValue = [someObj messageName:params];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时转化为</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> returnValue = objc_msgSend(someObj, <span class=\"keyword\">@selector</span>(messageName:), params);</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p>从该接收者所属的类的方法列表中寻找（每次找到都会缓存下，以供下次查找用），找不到就沿着继承树向上搜索，最后还是没找到，就执行消息转发</p>\n<h1 id=\"消息转发分为三大阶段\"><a href=\"#消息转发分为三大阶段\" class=\"headerlink\" title=\"消息转发分为三大阶段\"></a>消息转发分为三大阶段</h1><p>第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做<strong>动态方法解析</strong>（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。</p>\n<p>第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。</p>\n<p>第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/msgSend.png\" alt=\"\"></p>\n<h2 id=\"动态方法解析\"><a href=\"#动态方法解析\" class=\"headerlink\" title=\"动态方法解析\"></a>动态方法解析</h2><p>对象在收到无法响应的消息后，会调用其所属类的下列方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果尚未实现的方法是实例方法，则调用此函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param selector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 返回布尔值，表示是否能新增实例方法用以处理selector</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)selector;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果尚未实现的方法是类方法，则调用此函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param selector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 返回布尔值，表示是否能新增类方法用以处理selector</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)selector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"备援接收者\"><a href=\"#备援接收者\" class=\"headerlink\" title=\"备援接收者\"></a>备援接收者</h2><p>如果无法动态解析方法，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  此方法询问是否能将消息转给其他接收者来处理</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param aSelector 未处理的方法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整的消息转发机制\"><a href=\"#完整的消息转发机制\" class=\"headerlink\" title=\"完整的消息转发机制\"></a>完整的消息转发机制</h2><p>如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  消息派发系统通过此方法，将消息派发给目标对象</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure>\n<h1 id=\"例子：利用消息转发机制实现-dynamic属性\"><a href=\"#例子：利用消息转发机制实现-dynamic属性\" class=\"headerlink\" title=\"例子：利用消息转发机制实现@dynamic属性\"></a>例子：利用消息转发机制实现@dynamic属性</h1><p>.h</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NCYAutoDictionary</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *myName;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NCYAutoDictionary.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> autoDictionaryGetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd);</span><br><span class=\"line\"><span class=\"keyword\">void</span> autoDictionarySetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> value);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NCYAutoDictionary</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> *backingStore;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NCYAutoDictionary</span></span></span><br><span class=\"line\"><span class=\"keyword\">@dynamic</span> myName;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_backingStore = [<span class=\"built_in\">NSMutableDictionary</span> new];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> autoDictionaryGetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)<span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableDictionary</span> *backingStore = typeSelf.backingStore;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *key = <span class=\"built_in\">NSStringFromSelector</span>(_cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> [backingStore objectForKey:key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> autoDictionarySetter(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNCYAutoDictionary *typeSelf = (NCYAutoDictionary *)<span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableDictionary</span> *backingStore = typeSelf.backingStore;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *seletorString = <span class=\"built_in\">NSStringFromSelector</span>(_cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> *key = [seletorString mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将 \"setSomething:\" 转为 \"something\"</span></span><br><span class=\"line\">\t<span class=\"comment\">// remove :</span></span><br><span class=\"line\">\t[key deleteCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(key.length - <span class=\"number\">1</span>, <span class=\"number\">1</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// remove set</span></span><br><span class=\"line\">\t[key deleteCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// lowercase the first character</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *lowercaseFirstChar = [[key substringToIndex:<span class=\"number\">1</span>] lowercaseString];</span><br><span class=\"line\"></span><br><span class=\"line\">\t[key replaceCharactersInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>) withString:lowercaseFirstChar];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (value)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t[backingStore setObject:value forKey:key];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t[backingStore removeObjectForKey:key];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时动态添加方法，对于同一个SEL，执行完该函数后，就不会再次走到这里，因为方法已经添加到类中去了（程序运行时都有效）</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *selectorString = <span class=\"built_in\">NSStringFromSelector</span>(sel);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ([selectorString hasPrefix:<span class=\"string\">@\"set\"</span>])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tclass_addMethod(<span class=\"keyword\">self</span>, sel, (IMP)autoDictionarySetter, <span class=\"string\">\"v@:@\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tclass_addMethod(<span class=\"keyword\">self</span>, sel, (IMP)autoDictionaryGetter, <span class=\"string\">\"@@:\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NCYAutoDictionary *myDic = [[NCYAutoDictionary alloc] init];</span><br><span class=\"line\">myDic.myName = <span class=\"string\">@\"Norcy\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myDic.myName);   <span class=\"comment\">// 打印\"Norcy\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>对于同一个SEL，执行完 <code>resolveInstanceMethod:</code> 后，下次调用该SEL的方法时，就不会再次执行 <code>resolveInstanceMethod:</code>，因为方法已经添加到类中去了（程序运行时都有效）</li>\n<li><p><code>class_addMethod(self, sel, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</code></p>\n<p> 最后一个参数是编码格式，详见<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"noopener\">苹果官方文档</a></p>\n</li>\n<li><p><code>autoDictionarySetter</code>的参数是怎么确定的？</p>\n<p> 因为外部调用的时候其实是 <code>[myDic setMyName:@&quot;Norcy&quot;]</code></p>\n<p> 即 <code>objc_msgSend(myDic, @selector(setMyName:), @&quot;Norcy&quot;)</code></p>\n<p> 经过 <code>resolveInstanceMethod:</code> 替换之后，<code>setMyName:</code> 的消息都会转发给 <code>autoDictionarySetter</code> 来实现</p>\n<p> <code>autoDictionarySetter</code> 是一个 IMP，默认的参数就有2个，id self 和 SEL _cmd，最后一个参数 value 是 <code>setMyName:</code> 带过来的参数，以此确定</p>\n</li>\n</ol>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li>《Effective Objective-C 2.0》第11条和第12条</li>\n</ul>\n","sticky":0},{"title":"UITableView 中，UICollectionView 相互复用之间 contentOffset","date":"2016-03-27T16:00:00.000Z","photos":["images/view.jpg"],"keywords":"UITableView;UITableViewCell;UICollectionView;contentOffset;复用;reuse","_content":"\n# 问题描述\nUIViewController 中有一个 UITableView，UITableViewCell 的 contentView 上添加了横滑列表，横滑列表是用 UICollectionView 实现的。\n如下图所示\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset1.png)\n\n抽象出来就是这样\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset2.png)\n\n\n其中 UITableView 的 DataSource/Delegate 是 Controller，而 UICollectionView 的 DataSource/Delegate 是 UITableViewCell。\nUITableView 的 DataSource 抽象如下：\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath \n\t{\n\t\tJceObject *cellObj = [_dataModel.aryItems objectAtIndex:indexPath.row];\n\t\tUITableViewCell *cell = [QLThumbsMgr makeCellWithJCEPoster:cellObj tableView:tableView userInfo:self];\n\t\treturn cell;\n\t}\n\n好像看似没什么问题是吧，UITableView 的使用一向都是这样的嘛。可是当 UITableViewCell 碰上了 UICollectionView，问题就出来了。\n左右滑动一个 UICollectionView 使其 contentOffset 不为初始值，再上下滑动 UITableView，你会发现，其他的横滑列表也被横滑了，上个动图直观感受一下\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset3.gif)\n\n# 问题分析\n如果对于 UITableView 的 Cell 复用机制有一定了解的同学一定很容易看出问题，就是因为 Cell 之间的复用导致了 UICollectionView 的 contentOffset 也被复用了。\n\n那么之前我们是如何解决 UITableViewCell 的复用问题呢？就是每次 Cell 出现的时候，就根据数据源更新 Cell 的内容，这样就保证了每次看到的 Cell 是正确的。\n\n但是现在棘手的是数据源中并没有包含 UICollectionView 的 contentOffset。\n\n问题可以转化为如何在 UITableViewCell 出现的时候，更新其 UICollectionView 的 contentOffset。依赖 UITableViewCell 去记住是行不通的，因为它自己就是被复用的对象，那么就要外部去帮它记住，这个外部可以是 UITableView 的 Delegate——UIViewController，也可以 UITableViewCell 的数据源。\n\n如果是数据源，则需要对数据源做一个扩展 or 分类，由于数据源与前后台协议是相关的，改动数据源或许不是一个好的选择。所以这里我选择了让 UIViewController 去完成这个记忆的任务。\n\n# 解决方法\n我们可以为 UIViewController 添加一个 NSMutableDictionary 类型的实例变量，该字典存储的是 UITableViewCell 的位置和其 UICollectionView 的横滑位置的映射关系。\n\n+ UITableViewCell 即将从视野里消失的时候，UIViewController 用 NSMutableDictionary 记录该 Cell 的 indexPath.row 和其 UICollectionView 的 contentOffset；（这里只讨论 UITableView 只有一个 section 的情况，多个 section 的处理原理是一样的）\n\n+ UITableViewCell 即将出现在视野里的时候，UIViewController 根据该 Cell 的 indexPath.row，从 NSMutableDictionary 中读取相应的值去设置该 Cell 上的 UICollectionView 的 contentOffset；\n\nUIViewController 是 UITableView 的 Delegate，UITableViewCell 的出现和消失事件可以在以下2个代理方法中捕捉到。\n`- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;`\n和\n`- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;`\n\n那么，UIViewController 中的代码应该类似这样。\n\n\n\t- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n\t    if ([cell isKindOfClass:[QLONAListCell class]])\n\t\t{\n\t        QLONAListCell *listCell = (QLONAListCell *)cell;\n\t        NSInteger row = indexPath.row;\n\t        CGFloat horizontalOffset;\n\t        horizontalOffset = [self.contentOffsetDict[[@(row) stringValue]] floatValue];\n\t        [listCell.horizontalScrollView setContentOffset:CGPointMake(horizontalOffset, 0)];\n\t    }\n\t}\n\t\n\t- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n\t    if ([cell isKindOfClass:[QLONAListCell class]])\n\t    {\n\t        QLONAListCell *listCell = (QLONAListCell *)cell;\n\t        NSInteger row = indexPath.row;\n\t        CGFloat horizontalOffset = listCell.horizontalScrollView.contentOffset.x;\n\t        self.contentOffsetDict[[@(row) stringValue]] = @(horizontalOffset);\n\t    }\n\t}\n\n其中 QLONAListCell 是 UITableViewCell 的子类，它有一个 UICollectionView 类型的属性 horizontalScrollView。\ncontentOffsetDict 是 UIViewController 的实例变量，它是一个 NSMutableDictionary。\n\n哦，还有一个注意点。当对 UITableView 进行下拉刷新的时候，新数据可能与老数据不一样（比如多了某个 Cell 或少了某个 Cell），那么这种情况下，contentOffsetDict 的记录就不再正确，所以每次在数据请求回来的时候，最好清空一下 contentOffsetDict。这样做的后果就是每次下拉刷新就会清空横滑列表的 contentOffset，不过看起来也似乎合情合理。\n\n# 参考链接\n[Putting a UICollectionView in a UITableViewCell](https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/)","source":"_posts/UITableView 中，UICollectionView 相互复用之间 contentOffset.md","raw":"---\ntitle: UITableView 中，UICollectionView 相互复用之间 contentOffset\ndate: 2016-03-28\ncategories:\n- iOS\nphotos: images/view.jpg\nkeywords: UITableView;UITableViewCell;UICollectionView;contentOffset;复用;reuse\n---\n\n# 问题描述\nUIViewController 中有一个 UITableView，UITableViewCell 的 contentView 上添加了横滑列表，横滑列表是用 UICollectionView 实现的。\n如下图所示\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset1.png)\n\n抽象出来就是这样\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset2.png)\n\n\n其中 UITableView 的 DataSource/Delegate 是 Controller，而 UICollectionView 的 DataSource/Delegate 是 UITableViewCell。\nUITableView 的 DataSource 抽象如下：\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath \n\t{\n\t\tJceObject *cellObj = [_dataModel.aryItems objectAtIndex:indexPath.row];\n\t\tUITableViewCell *cell = [QLThumbsMgr makeCellWithJCEPoster:cellObj tableView:tableView userInfo:self];\n\t\treturn cell;\n\t}\n\n好像看似没什么问题是吧，UITableView 的使用一向都是这样的嘛。可是当 UITableViewCell 碰上了 UICollectionView，问题就出来了。\n左右滑动一个 UICollectionView 使其 contentOffset 不为初始值，再上下滑动 UITableView，你会发现，其他的横滑列表也被横滑了，上个动图直观感受一下\n\n![](http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset3.gif)\n\n# 问题分析\n如果对于 UITableView 的 Cell 复用机制有一定了解的同学一定很容易看出问题，就是因为 Cell 之间的复用导致了 UICollectionView 的 contentOffset 也被复用了。\n\n那么之前我们是如何解决 UITableViewCell 的复用问题呢？就是每次 Cell 出现的时候，就根据数据源更新 Cell 的内容，这样就保证了每次看到的 Cell 是正确的。\n\n但是现在棘手的是数据源中并没有包含 UICollectionView 的 contentOffset。\n\n问题可以转化为如何在 UITableViewCell 出现的时候，更新其 UICollectionView 的 contentOffset。依赖 UITableViewCell 去记住是行不通的，因为它自己就是被复用的对象，那么就要外部去帮它记住，这个外部可以是 UITableView 的 Delegate——UIViewController，也可以 UITableViewCell 的数据源。\n\n如果是数据源，则需要对数据源做一个扩展 or 分类，由于数据源与前后台协议是相关的，改动数据源或许不是一个好的选择。所以这里我选择了让 UIViewController 去完成这个记忆的任务。\n\n# 解决方法\n我们可以为 UIViewController 添加一个 NSMutableDictionary 类型的实例变量，该字典存储的是 UITableViewCell 的位置和其 UICollectionView 的横滑位置的映射关系。\n\n+ UITableViewCell 即将从视野里消失的时候，UIViewController 用 NSMutableDictionary 记录该 Cell 的 indexPath.row 和其 UICollectionView 的 contentOffset；（这里只讨论 UITableView 只有一个 section 的情况，多个 section 的处理原理是一样的）\n\n+ UITableViewCell 即将出现在视野里的时候，UIViewController 根据该 Cell 的 indexPath.row，从 NSMutableDictionary 中读取相应的值去设置该 Cell 上的 UICollectionView 的 contentOffset；\n\nUIViewController 是 UITableView 的 Delegate，UITableViewCell 的出现和消失事件可以在以下2个代理方法中捕捉到。\n`- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;`\n和\n`- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;`\n\n那么，UIViewController 中的代码应该类似这样。\n\n\n\t- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n\t    if ([cell isKindOfClass:[QLONAListCell class]])\n\t\t{\n\t        QLONAListCell *listCell = (QLONAListCell *)cell;\n\t        NSInteger row = indexPath.row;\n\t        CGFloat horizontalOffset;\n\t        horizontalOffset = [self.contentOffsetDict[[@(row) stringValue]] floatValue];\n\t        [listCell.horizontalScrollView setContentOffset:CGPointMake(horizontalOffset, 0)];\n\t    }\n\t}\n\t\n\t- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n\t{\n\t    if ([cell isKindOfClass:[QLONAListCell class]])\n\t    {\n\t        QLONAListCell *listCell = (QLONAListCell *)cell;\n\t        NSInteger row = indexPath.row;\n\t        CGFloat horizontalOffset = listCell.horizontalScrollView.contentOffset.x;\n\t        self.contentOffsetDict[[@(row) stringValue]] = @(horizontalOffset);\n\t    }\n\t}\n\n其中 QLONAListCell 是 UITableViewCell 的子类，它有一个 UICollectionView 类型的属性 horizontalScrollView。\ncontentOffsetDict 是 UIViewController 的实例变量，它是一个 NSMutableDictionary。\n\n哦，还有一个注意点。当对 UITableView 进行下拉刷新的时候，新数据可能与老数据不一样（比如多了某个 Cell 或少了某个 Cell），那么这种情况下，contentOffsetDict 的记录就不再正确，所以每次在数据请求回来的时候，最好清空一下 contentOffsetDict。这样做的后果就是每次下拉刷新就会清空横滑列表的 contentOffset，不过看起来也似乎合情合理。\n\n# 参考链接\n[Putting a UICollectionView in a UITableViewCell](https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/)","slug":"UITableView 中，UICollectionView 相互复用之间 contentOffset","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","link":"","_id":"cje87q098000btjqw3s0xrq9m","content":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>UIViewController 中有一个 UITableView，UITableViewCell 的 contentView 上添加了横滑列表，横滑列表是用 UICollectionView 实现的。<br>如下图所示</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset1.png\" alt=\"\"></p>\n<p>抽象出来就是这样</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset2.png\" alt=\"\"></p>\n<p>其中 UITableView 的 DataSource/Delegate 是 Controller，而 UICollectionView 的 DataSource/Delegate 是 UITableViewCell。<br>UITableView 的 DataSource 抽象如下：</p>\n<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath \n{\n    JceObject *cellObj = [_dataModel.aryItems objectAtIndex:indexPath.row];\n    UITableViewCell *cell = [QLThumbsMgr makeCellWithJCEPoster:cellObj tableView:tableView userInfo:self];\n    return cell;\n}\n</code></pre><p>好像看似没什么问题是吧，UITableView 的使用一向都是这样的嘛。可是当 UITableViewCell 碰上了 UICollectionView，问题就出来了。<br>左右滑动一个 UICollectionView 使其 contentOffset 不为初始值，再上下滑动 UITableView，你会发现，其他的横滑列表也被横滑了，上个动图直观感受一下</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset3.gif\" alt=\"\"></p>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>如果对于 UITableView 的 Cell 复用机制有一定了解的同学一定很容易看出问题，就是因为 Cell 之间的复用导致了 UICollectionView 的 contentOffset 也被复用了。</p>\n<p>那么之前我们是如何解决 UITableViewCell 的复用问题呢？就是每次 Cell 出现的时候，就根据数据源更新 Cell 的内容，这样就保证了每次看到的 Cell 是正确的。</p>\n<p>但是现在棘手的是数据源中并没有包含 UICollectionView 的 contentOffset。</p>\n<p>问题可以转化为如何在 UITableViewCell 出现的时候，更新其 UICollectionView 的 contentOffset。依赖 UITableViewCell 去记住是行不通的，因为它自己就是被复用的对象，那么就要外部去帮它记住，这个外部可以是 UITableView 的 Delegate——UIViewController，也可以 UITableViewCell 的数据源。</p>\n<p>如果是数据源，则需要对数据源做一个扩展 or 分类，由于数据源与前后台协议是相关的，改动数据源或许不是一个好的选择。所以这里我选择了让 UIViewController 去完成这个记忆的任务。</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>我们可以为 UIViewController 添加一个 NSMutableDictionary 类型的实例变量，该字典存储的是 UITableViewCell 的位置和其 UICollectionView 的横滑位置的映射关系。</p>\n<ul>\n<li><p>UITableViewCell 即将从视野里消失的时候，UIViewController 用 NSMutableDictionary 记录该 Cell 的 indexPath.row 和其 UICollectionView 的 contentOffset；（这里只讨论 UITableView 只有一个 section 的情况，多个 section 的处理原理是一样的）</p>\n</li>\n<li><p>UITableViewCell 即将出现在视野里的时候，UIViewController 根据该 Cell 的 indexPath.row，从 NSMutableDictionary 中读取相应的值去设置该 Cell 上的 UICollectionView 的 contentOffset；</p>\n</li>\n</ul>\n<p>UIViewController 是 UITableView 的 Delegate，UITableViewCell 的出现和消失事件可以在以下2个代理方法中捕捉到。<br><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</code><br>和<br><code>- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;</code></p>\n<p>那么，UIViewController 中的代码应该类似这样。</p>\n<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    if ([cell isKindOfClass:[QLONAListCell class]])\n    {\n        QLONAListCell *listCell = (QLONAListCell *)cell;\n        NSInteger row = indexPath.row;\n        CGFloat horizontalOffset;\n        horizontalOffset = [self.contentOffsetDict[[@(row) stringValue]] floatValue];\n        [listCell.horizontalScrollView setContentOffset:CGPointMake(horizontalOffset, 0)];\n    }\n}\n\n- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    if ([cell isKindOfClass:[QLONAListCell class]])\n    {\n        QLONAListCell *listCell = (QLONAListCell *)cell;\n        NSInteger row = indexPath.row;\n        CGFloat horizontalOffset = listCell.horizontalScrollView.contentOffset.x;\n        self.contentOffsetDict[[@(row) stringValue]] = @(horizontalOffset);\n    }\n}\n</code></pre><p>其中 QLONAListCell 是 UITableViewCell 的子类，它有一个 UICollectionView 类型的属性 horizontalScrollView。<br>contentOffsetDict 是 UIViewController 的实例变量，它是一个 NSMutableDictionary。</p>\n<p>哦，还有一个注意点。当对 UITableView 进行下拉刷新的时候，新数据可能与老数据不一样（比如多了某个 Cell 或少了某个 Cell），那么这种情况下，contentOffsetDict 的记录就不再正确，所以每次在数据请求回来的时候，最好清空一下 contentOffsetDict。这样做的后果就是每次下拉刷新就会清空横滑列表的 contentOffset，不过看起来也似乎合情合理。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/\" target=\"_blank\" rel=\"noopener\">Putting a UICollectionView in a UITableViewCell</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>UIViewController 中有一个 UITableView，UITableViewCell 的 contentView 上添加了横滑列表，横滑列表是用 UICollectionView 实现的。<br>如下图所示</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset1.png\" alt=\"\"></p>\n<p>抽象出来就是这样</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset2.png\" alt=\"\"></p>\n<p>其中 UITableView 的 DataSource/Delegate 是 Controller，而 UICollectionView 的 DataSource/Delegate 是 UITableViewCell。<br>UITableView 的 DataSource 抽象如下：</p>\n<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath \n{\n    JceObject *cellObj = [_dataModel.aryItems objectAtIndex:indexPath.row];\n    UITableViewCell *cell = [QLThumbsMgr makeCellWithJCEPoster:cellObj tableView:tableView userInfo:self];\n    return cell;\n}\n</code></pre><p>好像看似没什么问题是吧，UITableView 的使用一向都是这样的嘛。可是当 UITableViewCell 碰上了 UICollectionView，问题就出来了。<br>左右滑动一个 UICollectionView 使其 contentOffset 不为初始值，再上下滑动 UITableView，你会发现，其他的横滑列表也被横滑了，上个动图直观感受一下</p>\n<p><img src=\"http://7xsd8c.com1.z0.glb.clouddn.com/contentOffset3.gif\" alt=\"\"></p>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>如果对于 UITableView 的 Cell 复用机制有一定了解的同学一定很容易看出问题，就是因为 Cell 之间的复用导致了 UICollectionView 的 contentOffset 也被复用了。</p>\n<p>那么之前我们是如何解决 UITableViewCell 的复用问题呢？就是每次 Cell 出现的时候，就根据数据源更新 Cell 的内容，这样就保证了每次看到的 Cell 是正确的。</p>\n<p>但是现在棘手的是数据源中并没有包含 UICollectionView 的 contentOffset。</p>\n<p>问题可以转化为如何在 UITableViewCell 出现的时候，更新其 UICollectionView 的 contentOffset。依赖 UITableViewCell 去记住是行不通的，因为它自己就是被复用的对象，那么就要外部去帮它记住，这个外部可以是 UITableView 的 Delegate——UIViewController，也可以 UITableViewCell 的数据源。</p>\n<p>如果是数据源，则需要对数据源做一个扩展 or 分类，由于数据源与前后台协议是相关的，改动数据源或许不是一个好的选择。所以这里我选择了让 UIViewController 去完成这个记忆的任务。</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>我们可以为 UIViewController 添加一个 NSMutableDictionary 类型的实例变量，该字典存储的是 UITableViewCell 的位置和其 UICollectionView 的横滑位置的映射关系。</p>\n<ul>\n<li><p>UITableViewCell 即将从视野里消失的时候，UIViewController 用 NSMutableDictionary 记录该 Cell 的 indexPath.row 和其 UICollectionView 的 contentOffset；（这里只讨论 UITableView 只有一个 section 的情况，多个 section 的处理原理是一样的）</p>\n</li>\n<li><p>UITableViewCell 即将出现在视野里的时候，UIViewController 根据该 Cell 的 indexPath.row，从 NSMutableDictionary 中读取相应的值去设置该 Cell 上的 UICollectionView 的 contentOffset；</p>\n</li>\n</ul>\n<p>UIViewController 是 UITableView 的 Delegate，UITableViewCell 的出现和消失事件可以在以下2个代理方法中捕捉到。<br><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</code><br>和<br><code>- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;</code></p>\n<p>那么，UIViewController 中的代码应该类似这样。</p>\n<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    if ([cell isKindOfClass:[QLONAListCell class]])\n    {\n        QLONAListCell *listCell = (QLONAListCell *)cell;\n        NSInteger row = indexPath.row;\n        CGFloat horizontalOffset;\n        horizontalOffset = [self.contentOffsetDict[[@(row) stringValue]] floatValue];\n        [listCell.horizontalScrollView setContentOffset:CGPointMake(horizontalOffset, 0)];\n    }\n}\n\n- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    if ([cell isKindOfClass:[QLONAListCell class]])\n    {\n        QLONAListCell *listCell = (QLONAListCell *)cell;\n        NSInteger row = indexPath.row;\n        CGFloat horizontalOffset = listCell.horizontalScrollView.contentOffset.x;\n        self.contentOffsetDict[[@(row) stringValue]] = @(horizontalOffset);\n    }\n}\n</code></pre><p>其中 QLONAListCell 是 UITableViewCell 的子类，它有一个 UICollectionView 类型的属性 horizontalScrollView。<br>contentOffsetDict 是 UIViewController 的实例变量，它是一个 NSMutableDictionary。</p>\n<p>哦，还有一个注意点。当对 UITableView 进行下拉刷新的时候，新数据可能与老数据不一样（比如多了某个 Cell 或少了某个 Cell），那么这种情况下，contentOffsetDict 的记录就不再正确，所以每次在数据请求回来的时候，最好清空一下 contentOffsetDict。这样做的后果就是每次下拉刷新就会清空横滑列表的 contentOffset，不过看起来也似乎合情合理。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/\" target=\"_blank\" rel=\"noopener\">Putting a UICollectionView in a UITableViewCell</a></p>\n","sticky":0},{"title":"iOS 技能树","date":"2016-02-17T16:00:00.000Z","description":"iOSの修行 技能树","photos":["images/girl2.jpg"],"keywords":null,"_content":"\n# Objective-C\n\tRunLoop\n\tRuntime\n\t多线程\n\t\tNSThread\n\t\tNSOperation\n\t\tGCD\n\t\t\t线程同步\n\t\t\t线程间通信\n\tProperty\n\n# iOS\n\tUI\n\t\tUILabel\n\t网络通信\n\t\tASIHTTPRequest\n\t\tAFNETworking\n\t\tNSURLConnection\n\t存储\n\t\tCore Data\n\t推送\n\t\tRemoteNotification(APNS)\n\t\tUILocalNotification\n\t动画\n\t3D Touch\n\tSwift\n\n# 工具\n\tCocoaPods\n\n# 发布\n\t苹果证书\n\n# 函数式响应编程\n\tReactive Cocoa\n\n# 架构\n\tMVC\n\tMVVM\n\n# 版本控制\n\tGit\n\tSVN\n\n# 设计模式\n\t\n# 资源\n\t[WWDC](https://developer.apple.com/videos/wwdc2015/)\n\t[Objc中国](http://objccn.io/)\n\t开源框架\n\t\tMBProcessHUD\n\t\tSDWebImage\n\t开放平台\n\t\t分享（微信，QQ，微博）\n\t\t支付（微信，支付宝）\n","source":"_posts/iOS技能树.md","raw":"---\ntitle: iOS 技能树\ndate: 2016-2-18\ndescription: iOSの修行 技能树\ncategories:\n- Others\nphotos: images/girl2.jpg\nkeywords:\n---\n\n# Objective-C\n\tRunLoop\n\tRuntime\n\t多线程\n\t\tNSThread\n\t\tNSOperation\n\t\tGCD\n\t\t\t线程同步\n\t\t\t线程间通信\n\tProperty\n\n# iOS\n\tUI\n\t\tUILabel\n\t网络通信\n\t\tASIHTTPRequest\n\t\tAFNETworking\n\t\tNSURLConnection\n\t存储\n\t\tCore Data\n\t推送\n\t\tRemoteNotification(APNS)\n\t\tUILocalNotification\n\t动画\n\t3D Touch\n\tSwift\n\n# 工具\n\tCocoaPods\n\n# 发布\n\t苹果证书\n\n# 函数式响应编程\n\tReactive Cocoa\n\n# 架构\n\tMVC\n\tMVVM\n\n# 版本控制\n\tGit\n\tSVN\n\n# 设计模式\n\t\n# 资源\n\t[WWDC](https://developer.apple.com/videos/wwdc2015/)\n\t[Objc中国](http://objccn.io/)\n\t开源框架\n\t\tMBProcessHUD\n\t\tSDWebImage\n\t开放平台\n\t\t分享（微信，QQ，微博）\n\t\t支付（微信，支付宝）\n","slug":"iOS技能树","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","link":"","_id":"cje87q099000etjqw9dnr3yrm","content":"<h1 id=\"Objective-C\"><a href=\"#Objective-C\" class=\"headerlink\" title=\"Objective-C\"></a>Objective-C</h1><pre><code>RunLoop\nRuntime\n多线程\n    NSThread\n    NSOperation\n    GCD\n        线程同步\n        线程间通信\nProperty\n</code></pre><h1 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h1><pre><code>UI\n    UILabel\n网络通信\n    ASIHTTPRequest\n    AFNETworking\n    NSURLConnection\n存储\n    Core Data\n推送\n    RemoteNotification(APNS)\n    UILocalNotification\n动画\n3D Touch\nSwift\n</code></pre><h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><pre><code>CocoaPods\n</code></pre><h1 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h1><pre><code>苹果证书\n</code></pre><h1 id=\"函数式响应编程\"><a href=\"#函数式响应编程\" class=\"headerlink\" title=\"函数式响应编程\"></a>函数式响应编程</h1><pre><code>Reactive Cocoa\n</code></pre><h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><pre><code>MVC\nMVVM\n</code></pre><h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><pre><code>Git\nSVN\n</code></pre><h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><pre><code>[WWDC](https://developer.apple.com/videos/wwdc2015/)\n[Objc中国](http://objccn.io/)\n开源框架\n    MBProcessHUD\n    SDWebImage\n开放平台\n    分享（微信，QQ，微博）\n    支付（微信，支付宝）\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objective-C\"><a href=\"#Objective-C\" class=\"headerlink\" title=\"Objective-C\"></a>Objective-C</h1><pre><code>RunLoop\nRuntime\n多线程\n    NSThread\n    NSOperation\n    GCD\n        线程同步\n        线程间通信\nProperty\n</code></pre><h1 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h1><pre><code>UI\n    UILabel\n网络通信\n    ASIHTTPRequest\n    AFNETworking\n    NSURLConnection\n存储\n    Core Data\n推送\n    RemoteNotification(APNS)\n    UILocalNotification\n动画\n3D Touch\nSwift\n</code></pre><h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><pre><code>CocoaPods\n</code></pre><h1 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h1><pre><code>苹果证书\n</code></pre><h1 id=\"函数式响应编程\"><a href=\"#函数式响应编程\" class=\"headerlink\" title=\"函数式响应编程\"></a>函数式响应编程</h1><pre><code>Reactive Cocoa\n</code></pre><h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><pre><code>MVC\nMVVM\n</code></pre><h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><pre><code>Git\nSVN\n</code></pre><h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><pre><code>[WWDC](https://developer.apple.com/videos/wwdc2015/)\n[Objc中国](http://objccn.io/)\n开源框架\n    MBProcessHUD\n    SDWebImage\n开放平台\n    分享（微信，QQ，微博）\n    支付（微信，支付宝）\n</code></pre>","sticky":0},{"title":"iOS的单例模式与多线程安全","date":"2017-04-04T16:00:00.000Z","photos":[],"keywords":"iOS;单例模式;多线程安全;dispatch_once;","_content":"\n# 版本1\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        sharedInstance = [[self alloc] init];\n    }\n    return sharedInstance;\n}\n```\n\n版本1采用 static 变量方法，先判断实例是否已初始化，如果已初始化则直接返回，否则创建实例\n\n缺点是多线程下不安全。如果多个线程同时访问 sharedInstance，可能会有多个线程同时通过`(sharedInstance == nil)`的条件检查，于是，多个实例就创建出来\n\n# 版本2\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        @synchronized (self) \n        {\n            sharedInstance = [[self alloc] init];\n        }\n    }\n    return sharedInstance;\n}\n```\n\n为了线程互斥，那么版本2在版本1的基础上添加 @synchronized\n\n多线程的安全问题得到解决了吗？没有。依然可能有多个线程同时通过非空检查，现在它们变成按顺序地创建了多个实例\n\n# 版本3\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    @synchronized (self)\n    {\n        if (sharedInstance == nil)\n        {\n            sharedInstance = [[self alloc] init];\n        }\n    }\n    return sharedInstance;\n}\n```\n\n在版本2的基础上，只要把非空检查也放到 @synchronized 里面，那么就不会出现多个线程同时通过非空检查了，所以多线程的安全问题就得到解决了。\n\n但是现在每次访问 sharedInstance，无论单例是否已经初始化完毕，都要对 self 加锁，是非常浪费的\n\n# 版本4\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        @synchronized (self)\n        {\n            if (sharedInstance == nil)\n            {\n                sharedInstance = [[self alloc] init];\n            }\n        }\n    }\n    return sharedInstance;\n}\n```\n\n版本4是版本3的升级版本，称为“Double Check”。\n\n1. 如果单例已创建，则直接返回，不需要加锁；\n2. 如果单例没创建，则加锁\n3. 加锁后，只能有一个线程通过非空检查，创建单例\n\n很完美，但是写起来有点复杂\n\n# 终极版本\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n```\n\n使用 dispatch_once，秒杀以上方案，更快更安全\n\nTips：把上述代码保存到代码片段，直接丢到任何类里面都适用\n\n# 由单例模式引发的多线程安全的思考\n## static bool 的判断在多线程下不安全\n\n```objc\nstatic bool hasDone = NO;\nif (!hasDone)\n{\n    // do something\n    hasDone = YES;\n}\n// do something\n```\n\n以上写法不安全，有可能多个线程同时通过非空检查，导致 if 体内的代码执行多次\n\n如果一段代码是在 App 声明周期内只执行一次，则推荐使用 `dispatch_once`；其他的情况要具体分析\n\n## 懒加载在多线程下不安全\n\n```objc\n- (NSArray *)myArray\n{\n    if (_myArray)\n    {\n        _myArray = [[NSArray alloc] init];\n    }\n    return _myArray;\n}\n```\n\n这种判断在多线程下不安全的。所以多线程下尽量别使用懒加载，即使使用，也要加相应的保护，比如在 `_myArray` 不会被重新置为 nil 的前提下可以使用 `dispatch_once`","source":"_posts/iOS的单例模式与多线程安全.md","raw":"---\ntitle: iOS的单例模式与多线程安全\ndate: 2017-04-05\ncategories:\n- iOS\nphotos: \nkeywords: iOS;单例模式;多线程安全;dispatch_once;\n---\n\n# 版本1\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        sharedInstance = [[self alloc] init];\n    }\n    return sharedInstance;\n}\n```\n\n版本1采用 static 变量方法，先判断实例是否已初始化，如果已初始化则直接返回，否则创建实例\n\n缺点是多线程下不安全。如果多个线程同时访问 sharedInstance，可能会有多个线程同时通过`(sharedInstance == nil)`的条件检查，于是，多个实例就创建出来\n\n# 版本2\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        @synchronized (self) \n        {\n            sharedInstance = [[self alloc] init];\n        }\n    }\n    return sharedInstance;\n}\n```\n\n为了线程互斥，那么版本2在版本1的基础上添加 @synchronized\n\n多线程的安全问题得到解决了吗？没有。依然可能有多个线程同时通过非空检查，现在它们变成按顺序地创建了多个实例\n\n# 版本3\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    @synchronized (self)\n    {\n        if (sharedInstance == nil)\n        {\n            sharedInstance = [[self alloc] init];\n        }\n    }\n    return sharedInstance;\n}\n```\n\n在版本2的基础上，只要把非空检查也放到 @synchronized 里面，那么就不会出现多个线程同时通过非空检查了，所以多线程的安全问题就得到解决了。\n\n但是现在每次访问 sharedInstance，无论单例是否已经初始化完毕，都要对 self 加锁，是非常浪费的\n\n# 版本4\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    if (sharedInstance == nil)\n    {\n        @synchronized (self)\n        {\n            if (sharedInstance == nil)\n            {\n                sharedInstance = [[self alloc] init];\n            }\n        }\n    }\n    return sharedInstance;\n}\n```\n\n版本4是版本3的升级版本，称为“Double Check”。\n\n1. 如果单例已创建，则直接返回，不需要加锁；\n2. 如果单例没创建，则加锁\n3. 加锁后，只能有一个线程通过非空检查，创建单例\n\n很完美，但是写起来有点复杂\n\n# 终极版本\n\n```objc\n+ (instancetype)sharedInstance\n{\n    static id sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n```\n\n使用 dispatch_once，秒杀以上方案，更快更安全\n\nTips：把上述代码保存到代码片段，直接丢到任何类里面都适用\n\n# 由单例模式引发的多线程安全的思考\n## static bool 的判断在多线程下不安全\n\n```objc\nstatic bool hasDone = NO;\nif (!hasDone)\n{\n    // do something\n    hasDone = YES;\n}\n// do something\n```\n\n以上写法不安全，有可能多个线程同时通过非空检查，导致 if 体内的代码执行多次\n\n如果一段代码是在 App 声明周期内只执行一次，则推荐使用 `dispatch_once`；其他的情况要具体分析\n\n## 懒加载在多线程下不安全\n\n```objc\n- (NSArray *)myArray\n{\n    if (_myArray)\n    {\n        _myArray = [[NSArray alloc] init];\n    }\n    return _myArray;\n}\n```\n\n这种判断在多线程下不安全的。所以多线程下尽量别使用懒加载，即使使用，也要加相应的保护，比如在 `_myArray` 不会被重新置为 nil 的前提下可以使用 `dispatch_once`","slug":"iOS的单例模式与多线程安全","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","link":"","_id":"cje87q09a000ftjqwv8lxitbk","content":"<h1 id=\"版本1\"><a href=\"#版本1\" class=\"headerlink\" title=\"版本1\"></a>版本1</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>版本1采用 static 变量方法，先判断实例是否已初始化，如果已初始化则直接返回，否则创建实例</p>\n<p>缺点是多线程下不安全。如果多个线程同时访问 sharedInstance，可能会有多个线程同时通过<code>(sharedInstance == nil)</code>的条件检查，于是，多个实例就创建出来</p>\n<h1 id=\"版本2\"><a href=\"#版本2\" class=\"headerlink\" title=\"版本2\"></a>版本2</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了线程互斥，那么版本2在版本1的基础上添加 @synchronized</p>\n<p>多线程的安全问题得到解决了吗？没有。依然可能有多个线程同时通过非空检查，现在它们变成按顺序地创建了多个实例</p>\n<h1 id=\"版本3\"><a href=\"#版本3\" class=\"headerlink\" title=\"版本3\"></a>版本3</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在版本2的基础上，只要把非空检查也放到 @synchronized 里面，那么就不会出现多个线程同时通过非空检查了，所以多线程的安全问题就得到解决了。</p>\n<p>但是现在每次访问 sharedInstance，无论单例是否已经初始化完毕，都要对 self 加锁，是非常浪费的</p>\n<h1 id=\"版本4\"><a href=\"#版本4\" class=\"headerlink\" title=\"版本4\"></a>版本4</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>版本4是版本3的升级版本，称为“Double Check”。</p>\n<ol>\n<li>如果单例已创建，则直接返回，不需要加锁；</li>\n<li>如果单例没创建，则加锁</li>\n<li>加锁后，只能有一个线程通过非空检查，创建单例</li>\n</ol>\n<p>很完美，但是写起来有点复杂</p>\n<h1 id=\"终极版本\"><a href=\"#终极版本\" class=\"headerlink\" title=\"终极版本\"></a>终极版本</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_once，秒杀以上方案，更快更安全</p>\n<p>Tips：把上述代码保存到代码片段，直接丢到任何类里面都适用</p>\n<h1 id=\"由单例模式引发的多线程安全的思考\"><a href=\"#由单例模式引发的多线程安全的思考\" class=\"headerlink\" title=\"由单例模式引发的多线程安全的思考\"></a>由单例模式引发的多线程安全的思考</h1><h2 id=\"static-bool-的判断在多线程下不安全\"><a href=\"#static-bool-的判断在多线程下不安全\" class=\"headerlink\" title=\"static bool 的判断在多线程下不安全\"></a>static bool 的判断在多线程下不安全</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> hasDone = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!hasDone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    hasDone = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// do something</span></span><br></pre></td></tr></table></figure>\n<p>以上写法不安全，有可能多个线程同时通过非空检查，导致 if 体内的代码执行多次</p>\n<p>如果一段代码是在 App 声明周期内只执行一次，则推荐使用 <code>dispatch_once</code>；其他的情况要具体分析</p>\n<h2 id=\"懒加载在多线程下不安全\"><a href=\"#懒加载在多线程下不安全\" class=\"headerlink\" title=\"懒加载在多线程下不安全\"></a>懒加载在多线程下不安全</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)myArray</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_myArray)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _myArray = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _myArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种判断在多线程下不安全的。所以多线程下尽量别使用懒加载，即使使用，也要加相应的保护，比如在 <code>_myArray</code> 不会被重新置为 nil 的前提下可以使用 <code>dispatch_once</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"版本1\"><a href=\"#版本1\" class=\"headerlink\" title=\"版本1\"></a>版本1</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>版本1采用 static 变量方法，先判断实例是否已初始化，如果已初始化则直接返回，否则创建实例</p>\n<p>缺点是多线程下不安全。如果多个线程同时访问 sharedInstance，可能会有多个线程同时通过<code>(sharedInstance == nil)</code>的条件检查，于是，多个实例就创建出来</p>\n<h1 id=\"版本2\"><a href=\"#版本2\" class=\"headerlink\" title=\"版本2\"></a>版本2</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了线程互斥，那么版本2在版本1的基础上添加 @synchronized</p>\n<p>多线程的安全问题得到解决了吗？没有。依然可能有多个线程同时通过非空检查，现在它们变成按顺序地创建了多个实例</p>\n<h1 id=\"版本3\"><a href=\"#版本3\" class=\"headerlink\" title=\"版本3\"></a>版本3</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在版本2的基础上，只要把非空检查也放到 @synchronized 里面，那么就不会出现多个线程同时通过非空检查了，所以多线程的安全问题就得到解决了。</p>\n<p>但是现在每次访问 sharedInstance，无论单例是否已经初始化完毕，都要对 self 加锁，是非常浪费的</p>\n<h1 id=\"版本4\"><a href=\"#版本4\" class=\"headerlink\" title=\"版本4\"></a>版本4</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@synchronized</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sharedInstance == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>版本4是版本3的升级版本，称为“Double Check”。</p>\n<ol>\n<li>如果单例已创建，则直接返回，不需要加锁；</li>\n<li>如果单例没创建，则加锁</li>\n<li>加锁后，只能有一个线程通过非空检查，创建单例</li>\n</ol>\n<p>很完美，但是写起来有点复杂</p>\n<h1 id=\"终极版本\"><a href=\"#终极版本\" class=\"headerlink\" title=\"终极版本\"></a>终极版本</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">id</span> sharedInstance = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sharedInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_once，秒杀以上方案，更快更安全</p>\n<p>Tips：把上述代码保存到代码片段，直接丢到任何类里面都适用</p>\n<h1 id=\"由单例模式引发的多线程安全的思考\"><a href=\"#由单例模式引发的多线程安全的思考\" class=\"headerlink\" title=\"由单例模式引发的多线程安全的思考\"></a>由单例模式引发的多线程安全的思考</h1><h2 id=\"static-bool-的判断在多线程下不安全\"><a href=\"#static-bool-的判断在多线程下不安全\" class=\"headerlink\" title=\"static bool 的判断在多线程下不安全\"></a>static bool 的判断在多线程下不安全</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> hasDone = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!hasDone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    hasDone = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// do something</span></span><br></pre></td></tr></table></figure>\n<p>以上写法不安全，有可能多个线程同时通过非空检查，导致 if 体内的代码执行多次</p>\n<p>如果一段代码是在 App 声明周期内只执行一次，则推荐使用 <code>dispatch_once</code>；其他的情况要具体分析</p>\n<h2 id=\"懒加载在多线程下不安全\"><a href=\"#懒加载在多线程下不安全\" class=\"headerlink\" title=\"懒加载在多线程下不安全\"></a>懒加载在多线程下不安全</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)myArray</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_myArray)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _myArray = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _myArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种判断在多线程下不安全的。所以多线程下尽量别使用懒加载，即使使用，也要加相应的保护，比如在 <code>_myArray</code> 不会被重新置为 nil 的前提下可以使用 <code>dispatch_once</code></p>\n","sticky":0},{"title":"关于Objective-C中的BOOL你所要知道的","date":"2016-05-31T16:00:00.000Z","keywords":"BOOL","_content":"\n# 问题\n曾经同事遇到一个关于 BOOL 的坑，这里分享下\n\n```objectivec\n- (BOOL)isPreloadingViewShowing\n{\n    return self.mainCtl.preLoadingView.superview;\n}\n```\n当 preLoadingView 明明有 superview 的时候，该函数居然有可能返回 NO\n\n通过进一步的测试，发现在64位机器上没有这个问题，而在32位机器上有可能出现\n\nWhy?!先写个 Demo 测试下\n\n---\n\n# Demo\n```objectivec\nstatic BOOL dif(int a, int b)\n{\n    return a-b;\n}\n\nif (dif(11, 10))\n{\n    NSLog(@\"11 != 10\");\n}\n\nif (dif(10, 11))\n{\n    NSLog(@\"10 != 11\");\n}\n\nif (dif(512, 256))\n{\n    NSLog(@\"512 != 256\");\n}\n```\n\n# Demo 运行结果\n+ 64位机器上\n\n```objectivec\n11 != 10\n10 != 11\n512 != 256\n```\n+ 32位机器上\n\n```objectivec\n11 != 10\n10 != 11\n```\n\n唯一的问题是为什么32位机器上最后一个的结果不对？！\n\n# Objective-C 中的 BOOL 到底是什么\n第一个要搞清楚的问题是，Obj-C 中的 BOOL 到底是什么？打开 objc.h，查看 BOOL 的定义\n\n```objectivec\n// objc.h\n\n#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH\ntypedef bool BOOL;\n#else\ntypedef signed char BOOL; \n#endif\n```\n意思是，在64位机器上，BOOL 是 bool，bool 的取值只有 true or false；在32位机器上，BOOL 是 signed char，长度8 bits\n\n所以，没有多余的机器可以测试的时候，我们可以把`static BOOL dif(int a, int b)`改为`static bool dif(int a, int b)`或`static signed char dif(int a, int b)`来模拟64位机器或32位机器的情况\n\n\n# Demo 结果分析\nDemo 中，a-b的结果是 int 类型，\n> int 作为返回值的时候会被强转为 BOOL，32位机器上 int 强转为 BOOL 的时候，其实是转为 signed char，只取了最低的8位，而64位机器上，BOOL 就是 bool，什么问题都没有，0即 false，非0即 true，可以像 C/C++ 语言那样放心使用\n\n+ 64位机器上\n\n```objectivec\n11-10=1 -> 0x0000000000000001 -> true\n10-11=-1 -> 0xffffffffffffffff -> true\n512-256=256 -> 0x0000000000000100 -> true\n```\n+ 32位机器上\n\n```objectivec\n11-10=1 -> 0x00000001 -> 00000001 -> true\n10-11=-1 -> 0xffffffff -> 11111111 -> true\n512-256=256 -> 0x00000100 -> 00000000 -> false\n```\n\n关于32位机器与64位机器数据类型长度类型，可以参见[32位机器与64位机器数据类型长度][1]\n\n---\n\n# 解决方法\n理清了 Demo，最上面的问题就迎刃而解了，superview 是一个指针（指针在 32/64 位机器上的位数是不同的），32位机器上，如果指针地址刚好最后8位都是0，那么即使指针不是空的，也会导致返回结果为空\n\n正确的做法应该为\n\n```objectivec\n- (BOOL)isPreloadingViewShowing\n{\n    if (self.mainCtl.preLoadingView.superview) \n        return YES;\n    else\n        return NO;\n}\n```\n\n# 结论\n> 取 int 或指针等类型作为 BOOL 的返回值时要注意，强转的时候可能会只取最低8位作为结果，尽量避免这种情况\n\n# 参考\n+ [重新认识一下OC 中的 BOOL 值](http://www.jianshu.com/p/2b97f18918b3?utm_campaign=hugo&utm_medium=reader_share&utm_content=note)\n+ [32位机器与64位机器数据类型长度][1]\n[1]: https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html","source":"_posts/关于Objective-C中的BOOL你所要知道的.md","raw":"---\ntitle: 关于Objective-C中的BOOL你所要知道的\ndate: 2016-06-01\ncategories:\n- iOS\nkeywords: BOOL\n---\n\n# 问题\n曾经同事遇到一个关于 BOOL 的坑，这里分享下\n\n```objectivec\n- (BOOL)isPreloadingViewShowing\n{\n    return self.mainCtl.preLoadingView.superview;\n}\n```\n当 preLoadingView 明明有 superview 的时候，该函数居然有可能返回 NO\n\n通过进一步的测试，发现在64位机器上没有这个问题，而在32位机器上有可能出现\n\nWhy?!先写个 Demo 测试下\n\n---\n\n# Demo\n```objectivec\nstatic BOOL dif(int a, int b)\n{\n    return a-b;\n}\n\nif (dif(11, 10))\n{\n    NSLog(@\"11 != 10\");\n}\n\nif (dif(10, 11))\n{\n    NSLog(@\"10 != 11\");\n}\n\nif (dif(512, 256))\n{\n    NSLog(@\"512 != 256\");\n}\n```\n\n# Demo 运行结果\n+ 64位机器上\n\n```objectivec\n11 != 10\n10 != 11\n512 != 256\n```\n+ 32位机器上\n\n```objectivec\n11 != 10\n10 != 11\n```\n\n唯一的问题是为什么32位机器上最后一个的结果不对？！\n\n# Objective-C 中的 BOOL 到底是什么\n第一个要搞清楚的问题是，Obj-C 中的 BOOL 到底是什么？打开 objc.h，查看 BOOL 的定义\n\n```objectivec\n// objc.h\n\n#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH\ntypedef bool BOOL;\n#else\ntypedef signed char BOOL; \n#endif\n```\n意思是，在64位机器上，BOOL 是 bool，bool 的取值只有 true or false；在32位机器上，BOOL 是 signed char，长度8 bits\n\n所以，没有多余的机器可以测试的时候，我们可以把`static BOOL dif(int a, int b)`改为`static bool dif(int a, int b)`或`static signed char dif(int a, int b)`来模拟64位机器或32位机器的情况\n\n\n# Demo 结果分析\nDemo 中，a-b的结果是 int 类型，\n> int 作为返回值的时候会被强转为 BOOL，32位机器上 int 强转为 BOOL 的时候，其实是转为 signed char，只取了最低的8位，而64位机器上，BOOL 就是 bool，什么问题都没有，0即 false，非0即 true，可以像 C/C++ 语言那样放心使用\n\n+ 64位机器上\n\n```objectivec\n11-10=1 -> 0x0000000000000001 -> true\n10-11=-1 -> 0xffffffffffffffff -> true\n512-256=256 -> 0x0000000000000100 -> true\n```\n+ 32位机器上\n\n```objectivec\n11-10=1 -> 0x00000001 -> 00000001 -> true\n10-11=-1 -> 0xffffffff -> 11111111 -> true\n512-256=256 -> 0x00000100 -> 00000000 -> false\n```\n\n关于32位机器与64位机器数据类型长度类型，可以参见[32位机器与64位机器数据类型长度][1]\n\n---\n\n# 解决方法\n理清了 Demo，最上面的问题就迎刃而解了，superview 是一个指针（指针在 32/64 位机器上的位数是不同的），32位机器上，如果指针地址刚好最后8位都是0，那么即使指针不是空的，也会导致返回结果为空\n\n正确的做法应该为\n\n```objectivec\n- (BOOL)isPreloadingViewShowing\n{\n    if (self.mainCtl.preLoadingView.superview) \n        return YES;\n    else\n        return NO;\n}\n```\n\n# 结论\n> 取 int 或指针等类型作为 BOOL 的返回值时要注意，强转的时候可能会只取最低8位作为结果，尽量避免这种情况\n\n# 参考\n+ [重新认识一下OC 中的 BOOL 值](http://www.jianshu.com/p/2b97f18918b3?utm_campaign=hugo&utm_medium=reader_share&utm_content=note)\n+ [32位机器与64位机器数据类型长度][1]\n[1]: https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html","slug":"关于Objective-C中的BOOL你所要知道的","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje87q09c000itjqwug6swg14","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>曾经同事遇到一个关于 BOOL 的坑，这里分享下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPreloadingViewShowing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.mainCtl.preLoadingView.superview;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 preLoadingView 明明有 superview 的时候，该函数居然有可能返回 NO</p>\n<p>通过进一步的测试，发现在64位机器上没有这个问题，而在32位机器上有可能出现</p>\n<p>Why?!先写个 Demo 测试下</p>\n<hr>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">BOOL</span> dif(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a-b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">11</span>, <span class=\"number\">10</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"11 != 10\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">10</span>, <span class=\"number\">11</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"10 != 11\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">512</span>, <span class=\"number\">256</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"512 != 256\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Demo-运行结果\"><a href=\"#Demo-运行结果\" class=\"headerlink\" title=\"Demo 运行结果\"></a>Demo 运行结果</h1><ul>\n<li>64位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> != <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span> != <span class=\"number\">11</span></span><br><span class=\"line\"><span class=\"number\">512</span> != <span class=\"number\">256</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>32位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> != <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span> != <span class=\"number\">11</span></span><br></pre></td></tr></table></figure>\n<p>唯一的问题是为什么32位机器上最后一个的结果不对？！</p>\n<h1 id=\"Objective-C-中的-BOOL-到底是什么\"><a href=\"#Objective-C-中的-BOOL-到底是什么\" class=\"headerlink\" title=\"Objective-C 中的 BOOL 到底是什么\"></a>Objective-C 中的 BOOL 到底是什么</h1><p>第一个要搞清楚的问题是，Obj-C 中的 BOOL 到底是什么？打开 objc.h，查看 BOOL 的定义</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#if (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> <span class=\"built_in\">BOOL</span>;</span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> <span class=\"built_in\">BOOL</span>; </span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>意思是，在64位机器上，BOOL 是 bool，bool 的取值只有 true or false；在32位机器上，BOOL 是 signed char，长度8 bits</p>\n<p>所以，没有多余的机器可以测试的时候，我们可以把<code>static BOOL dif(int a, int b)</code>改为<code>static bool dif(int a, int b)</code>或<code>static signed char dif(int a, int b)</code>来模拟64位机器或32位机器的情况</p>\n<h1 id=\"Demo-结果分析\"><a href=\"#Demo-结果分析\" class=\"headerlink\" title=\"Demo 结果分析\"></a>Demo 结果分析</h1><p>Demo 中，a-b的结果是 int 类型，</p>\n<blockquote>\n<p>int 作为返回值的时候会被强转为 BOOL，32位机器上 int 强转为 BOOL 的时候，其实是转为 signed char，只取了最低的8位，而64位机器上，BOOL 就是 bool，什么问题都没有，0即 false，非0即 true，可以像 C/C++ 语言那样放心使用</p>\n</blockquote>\n<ul>\n<li>64位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span><span class=\"number\">-10</span>=<span class=\"number\">1</span> -&gt; <span class=\"number\">0x0000000000000001</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">10</span><span class=\"number\">-11</span>=<span class=\"number\">-1</span> -&gt; <span class=\"number\">0xffffffffffffffff</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">512</span><span class=\"number\">-256</span>=<span class=\"number\">256</span> -&gt; <span class=\"number\">0x0000000000000100</span> -&gt; <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>32位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span><span class=\"number\">-10</span>=<span class=\"number\">1</span> -&gt; <span class=\"number\">0x00000001</span> -&gt; <span class=\"number\">00000001</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">10</span><span class=\"number\">-11</span>=<span class=\"number\">-1</span> -&gt; <span class=\"number\">0xffffffff</span> -&gt; <span class=\"number\">11111111</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">512</span><span class=\"number\">-256</span>=<span class=\"number\">256</span> -&gt; <span class=\"number\">0x00000100</span> -&gt; <span class=\"number\">00000000</span> -&gt; <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>关于32位机器与64位机器数据类型长度类型，可以参见<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html\" target=\"_blank\" rel=\"noopener\">32位机器与64位机器数据类型长度</a></p>\n<hr>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>理清了 Demo，最上面的问题就迎刃而解了，superview 是一个指针（指针在 32/64 位机器上的位数是不同的），32位机器上，如果指针地址刚好最后8位都是0，那么即使指针不是空的，也会导致返回结果为空</p>\n<p>正确的做法应该为</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPreloadingViewShowing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.mainCtl.preLoadingView.superview) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><blockquote>\n<p>取 int 或指针等类型作为 BOOL 的返回值时要注意，强转的时候可能会只取最低8位作为结果，尽量避免这种情况</p>\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://www.jianshu.com/p/2b97f18918b3?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note\" target=\"_blank\" rel=\"noopener\">重新认识一下OC 中的 BOOL 值</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html\" target=\"_blank\" rel=\"noopener\">32位机器与64位机器数据类型长度</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>曾经同事遇到一个关于 BOOL 的坑，这里分享下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPreloadingViewShowing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.mainCtl.preLoadingView.superview;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 preLoadingView 明明有 superview 的时候，该函数居然有可能返回 NO</p>\n<p>通过进一步的测试，发现在64位机器上没有这个问题，而在32位机器上有可能出现</p>\n<p>Why?!先写个 Demo 测试下</p>\n<hr>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">BOOL</span> dif(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a-b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">11</span>, <span class=\"number\">10</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"11 != 10\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">10</span>, <span class=\"number\">11</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"10 != 11\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (dif(<span class=\"number\">512</span>, <span class=\"number\">256</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"512 != 256\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Demo-运行结果\"><a href=\"#Demo-运行结果\" class=\"headerlink\" title=\"Demo 运行结果\"></a>Demo 运行结果</h1><ul>\n<li>64位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> != <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span> != <span class=\"number\">11</span></span><br><span class=\"line\"><span class=\"number\">512</span> != <span class=\"number\">256</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>32位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> != <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span> != <span class=\"number\">11</span></span><br></pre></td></tr></table></figure>\n<p>唯一的问题是为什么32位机器上最后一个的结果不对？！</p>\n<h1 id=\"Objective-C-中的-BOOL-到底是什么\"><a href=\"#Objective-C-中的-BOOL-到底是什么\" class=\"headerlink\" title=\"Objective-C 中的 BOOL 到底是什么\"></a>Objective-C 中的 BOOL 到底是什么</h1><p>第一个要搞清楚的问题是，Obj-C 中的 BOOL 到底是什么？打开 objc.h，查看 BOOL 的定义</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#if (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> <span class=\"built_in\">BOOL</span>;</span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> <span class=\"built_in\">BOOL</span>; </span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>意思是，在64位机器上，BOOL 是 bool，bool 的取值只有 true or false；在32位机器上，BOOL 是 signed char，长度8 bits</p>\n<p>所以，没有多余的机器可以测试的时候，我们可以把<code>static BOOL dif(int a, int b)</code>改为<code>static bool dif(int a, int b)</code>或<code>static signed char dif(int a, int b)</code>来模拟64位机器或32位机器的情况</p>\n<h1 id=\"Demo-结果分析\"><a href=\"#Demo-结果分析\" class=\"headerlink\" title=\"Demo 结果分析\"></a>Demo 结果分析</h1><p>Demo 中，a-b的结果是 int 类型，</p>\n<blockquote>\n<p>int 作为返回值的时候会被强转为 BOOL，32位机器上 int 强转为 BOOL 的时候，其实是转为 signed char，只取了最低的8位，而64位机器上，BOOL 就是 bool，什么问题都没有，0即 false，非0即 true，可以像 C/C++ 语言那样放心使用</p>\n</blockquote>\n<ul>\n<li>64位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span><span class=\"number\">-10</span>=<span class=\"number\">1</span> -&gt; <span class=\"number\">0x0000000000000001</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">10</span><span class=\"number\">-11</span>=<span class=\"number\">-1</span> -&gt; <span class=\"number\">0xffffffffffffffff</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">512</span><span class=\"number\">-256</span>=<span class=\"number\">256</span> -&gt; <span class=\"number\">0x0000000000000100</span> -&gt; <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>32位机器上</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span><span class=\"number\">-10</span>=<span class=\"number\">1</span> -&gt; <span class=\"number\">0x00000001</span> -&gt; <span class=\"number\">00000001</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">10</span><span class=\"number\">-11</span>=<span class=\"number\">-1</span> -&gt; <span class=\"number\">0xffffffff</span> -&gt; <span class=\"number\">11111111</span> -&gt; <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">512</span><span class=\"number\">-256</span>=<span class=\"number\">256</span> -&gt; <span class=\"number\">0x00000100</span> -&gt; <span class=\"number\">00000000</span> -&gt; <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>关于32位机器与64位机器数据类型长度类型，可以参见<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html\" target=\"_blank\" rel=\"noopener\">32位机器与64位机器数据类型长度</a></p>\n<hr>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>理清了 Demo，最上面的问题就迎刃而解了，superview 是一个指针（指针在 32/64 位机器上的位数是不同的），32位机器上，如果指针地址刚好最后8位都是0，那么即使指针不是空的，也会导致返回结果为空</p>\n<p>正确的做法应该为</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPreloadingViewShowing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.mainCtl.preLoadingView.superview) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><blockquote>\n<p>取 int 或指针等类型作为 BOOL 的返回值时要注意，强转的时候可能会只取最低8位作为结果，尽量避免这种情况</p>\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://www.jianshu.com/p/2b97f18918b3?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note\" target=\"_blank\" rel=\"noopener\">重新认识一下OC 中的 BOOL 值</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/Major64-BitChanges/Major64-BitChanges.html\" target=\"_blank\" rel=\"noopener\">32位机器与64位机器数据类型长度</a></li>\n</ul>\n","sticky":0},{"title":"同步、异步、阻塞、非阻塞的简单理解","date":"2016-08-23T16:00:00.000Z","keywords":"同步;异步;阻塞;非阻塞","_content":"\n>    \n    同步和异步, 是消息的通知机制，描述的是两个对象之间的关系\n>\n    阻塞和非阻塞, 是程序在等待消息(无所谓同步或者异步)时的状态，描述的是单个对象的状态\n    \n# 同步\n同步，就是调用一个函数时，在没有得到结果之前，该函数就不返回\n\n# 异步\n异步，就是就是调用一个函数时，该函数直接返回，等到有结果后，再通过`状态`、`通知`或`回调函数`告诉调用者\n\n# 阻塞\n阻塞是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后线程才继续工作\n\n# 非阻塞\n非阻塞指调用结果返回之前，该函数不会阻塞当前线程\n\n# 例子\n你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下\"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）\n\n而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调\n\n你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先做其他事，比如看电视\n\n# 同步阻塞\n同步阻塞是指你不挂电话，你无法做其他事\n\n效率最低\n\n“你”可以理解为一个程序，而打电话和做其他事分别是2个操作，打电话的操作没有返回，整个程序还被挂起\n\n# 同步非阻塞\n同步非阻塞是指你不挂电话，你可以做其他事\n\n效率低下，你需要边做其他事，边观察老板有没有告诉你结果\n\n虽然打电话的操作没有返回，但是程序可以先执行其他操作（不是执行打电话之后的操作，而是跟打电话行为平行的操作），程序需要在2个函数之间频繁切换\n\n# 异步阻塞\n异步阻塞是指你挂了电话，但你无法做其他事，等老板打电话过来\n\n效率低下\n\n虽然挂了电话，但是程序无法执行其他操作。程序不是被调用函数阻塞，而是被等待函数结果阻塞\n\n# 异步非阻塞\n异步非阻塞是指你挂了电话，你可以做其他事，等老板打电话过来\n\n效率最高\n\n程序没有在两种不同的操作中来回切换\n\n# 参考文章\n1. [IO中同步、异步与阻塞、非阻塞的区别](http://blog.chinaunix.net/uid-26000296-id-3754118.html)\n2. [怎样理解阻塞非阻塞与同步异步的区别？](http://www.linuxidc.com/Linux/2015-07/120338.htm)\n3. [IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）](http://m.blog.csdn.net/article/details?id=5778378)","source":"_posts/同步、异步、阻塞、非阻塞的简单理解.md","raw":"---\ntitle: 同步、异步、阻塞、非阻塞的简单理解\ndate: 2016-08-24\ncategories:\n- Others\nkeywords: 同步;异步;阻塞;非阻塞\n---\n\n>    \n    同步和异步, 是消息的通知机制，描述的是两个对象之间的关系\n>\n    阻塞和非阻塞, 是程序在等待消息(无所谓同步或者异步)时的状态，描述的是单个对象的状态\n    \n# 同步\n同步，就是调用一个函数时，在没有得到结果之前，该函数就不返回\n\n# 异步\n异步，就是就是调用一个函数时，该函数直接返回，等到有结果后，再通过`状态`、`通知`或`回调函数`告诉调用者\n\n# 阻塞\n阻塞是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后线程才继续工作\n\n# 非阻塞\n非阻塞指调用结果返回之前，该函数不会阻塞当前线程\n\n# 例子\n你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下\"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）\n\n而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调\n\n你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先做其他事，比如看电视\n\n# 同步阻塞\n同步阻塞是指你不挂电话，你无法做其他事\n\n效率最低\n\n“你”可以理解为一个程序，而打电话和做其他事分别是2个操作，打电话的操作没有返回，整个程序还被挂起\n\n# 同步非阻塞\n同步非阻塞是指你不挂电话，你可以做其他事\n\n效率低下，你需要边做其他事，边观察老板有没有告诉你结果\n\n虽然打电话的操作没有返回，但是程序可以先执行其他操作（不是执行打电话之后的操作，而是跟打电话行为平行的操作），程序需要在2个函数之间频繁切换\n\n# 异步阻塞\n异步阻塞是指你挂了电话，但你无法做其他事，等老板打电话过来\n\n效率低下\n\n虽然挂了电话，但是程序无法执行其他操作。程序不是被调用函数阻塞，而是被等待函数结果阻塞\n\n# 异步非阻塞\n异步非阻塞是指你挂了电话，你可以做其他事，等老板打电话过来\n\n效率最高\n\n程序没有在两种不同的操作中来回切换\n\n# 参考文章\n1. [IO中同步、异步与阻塞、非阻塞的区别](http://blog.chinaunix.net/uid-26000296-id-3754118.html)\n2. [怎样理解阻塞非阻塞与同步异步的区别？](http://www.linuxidc.com/Linux/2015-07/120338.htm)\n3. [IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）](http://m.blog.csdn.net/article/details?id=5778378)","slug":"同步、异步、阻塞、非阻塞的简单理解","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje87q09d000ktjqwiysp314c","content":"<blockquote>\n<pre><code>同步和异步, 是消息的通知机制，描述的是两个对象之间的关系\n\n阻塞和非阻塞, 是程序在等待消息(无所谓同步或者异步)时的状态，描述的是单个对象的状态\n</code></pre></blockquote>\n<h1 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h1><p>同步，就是调用一个函数时，在没有得到结果之前，该函数就不返回</p>\n<h1 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h1><p>异步，就是就是调用一个函数时，该函数直接返回，等到有结果后，再通过<code>状态</code>、<code>通知</code>或<code>回调函数</code>告诉调用者</p>\n<h1 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h1><p>阻塞是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后线程才继续工作</p>\n<h1 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a>非阻塞</h1><p>非阻塞指调用结果返回之前，该函数不会阻塞当前线程</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）</p>\n<p>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调</p>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先做其他事，比如看电视</p>\n<h1 id=\"同步阻塞\"><a href=\"#同步阻塞\" class=\"headerlink\" title=\"同步阻塞\"></a>同步阻塞</h1><p>同步阻塞是指你不挂电话，你无法做其他事</p>\n<p>效率最低</p>\n<p>“你”可以理解为一个程序，而打电话和做其他事分别是2个操作，打电话的操作没有返回，整个程序还被挂起</p>\n<h1 id=\"同步非阻塞\"><a href=\"#同步非阻塞\" class=\"headerlink\" title=\"同步非阻塞\"></a>同步非阻塞</h1><p>同步非阻塞是指你不挂电话，你可以做其他事</p>\n<p>效率低下，你需要边做其他事，边观察老板有没有告诉你结果</p>\n<p>虽然打电话的操作没有返回，但是程序可以先执行其他操作（不是执行打电话之后的操作，而是跟打电话行为平行的操作），程序需要在2个函数之间频繁切换</p>\n<h1 id=\"异步阻塞\"><a href=\"#异步阻塞\" class=\"headerlink\" title=\"异步阻塞\"></a>异步阻塞</h1><p>异步阻塞是指你挂了电话，但你无法做其他事，等老板打电话过来</p>\n<p>效率低下</p>\n<p>虽然挂了电话，但是程序无法执行其他操作。程序不是被调用函数阻塞，而是被等待函数结果阻塞</p>\n<h1 id=\"异步非阻塞\"><a href=\"#异步非阻塞\" class=\"headerlink\" title=\"异步非阻塞\"></a>异步非阻塞</h1><p>异步非阻塞是指你挂了电话，你可以做其他事，等老板打电话过来</p>\n<p>效率最高</p>\n<p>程序没有在两种不同的操作中来回切换</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ol>\n<li><a href=\"http://blog.chinaunix.net/uid-26000296-id-3754118.html\" target=\"_blank\" rel=\"noopener\">IO中同步、异步与阻塞、非阻塞的区别</a></li>\n<li><a href=\"http://www.linuxidc.com/Linux/2015-07/120338.htm\" target=\"_blank\" rel=\"noopener\">怎样理解阻塞非阻塞与同步异步的区别？</a></li>\n<li><a href=\"http://m.blog.csdn.net/article/details?id=5778378\" target=\"_blank\" rel=\"noopener\">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<pre><code>同步和异步, 是消息的通知机制，描述的是两个对象之间的关系\n\n阻塞和非阻塞, 是程序在等待消息(无所谓同步或者异步)时的状态，描述的是单个对象的状态\n</code></pre></blockquote>\n<h1 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h1><p>同步，就是调用一个函数时，在没有得到结果之前，该函数就不返回</p>\n<h1 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h1><p>异步，就是就是调用一个函数时，该函数直接返回，等到有结果后，再通过<code>状态</code>、<code>通知</code>或<code>回调函数</code>告诉调用者</p>\n<h1 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h1><p>阻塞是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后线程才继续工作</p>\n<h1 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a>非阻塞</h1><p>非阻塞指调用结果返回之前，该函数不会阻塞当前线程</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）</p>\n<p>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调</p>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先做其他事，比如看电视</p>\n<h1 id=\"同步阻塞\"><a href=\"#同步阻塞\" class=\"headerlink\" title=\"同步阻塞\"></a>同步阻塞</h1><p>同步阻塞是指你不挂电话，你无法做其他事</p>\n<p>效率最低</p>\n<p>“你”可以理解为一个程序，而打电话和做其他事分别是2个操作，打电话的操作没有返回，整个程序还被挂起</p>\n<h1 id=\"同步非阻塞\"><a href=\"#同步非阻塞\" class=\"headerlink\" title=\"同步非阻塞\"></a>同步非阻塞</h1><p>同步非阻塞是指你不挂电话，你可以做其他事</p>\n<p>效率低下，你需要边做其他事，边观察老板有没有告诉你结果</p>\n<p>虽然打电话的操作没有返回，但是程序可以先执行其他操作（不是执行打电话之后的操作，而是跟打电话行为平行的操作），程序需要在2个函数之间频繁切换</p>\n<h1 id=\"异步阻塞\"><a href=\"#异步阻塞\" class=\"headerlink\" title=\"异步阻塞\"></a>异步阻塞</h1><p>异步阻塞是指你挂了电话，但你无法做其他事，等老板打电话过来</p>\n<p>效率低下</p>\n<p>虽然挂了电话，但是程序无法执行其他操作。程序不是被调用函数阻塞，而是被等待函数结果阻塞</p>\n<h1 id=\"异步非阻塞\"><a href=\"#异步非阻塞\" class=\"headerlink\" title=\"异步非阻塞\"></a>异步非阻塞</h1><p>异步非阻塞是指你挂了电话，你可以做其他事，等老板打电话过来</p>\n<p>效率最高</p>\n<p>程序没有在两种不同的操作中来回切换</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ol>\n<li><a href=\"http://blog.chinaunix.net/uid-26000296-id-3754118.html\" target=\"_blank\" rel=\"noopener\">IO中同步、异步与阻塞、非阻塞的区别</a></li>\n<li><a href=\"http://www.linuxidc.com/Linux/2015-07/120338.htm\" target=\"_blank\" rel=\"noopener\">怎样理解阻塞非阻塞与同步异步的区别？</a></li>\n<li><a href=\"http://m.blog.csdn.net/article/details?id=5778378\" target=\"_blank\" rel=\"noopener\">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a></li>\n</ol>\n","sticky":0},{"title":"如何用iPad在床上优雅的看大片","date":"2016-08-03T16:00:00.000Z","photos":["images/girl.jpg"],"keywords":"iPad;局域网;视频","_content":"\n# 背景\n家里躺床上的想用 iPad 看电影，普通人会怎么做？\n\n+ 在线观看。那么网络卡怎么办？在线视频网站或 app 没有你要的视频怎么办？\n+ 直接下载到 iPad？iPad 内存不够用，看一部删一部？\n+ 下载到 PC，再从 PC 导入到 iPad。导入过程很蛋疼怎么办？\n\n我是多么愚蠢，现在才意识到要解决这个问题，第一反应当然是利用局域网共享，于是找到以下方法\n\n# 方法\n相比普通人的普通方法，更优雅的解决方法是，视频提前下载到 PC 上，然后保证 iPad 和 PC 处于同一局域网，这样就能利用局域网来共享视频，不影响其他人的网速！\n\n原理是利用 DLNA 解决，PC 部署成服务器，iPad 来访问\n\n啊，DLNA 是什么？你不用管，我也不知道，专注问题本身，学会利用工具就行了\n\n# 工具\n硬件：\n\n+ 首先你要有一台 iPad，当然其他支持 DLNA 的设备也行\n+ 一台 PC，Mac 或 Windows 都行\n+ 一个路由\n\n软件：\n\n+ Twonky Server\n+ nPlayer\n\n## Twonky Server\n+ PC 上安装 Twonky Server\n+ 打开配置页面，指定共享文件夹\n+ 设置开机运行\n\n## nPlayer\n+ iPad 上安装 nPlayer\n+ AppStore 有免费版本，但是底部有广告，不过功能是齐全的\n+ 下载后扫描网络即可发现 PC 上的服务器\n\n# 效果\n成功播放，非常流畅，与播放本地视频无异，支持滑动快进快退，嘿嘿嘿，你懂的，就是时不时蹦出个小广告，挺烦的\n\n# 注意点\n最后记得，手动配置电脑的 IP 地址，以防止 IP 地址更改时客户端链接失效\n\n从萌生想法，查阅资料，解决问题，到写下这篇博客，前前后后花了不到2个小时，但却为我以后省下了很多很多的时间。这个问题很难解决吗？不难，能不能发现问题才是关键\n\n所以，多留心，看看生活中有什么让你不爽的地方，想办法，解决它。这是一种生活态度，也是一种学习态度。正如之前的文章[《手机控制电脑定时关机，重启WiFi》](http://www.cnblogs.com/chenyg32/p/4391727.html)和[《房间WIFI信号不好怎么办？——无线路由桥接（WDS）》](http://www.cnblogs.com/chenyg32/p/4782645.html)说的一样：\n\n> 至此，虽然是简简单单的功能，但是，it makes my world better.\n\n# 参考文章\n[iPad 直接播放 PC / Mac端或移动硬盘内的视频，目前最好的解决方案是？](https://www.zhihu.com/question/20581392)","source":"_posts/如何用iPad在床上优雅的看大片.md","raw":"---\ntitle: 如何用iPad在床上优雅的看大片\ndate: 2016-08-04\ncategories:\n- 代码之外\nphotos: images/girl.jpg\nkeywords: iPad;局域网;视频\n---\n\n# 背景\n家里躺床上的想用 iPad 看电影，普通人会怎么做？\n\n+ 在线观看。那么网络卡怎么办？在线视频网站或 app 没有你要的视频怎么办？\n+ 直接下载到 iPad？iPad 内存不够用，看一部删一部？\n+ 下载到 PC，再从 PC 导入到 iPad。导入过程很蛋疼怎么办？\n\n我是多么愚蠢，现在才意识到要解决这个问题，第一反应当然是利用局域网共享，于是找到以下方法\n\n# 方法\n相比普通人的普通方法，更优雅的解决方法是，视频提前下载到 PC 上，然后保证 iPad 和 PC 处于同一局域网，这样就能利用局域网来共享视频，不影响其他人的网速！\n\n原理是利用 DLNA 解决，PC 部署成服务器，iPad 来访问\n\n啊，DLNA 是什么？你不用管，我也不知道，专注问题本身，学会利用工具就行了\n\n# 工具\n硬件：\n\n+ 首先你要有一台 iPad，当然其他支持 DLNA 的设备也行\n+ 一台 PC，Mac 或 Windows 都行\n+ 一个路由\n\n软件：\n\n+ Twonky Server\n+ nPlayer\n\n## Twonky Server\n+ PC 上安装 Twonky Server\n+ 打开配置页面，指定共享文件夹\n+ 设置开机运行\n\n## nPlayer\n+ iPad 上安装 nPlayer\n+ AppStore 有免费版本，但是底部有广告，不过功能是齐全的\n+ 下载后扫描网络即可发现 PC 上的服务器\n\n# 效果\n成功播放，非常流畅，与播放本地视频无异，支持滑动快进快退，嘿嘿嘿，你懂的，就是时不时蹦出个小广告，挺烦的\n\n# 注意点\n最后记得，手动配置电脑的 IP 地址，以防止 IP 地址更改时客户端链接失效\n\n从萌生想法，查阅资料，解决问题，到写下这篇博客，前前后后花了不到2个小时，但却为我以后省下了很多很多的时间。这个问题很难解决吗？不难，能不能发现问题才是关键\n\n所以，多留心，看看生活中有什么让你不爽的地方，想办法，解决它。这是一种生活态度，也是一种学习态度。正如之前的文章[《手机控制电脑定时关机，重启WiFi》](http://www.cnblogs.com/chenyg32/p/4391727.html)和[《房间WIFI信号不好怎么办？——无线路由桥接（WDS）》](http://www.cnblogs.com/chenyg32/p/4782645.html)说的一样：\n\n> 至此，虽然是简简单单的功能，但是，it makes my world better.\n\n# 参考文章\n[iPad 直接播放 PC / Mac端或移动硬盘内的视频，目前最好的解决方案是？](https://www.zhihu.com/question/20581392)","slug":"如何用iPad在床上优雅的看大片","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","link":"","_id":"cje87q09f000ntjqww8ehg3bx","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>家里躺床上的想用 iPad 看电影，普通人会怎么做？</p>\n<ul>\n<li>在线观看。那么网络卡怎么办？在线视频网站或 app 没有你要的视频怎么办？</li>\n<li>直接下载到 iPad？iPad 内存不够用，看一部删一部？</li>\n<li>下载到 PC，再从 PC 导入到 iPad。导入过程很蛋疼怎么办？</li>\n</ul>\n<p>我是多么愚蠢，现在才意识到要解决这个问题，第一反应当然是利用局域网共享，于是找到以下方法</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>相比普通人的普通方法，更优雅的解决方法是，视频提前下载到 PC 上，然后保证 iPad 和 PC 处于同一局域网，这样就能利用局域网来共享视频，不影响其他人的网速！</p>\n<p>原理是利用 DLNA 解决，PC 部署成服务器，iPad 来访问</p>\n<p>啊，DLNA 是什么？你不用管，我也不知道，专注问题本身，学会利用工具就行了</p>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><p>硬件：</p>\n<ul>\n<li>首先你要有一台 iPad，当然其他支持 DLNA 的设备也行</li>\n<li>一台 PC，Mac 或 Windows 都行</li>\n<li>一个路由</li>\n</ul>\n<p>软件：</p>\n<ul>\n<li>Twonky Server</li>\n<li>nPlayer</li>\n</ul>\n<h2 id=\"Twonky-Server\"><a href=\"#Twonky-Server\" class=\"headerlink\" title=\"Twonky Server\"></a>Twonky Server</h2><ul>\n<li>PC 上安装 Twonky Server</li>\n<li>打开配置页面，指定共享文件夹</li>\n<li>设置开机运行</li>\n</ul>\n<h2 id=\"nPlayer\"><a href=\"#nPlayer\" class=\"headerlink\" title=\"nPlayer\"></a>nPlayer</h2><ul>\n<li>iPad 上安装 nPlayer</li>\n<li>AppStore 有免费版本，但是底部有广告，不过功能是齐全的</li>\n<li>下载后扫描网络即可发现 PC 上的服务器</li>\n</ul>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>成功播放，非常流畅，与播放本地视频无异，支持滑动快进快退，嘿嘿嘿，你懂的，就是时不时蹦出个小广告，挺烦的</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>最后记得，手动配置电脑的 IP 地址，以防止 IP 地址更改时客户端链接失效</p>\n<p>从萌生想法，查阅资料，解决问题，到写下这篇博客，前前后后花了不到2个小时，但却为我以后省下了很多很多的时间。这个问题很难解决吗？不难，能不能发现问题才是关键</p>\n<p>所以，多留心，看看生活中有什么让你不爽的地方，想办法，解决它。这是一种生活态度，也是一种学习态度。正如之前的文章<a href=\"http://www.cnblogs.com/chenyg32/p/4391727.html\" target=\"_blank\" rel=\"noopener\">《手机控制电脑定时关机，重启WiFi》</a>和<a href=\"http://www.cnblogs.com/chenyg32/p/4782645.html\" target=\"_blank\" rel=\"noopener\">《房间WIFI信号不好怎么办？——无线路由桥接（WDS）》</a>说的一样：</p>\n<blockquote>\n<p>至此，虽然是简简单单的功能，但是，it makes my world better.</p>\n</blockquote>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p><a href=\"https://www.zhihu.com/question/20581392\" target=\"_blank\" rel=\"noopener\">iPad 直接播放 PC / Mac端或移动硬盘内的视频，目前最好的解决方案是？</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>家里躺床上的想用 iPad 看电影，普通人会怎么做？</p>\n<ul>\n<li>在线观看。那么网络卡怎么办？在线视频网站或 app 没有你要的视频怎么办？</li>\n<li>直接下载到 iPad？iPad 内存不够用，看一部删一部？</li>\n<li>下载到 PC，再从 PC 导入到 iPad。导入过程很蛋疼怎么办？</li>\n</ul>\n<p>我是多么愚蠢，现在才意识到要解决这个问题，第一反应当然是利用局域网共享，于是找到以下方法</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>相比普通人的普通方法，更优雅的解决方法是，视频提前下载到 PC 上，然后保证 iPad 和 PC 处于同一局域网，这样就能利用局域网来共享视频，不影响其他人的网速！</p>\n<p>原理是利用 DLNA 解决，PC 部署成服务器，iPad 来访问</p>\n<p>啊，DLNA 是什么？你不用管，我也不知道，专注问题本身，学会利用工具就行了</p>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><p>硬件：</p>\n<ul>\n<li>首先你要有一台 iPad，当然其他支持 DLNA 的设备也行</li>\n<li>一台 PC，Mac 或 Windows 都行</li>\n<li>一个路由</li>\n</ul>\n<p>软件：</p>\n<ul>\n<li>Twonky Server</li>\n<li>nPlayer</li>\n</ul>\n<h2 id=\"Twonky-Server\"><a href=\"#Twonky-Server\" class=\"headerlink\" title=\"Twonky Server\"></a>Twonky Server</h2><ul>\n<li>PC 上安装 Twonky Server</li>\n<li>打开配置页面，指定共享文件夹</li>\n<li>设置开机运行</li>\n</ul>\n<h2 id=\"nPlayer\"><a href=\"#nPlayer\" class=\"headerlink\" title=\"nPlayer\"></a>nPlayer</h2><ul>\n<li>iPad 上安装 nPlayer</li>\n<li>AppStore 有免费版本，但是底部有广告，不过功能是齐全的</li>\n<li>下载后扫描网络即可发现 PC 上的服务器</li>\n</ul>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>成功播放，非常流畅，与播放本地视频无异，支持滑动快进快退，嘿嘿嘿，你懂的，就是时不时蹦出个小广告，挺烦的</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>最后记得，手动配置电脑的 IP 地址，以防止 IP 地址更改时客户端链接失效</p>\n<p>从萌生想法，查阅资料，解决问题，到写下这篇博客，前前后后花了不到2个小时，但却为我以后省下了很多很多的时间。这个问题很难解决吗？不难，能不能发现问题才是关键</p>\n<p>所以，多留心，看看生活中有什么让你不爽的地方，想办法，解决它。这是一种生活态度，也是一种学习态度。正如之前的文章<a href=\"http://www.cnblogs.com/chenyg32/p/4391727.html\" target=\"_blank\" rel=\"noopener\">《手机控制电脑定时关机，重启WiFi》</a>和<a href=\"http://www.cnblogs.com/chenyg32/p/4782645.html\" target=\"_blank\" rel=\"noopener\">《房间WIFI信号不好怎么办？——无线路由桥接（WDS）》</a>说的一样：</p>\n<blockquote>\n<p>至此，虽然是简简单单的功能，但是，it makes my world better.</p>\n</blockquote>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p><a href=\"https://www.zhihu.com/question/20581392\" target=\"_blank\" rel=\"noopener\">iPad 直接播放 PC / Mac端或移动硬盘内的视频，目前最好的解决方案是？</a></p>\n","sticky":0},{"title":"神在细节之中","date":"2016-07-24T16:00:00.000Z","photos":["images/view.jpg"],"keywords":"代码整洁之道;","_content":"\n# 碎碎念\n这其实是《代码整洁之道》的学习笔记，起了一个看起来很厉害的名字。\n\n之前读过《如何阅读一本书》，但是读完之后还是没什么收获，只懂读，不懂消化。前几天看了这篇文章[《一年读100本书的技能，你1分钟就能学得会》](http://www.jianshu.com/p/b780ba99abd6)，有恍然大悟状。怪不得我一直读书很慢，很少，读了一点就不想读，原来我是一直用的学生考试时代的`基础阅读`，这种是最低级的阅读方式，一个字一个字读，漫无目的地读。现在我改用了`检视阅读`和`分析阅读`，不求甚解，跳过了一些无用章节，比如 Java 相关的，测试相关的，所以一个下午就把大半本书给啃下来了，效率十分高。另外，书的配图很棒\n\n我只挑自己仍需注意的点记录下来，并结合自己的经验谈谈。而一些最基本的，SRP、DRY 等是老生常谈的问题，就不赘述。特别是 DRY，懂的人很多，敲代码的时候能想到的人就少了，想到并且做好的人就更少。工程里面经常看到这段代码复制过来，那段代码复制过去，是最恶心的。这个原则值得用一生去践行、体会并提高\n\n# 前言\n> 阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。\n\n我是第二种。希望有一天，我写的代码，能成为一种艺术\n\n> 衡量代码质量的唯一有效标准： WTF/min\n\n![](http://images.cnitblog.com/blog/435441/201301/29202423-4786f70c83254e0f88aa1c31110e1bd5.jpg)\n\n《代码整洁之道》最有道理的一句话，即代码阅读者每一分钟爆出的\"What The Fuck\"数量，哈哈哈\n\n# 使用可搜索的名称\n> 名称长短应与其作用域大小相对应\n\n比如，在一个简单的 for 循环里，使用简单的 i 来命名下标就很足够了；而如果一个变量的作用域很大，那么其命名应该易于搜索（名称长是为了易于搜索）\n\n# 不要写多余的注释，别让你写的注释比看代码还累\n> 与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那段糟糕的代码\n\n确实，这点我做得不够，有时候为函数的声明写的注释太多，需要改进\n\n# 如果可以，尽量别注释代码\n> 其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除\n\n一方面，我看到注释掉的代码真的很讨厌，因为我是极简主义，能少写一行代码甚至一个空格就少写，一坨被注释的代码放在那里会影响阅读体验\n\n但是另一方面我又不完全同意这个观点，作者说现在已经有版本管理，所以没必要保留注释的代码，但是谁修改代码的时候没事会去查看之前的版本呢？比如，上次我想为频道列表页添加缓存逻辑，但是发现之前有人加过了，但是被注释了，询问之后才发现直接为这个页面添加缓存是有坑的，于是这次添加缓存就顺利绕过了这个坑。那么如果没有这段注释的代码，我可能就会直接跳进这个坑了，因为我修改之前并不可能漫无目的去查看 SVN\n\n# 不要刻意去水平对齐\n刻意的水平像是在强调不重要的东西，分散读者注意力\n\n```objc\n@property (nonatomic, assign) int                   leftNum;\n@property (nonatomic, copy)   NSString              *dataKey;\n@property (nonatomic, retain) QLJCEShareItem        *shareItem;\n@property (nonatomic, retain) QLJCEONAPosterTitle   *tips;\n```\n\n下面这段代码更好，因为注意力能更集中在变量的类型上\n\n```objc\n@property (nonatomic, assign) int leftNum;\n@property (nonatomic, copy) NSString *dataKey;\n@property (nonatomic, retain) QLJCEShareItem *shareItem;\n@property (nonatomic, retain) QLJCEONAPosterTitle *tips;\n```\n\n# 要编写简洁的代码，必须先写肮脏的代码，然后再清理它\n问题是写完了肮脏的可运行的代码之后，别着急开始下一个任务而忘记改进它\n\n# 使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\n先看一个例子\n\n```objc\n- (void)pay:(BOOL)isVip\n{\n    // 通用代码\n\n    if (isVip)\n    {\n        // VIP处理代码\n    }\n    else\n    {\n        // 普通成员处理代码\n    }\n}\n```\n首先作者认为这种代码不好，因为调用的时候应该去记住传递的 BOOL 代表什么意思，应该改为以下这种\n\n```objc\n- (void)pay\n{\n    // 通用代码\n\n    if ([self isVip])\n    {\n        // Vip处理代码\n    }\n    else\n    {\n        // 普通成员处理代码\n    }\n}\n```\n或这种\n\n```objc\n- (void)vipPay\n{\n    // 通用代码\n\n    // VIP处理代码\n}\n\n- (void)commonPay\n{\n    // 通用代码\n\n    // 普通成员处理代码\n}\n```\n首先方法1并不是处处可行，因为对于 Vip 的判断是否合适放在本类要根据具体情况讨论，合适则方法1可行\n\n而方法2我不敢苟同，因为这首先违背了一种重要的原则——DRY，通用代码在2处地方重复，维护起来十分恶心\n\n同时，在 IDE 日益强大的今天，多写一个参数并不对程序员的记忆有所挑战，即使有，也比重复代码好\n\n# 代码要尽可能具有表达力\n\n```objc\nif (curTime >= startTime && curTime <= endTime && !hasShown)    // 是否应该展示\n{\n\n}\n```\n应该处理为下面这种，这比写注释好\n\n```objc\n- (BOOL)shouldShow\n{\n    return (curTime >= startTime && curTime <= endTime && !hasShown);\n}\n\nif ([self shouldShow])\n{\n\n}\n```\n\n# 得墨忒耳定律（最少了解原理）\nA 有一个属性叫 B，B 有一个属性叫 C，C 有一个 doSomething 的函数。现在需要在 A 里面调用 C 的函数。有以下2种写法\n\n方法1，B 把属性 C 暴露在头文件，让 A 可以直接读取\n\n```objc\n// A.m\n[self.b.c doSomething];\n\n// B.h\n@property (nonatomic, strong) C *c;\n\n// C.h\n- (void)doSomething;\n\n// C.m\n- (void)doSomething\n{\n    NSLog(@\"Hello World!\");\n}\n```\n\n方法2，B 把 C 中的函数封装成接口提供给外部使用\n\n```objc\n// A.m\n[self.b doSomething];\n\n// B.h\n- (void)doSomething;\n\n// B.m\n- (void)doSomething\n{\n    [self.c doSomething];\n}\n\n// C.h\n- (void)doSomething;\n\n// C.m\n- (void)doSomething\n{\n    NSLog(@\"Hello World!\");\n}\n```\n\n曾经，我不知道方法1和方法2孰优孰劣，甚至更倾向于方法1，因为代码量更少，但读了这本书后，我明白了，方法2更好，为什么？\n\n+ 方法1违背了`得墨忒耳定律`，C 不是 A 的属性，而 A 居然要去了解 C 里面的函数\n+ 假如不止A，还有A1,A2,A3...直接调用了 C 的函数，那么有一天，当 C 修改 doSomething 这个函数名，或者想在 B 和 C 之间再添加一个类 D 的时候，此时方法1就需要修改很多地方，而方法2只需要修改 B 文件","source":"_posts/神在细节之中.md","raw":"---\ntitle: 神在细节之中\ndate: 2016-07-25\ncategories:\n- 读书笔记\nphotos: images/view.jpg\nkeywords: 代码整洁之道;\n---\n\n# 碎碎念\n这其实是《代码整洁之道》的学习笔记，起了一个看起来很厉害的名字。\n\n之前读过《如何阅读一本书》，但是读完之后还是没什么收获，只懂读，不懂消化。前几天看了这篇文章[《一年读100本书的技能，你1分钟就能学得会》](http://www.jianshu.com/p/b780ba99abd6)，有恍然大悟状。怪不得我一直读书很慢，很少，读了一点就不想读，原来我是一直用的学生考试时代的`基础阅读`，这种是最低级的阅读方式，一个字一个字读，漫无目的地读。现在我改用了`检视阅读`和`分析阅读`，不求甚解，跳过了一些无用章节，比如 Java 相关的，测试相关的，所以一个下午就把大半本书给啃下来了，效率十分高。另外，书的配图很棒\n\n我只挑自己仍需注意的点记录下来，并结合自己的经验谈谈。而一些最基本的，SRP、DRY 等是老生常谈的问题，就不赘述。特别是 DRY，懂的人很多，敲代码的时候能想到的人就少了，想到并且做好的人就更少。工程里面经常看到这段代码复制过来，那段代码复制过去，是最恶心的。这个原则值得用一生去践行、体会并提高\n\n# 前言\n> 阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。\n\n我是第二种。希望有一天，我写的代码，能成为一种艺术\n\n> 衡量代码质量的唯一有效标准： WTF/min\n\n![](http://images.cnitblog.com/blog/435441/201301/29202423-4786f70c83254e0f88aa1c31110e1bd5.jpg)\n\n《代码整洁之道》最有道理的一句话，即代码阅读者每一分钟爆出的\"What The Fuck\"数量，哈哈哈\n\n# 使用可搜索的名称\n> 名称长短应与其作用域大小相对应\n\n比如，在一个简单的 for 循环里，使用简单的 i 来命名下标就很足够了；而如果一个变量的作用域很大，那么其命名应该易于搜索（名称长是为了易于搜索）\n\n# 不要写多余的注释，别让你写的注释比看代码还累\n> 与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那段糟糕的代码\n\n确实，这点我做得不够，有时候为函数的声明写的注释太多，需要改进\n\n# 如果可以，尽量别注释代码\n> 其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除\n\n一方面，我看到注释掉的代码真的很讨厌，因为我是极简主义，能少写一行代码甚至一个空格就少写，一坨被注释的代码放在那里会影响阅读体验\n\n但是另一方面我又不完全同意这个观点，作者说现在已经有版本管理，所以没必要保留注释的代码，但是谁修改代码的时候没事会去查看之前的版本呢？比如，上次我想为频道列表页添加缓存逻辑，但是发现之前有人加过了，但是被注释了，询问之后才发现直接为这个页面添加缓存是有坑的，于是这次添加缓存就顺利绕过了这个坑。那么如果没有这段注释的代码，我可能就会直接跳进这个坑了，因为我修改之前并不可能漫无目的去查看 SVN\n\n# 不要刻意去水平对齐\n刻意的水平像是在强调不重要的东西，分散读者注意力\n\n```objc\n@property (nonatomic, assign) int                   leftNum;\n@property (nonatomic, copy)   NSString              *dataKey;\n@property (nonatomic, retain) QLJCEShareItem        *shareItem;\n@property (nonatomic, retain) QLJCEONAPosterTitle   *tips;\n```\n\n下面这段代码更好，因为注意力能更集中在变量的类型上\n\n```objc\n@property (nonatomic, assign) int leftNum;\n@property (nonatomic, copy) NSString *dataKey;\n@property (nonatomic, retain) QLJCEShareItem *shareItem;\n@property (nonatomic, retain) QLJCEONAPosterTitle *tips;\n```\n\n# 要编写简洁的代码，必须先写肮脏的代码，然后再清理它\n问题是写完了肮脏的可运行的代码之后，别着急开始下一个任务而忘记改进它\n\n# 使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\n先看一个例子\n\n```objc\n- (void)pay:(BOOL)isVip\n{\n    // 通用代码\n\n    if (isVip)\n    {\n        // VIP处理代码\n    }\n    else\n    {\n        // 普通成员处理代码\n    }\n}\n```\n首先作者认为这种代码不好，因为调用的时候应该去记住传递的 BOOL 代表什么意思，应该改为以下这种\n\n```objc\n- (void)pay\n{\n    // 通用代码\n\n    if ([self isVip])\n    {\n        // Vip处理代码\n    }\n    else\n    {\n        // 普通成员处理代码\n    }\n}\n```\n或这种\n\n```objc\n- (void)vipPay\n{\n    // 通用代码\n\n    // VIP处理代码\n}\n\n- (void)commonPay\n{\n    // 通用代码\n\n    // 普通成员处理代码\n}\n```\n首先方法1并不是处处可行，因为对于 Vip 的判断是否合适放在本类要根据具体情况讨论，合适则方法1可行\n\n而方法2我不敢苟同，因为这首先违背了一种重要的原则——DRY，通用代码在2处地方重复，维护起来十分恶心\n\n同时，在 IDE 日益强大的今天，多写一个参数并不对程序员的记忆有所挑战，即使有，也比重复代码好\n\n# 代码要尽可能具有表达力\n\n```objc\nif (curTime >= startTime && curTime <= endTime && !hasShown)    // 是否应该展示\n{\n\n}\n```\n应该处理为下面这种，这比写注释好\n\n```objc\n- (BOOL)shouldShow\n{\n    return (curTime >= startTime && curTime <= endTime && !hasShown);\n}\n\nif ([self shouldShow])\n{\n\n}\n```\n\n# 得墨忒耳定律（最少了解原理）\nA 有一个属性叫 B，B 有一个属性叫 C，C 有一个 doSomething 的函数。现在需要在 A 里面调用 C 的函数。有以下2种写法\n\n方法1，B 把属性 C 暴露在头文件，让 A 可以直接读取\n\n```objc\n// A.m\n[self.b.c doSomething];\n\n// B.h\n@property (nonatomic, strong) C *c;\n\n// C.h\n- (void)doSomething;\n\n// C.m\n- (void)doSomething\n{\n    NSLog(@\"Hello World!\");\n}\n```\n\n方法2，B 把 C 中的函数封装成接口提供给外部使用\n\n```objc\n// A.m\n[self.b doSomething];\n\n// B.h\n- (void)doSomething;\n\n// B.m\n- (void)doSomething\n{\n    [self.c doSomething];\n}\n\n// C.h\n- (void)doSomething;\n\n// C.m\n- (void)doSomething\n{\n    NSLog(@\"Hello World!\");\n}\n```\n\n曾经，我不知道方法1和方法2孰优孰劣，甚至更倾向于方法1，因为代码量更少，但读了这本书后，我明白了，方法2更好，为什么？\n\n+ 方法1违背了`得墨忒耳定律`，C 不是 A 的属性，而 A 居然要去了解 C 里面的函数\n+ 假如不止A，还有A1,A2,A3...直接调用了 C 的函数，那么有一天，当 C 修改 doSomething 这个函数名，或者想在 B 和 C 之间再添加一个类 D 的时候，此时方法1就需要修改很多地方，而方法2只需要修改 B 文件","slug":"神在细节之中","published":1,"updated":"2017-12-17T09:35:05.000Z","comments":1,"layout":"post","link":"","_id":"cje87q09g000ptjqwzd5y18va","content":"<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>这其实是《代码整洁之道》的学习笔记，起了一个看起来很厉害的名字。</p>\n<p>之前读过《如何阅读一本书》，但是读完之后还是没什么收获，只懂读，不懂消化。前几天看了这篇文章<a href=\"http://www.jianshu.com/p/b780ba99abd6\" target=\"_blank\" rel=\"noopener\">《一年读100本书的技能，你1分钟就能学得会》</a>，有恍然大悟状。怪不得我一直读书很慢，很少，读了一点就不想读，原来我是一直用的学生考试时代的<code>基础阅读</code>，这种是最低级的阅读方式，一个字一个字读，漫无目的地读。现在我改用了<code>检视阅读</code>和<code>分析阅读</code>，不求甚解，跳过了一些无用章节，比如 Java 相关的，测试相关的，所以一个下午就把大半本书给啃下来了，效率十分高。另外，书的配图很棒</p>\n<p>我只挑自己仍需注意的点记录下来，并结合自己的经验谈谈。而一些最基本的，SRP、DRY 等是老生常谈的问题，就不赘述。特别是 DRY，懂的人很多，敲代码的时候能想到的人就少了，想到并且做好的人就更少。工程里面经常看到这段代码复制过来，那段代码复制过去，是最恶心的。这个原则值得用一生去践行、体会并提高</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。</p>\n</blockquote>\n<p>我是第二种。希望有一天，我写的代码，能成为一种艺术</p>\n<blockquote>\n<p>衡量代码质量的唯一有效标准： WTF/min</p>\n</blockquote>\n<p><img src=\"http://images.cnitblog.com/blog/435441/201301/29202423-4786f70c83254e0f88aa1c31110e1bd5.jpg\" alt=\"\"></p>\n<p>《代码整洁之道》最有道理的一句话，即代码阅读者每一分钟爆出的”What The Fuck”数量，哈哈哈</p>\n<h1 id=\"使用可搜索的名称\"><a href=\"#使用可搜索的名称\" class=\"headerlink\" title=\"使用可搜索的名称\"></a>使用可搜索的名称</h1><blockquote>\n<p>名称长短应与其作用域大小相对应</p>\n</blockquote>\n<p>比如，在一个简单的 for 循环里，使用简单的 i 来命名下标就很足够了；而如果一个变量的作用域很大，那么其命名应该易于搜索（名称长是为了易于搜索）</p>\n<h1 id=\"不要写多余的注释，别让你写的注释比看代码还累\"><a href=\"#不要写多余的注释，别让你写的注释比看代码还累\" class=\"headerlink\" title=\"不要写多余的注释，别让你写的注释比看代码还累\"></a>不要写多余的注释，别让你写的注释比看代码还累</h1><blockquote>\n<p>与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那段糟糕的代码</p>\n</blockquote>\n<p>确实，这点我做得不够，有时候为函数的声明写的注释太多，需要改进</p>\n<h1 id=\"如果可以，尽量别注释代码\"><a href=\"#如果可以，尽量别注释代码\" class=\"headerlink\" title=\"如果可以，尽量别注释代码\"></a>如果可以，尽量别注释代码</h1><blockquote>\n<p>其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除</p>\n</blockquote>\n<p>一方面，我看到注释掉的代码真的很讨厌，因为我是极简主义，能少写一行代码甚至一个空格就少写，一坨被注释的代码放在那里会影响阅读体验</p>\n<p>但是另一方面我又不完全同意这个观点，作者说现在已经有版本管理，所以没必要保留注释的代码，但是谁修改代码的时候没事会去查看之前的版本呢？比如，上次我想为频道列表页添加缓存逻辑，但是发现之前有人加过了，但是被注释了，询问之后才发现直接为这个页面添加缓存是有坑的，于是这次添加缓存就顺利绕过了这个坑。那么如果没有这段注释的代码，我可能就会直接跳进这个坑了，因为我修改之前并不可能漫无目的去查看 SVN</p>\n<h1 id=\"不要刻意去水平对齐\"><a href=\"#不要刻意去水平对齐\" class=\"headerlink\" title=\"不要刻意去水平对齐\"></a>不要刻意去水平对齐</h1><p>刻意的水平像是在强调不重要的东西，分散读者注意力</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span>                   leftNum;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>)   <span class=\"built_in\">NSString</span>              *dataKey;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEShareItem        *shareItem;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEONAPosterTitle   *tips;</span><br></pre></td></tr></table></figure>\n<p>下面这段代码更好，因为注意力能更集中在变量的类型上</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span> leftNum;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *dataKey;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEShareItem *shareItem;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEONAPosterTitle *tips;</span><br></pre></td></tr></table></figure>\n<h1 id=\"要编写简洁的代码，必须先写肮脏的代码，然后再清理它\"><a href=\"#要编写简洁的代码，必须先写肮脏的代码，然后再清理它\" class=\"headerlink\" title=\"要编写简洁的代码，必须先写肮脏的代码，然后再清理它\"></a>要编写简洁的代码，必须先写肮脏的代码，然后再清理它</h1><p>问题是写完了肮脏的可运行的代码之后，别着急开始下一个任务而忘记改进它</p>\n<h1 id=\"使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\"><a href=\"#使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\" class=\"headerlink\" title=\"使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\"></a>使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</h1><p>先看一个例子</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pay:(<span class=\"built_in\">BOOL</span>)isVip</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isVip)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// VIP处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先作者认为这种代码不好，因为调用的时候应该去记住传递的 BOOL 代表什么意思，应该改为以下这种</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isVip])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Vip处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或这种</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)vipPay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// VIP处理代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)commonPay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先方法1并不是处处可行，因为对于 Vip 的判断是否合适放在本类要根据具体情况讨论，合适则方法1可行</p>\n<p>而方法2我不敢苟同，因为这首先违背了一种重要的原则——DRY，通用代码在2处地方重复，维护起来十分恶心</p>\n<p>同时，在 IDE 日益强大的今天，多写一个参数并不对程序员的记忆有所挑战，即使有，也比重复代码好</p>\n<h1 id=\"代码要尽可能具有表达力\"><a href=\"#代码要尽可能具有表达力\" class=\"headerlink\" title=\"代码要尽可能具有表达力\"></a>代码要尽可能具有表达力</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (curTime &gt;= startTime &amp;&amp; curTime &lt;= endTime &amp;&amp; !hasShown)    <span class=\"comment\">// 是否应该展示</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>应该处理为下面这种，这比写注释好</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)shouldShow</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (curTime &gt;= startTime &amp;&amp; curTime &lt;= endTime &amp;&amp; !hasShown);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> shouldShow])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"得墨忒耳定律（最少了解原理）\"><a href=\"#得墨忒耳定律（最少了解原理）\" class=\"headerlink\" title=\"得墨忒耳定律（最少了解原理）\"></a>得墨忒耳定律（最少了解原理）</h1><p>A 有一个属性叫 B，B 有一个属性叫 C，C 有一个 doSomething 的函数。现在需要在 A 里面调用 C 的函数。有以下2种写法</p>\n<p>方法1，B 把属性 C 暴露在头文件，让 A 可以直接读取</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.m</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.b.c doSomething];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) C *c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello World!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法2，B 把 C 中的函数封装成接口提供给外部使用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.m</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.b doSomething];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.c doSomething];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello World!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>曾经，我不知道方法1和方法2孰优孰劣，甚至更倾向于方法1，因为代码量更少，但读了这本书后，我明白了，方法2更好，为什么？</p>\n<ul>\n<li>方法1违背了<code>得墨忒耳定律</code>，C 不是 A 的属性，而 A 居然要去了解 C 里面的函数</li>\n<li>假如不止A，还有A1,A2,A3…直接调用了 C 的函数，那么有一天，当 C 修改 doSomething 这个函数名，或者想在 B 和 C 之间再添加一个类 D 的时候，此时方法1就需要修改很多地方，而方法2只需要修改 B 文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>这其实是《代码整洁之道》的学习笔记，起了一个看起来很厉害的名字。</p>\n<p>之前读过《如何阅读一本书》，但是读完之后还是没什么收获，只懂读，不懂消化。前几天看了这篇文章<a href=\"http://www.jianshu.com/p/b780ba99abd6\" target=\"_blank\" rel=\"noopener\">《一年读100本书的技能，你1分钟就能学得会》</a>，有恍然大悟状。怪不得我一直读书很慢，很少，读了一点就不想读，原来我是一直用的学生考试时代的<code>基础阅读</code>，这种是最低级的阅读方式，一个字一个字读，漫无目的地读。现在我改用了<code>检视阅读</code>和<code>分析阅读</code>，不求甚解，跳过了一些无用章节，比如 Java 相关的，测试相关的，所以一个下午就把大半本书给啃下来了，效率十分高。另外，书的配图很棒</p>\n<p>我只挑自己仍需注意的点记录下来，并结合自己的经验谈谈。而一些最基本的，SRP、DRY 等是老生常谈的问题，就不赘述。特别是 DRY，懂的人很多，敲代码的时候能想到的人就少了，想到并且做好的人就更少。工程里面经常看到这段代码复制过来，那段代码复制过去，是最恶心的。这个原则值得用一生去践行、体会并提高</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。</p>\n</blockquote>\n<p>我是第二种。希望有一天，我写的代码，能成为一种艺术</p>\n<blockquote>\n<p>衡量代码质量的唯一有效标准： WTF/min</p>\n</blockquote>\n<p><img src=\"http://images.cnitblog.com/blog/435441/201301/29202423-4786f70c83254e0f88aa1c31110e1bd5.jpg\" alt=\"\"></p>\n<p>《代码整洁之道》最有道理的一句话，即代码阅读者每一分钟爆出的”What The Fuck”数量，哈哈哈</p>\n<h1 id=\"使用可搜索的名称\"><a href=\"#使用可搜索的名称\" class=\"headerlink\" title=\"使用可搜索的名称\"></a>使用可搜索的名称</h1><blockquote>\n<p>名称长短应与其作用域大小相对应</p>\n</blockquote>\n<p>比如，在一个简单的 for 循环里，使用简单的 i 来命名下标就很足够了；而如果一个变量的作用域很大，那么其命名应该易于搜索（名称长是为了易于搜索）</p>\n<h1 id=\"不要写多余的注释，别让你写的注释比看代码还累\"><a href=\"#不要写多余的注释，别让你写的注释比看代码还累\" class=\"headerlink\" title=\"不要写多余的注释，别让你写的注释比看代码还累\"></a>不要写多余的注释，别让你写的注释比看代码还累</h1><blockquote>\n<p>与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那段糟糕的代码</p>\n</blockquote>\n<p>确实，这点我做得不够，有时候为函数的声明写的注释太多，需要改进</p>\n<h1 id=\"如果可以，尽量别注释代码\"><a href=\"#如果可以，尽量别注释代码\" class=\"headerlink\" title=\"如果可以，尽量别注释代码\"></a>如果可以，尽量别注释代码</h1><blockquote>\n<p>其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除</p>\n</blockquote>\n<p>一方面，我看到注释掉的代码真的很讨厌，因为我是极简主义，能少写一行代码甚至一个空格就少写，一坨被注释的代码放在那里会影响阅读体验</p>\n<p>但是另一方面我又不完全同意这个观点，作者说现在已经有版本管理，所以没必要保留注释的代码，但是谁修改代码的时候没事会去查看之前的版本呢？比如，上次我想为频道列表页添加缓存逻辑，但是发现之前有人加过了，但是被注释了，询问之后才发现直接为这个页面添加缓存是有坑的，于是这次添加缓存就顺利绕过了这个坑。那么如果没有这段注释的代码，我可能就会直接跳进这个坑了，因为我修改之前并不可能漫无目的去查看 SVN</p>\n<h1 id=\"不要刻意去水平对齐\"><a href=\"#不要刻意去水平对齐\" class=\"headerlink\" title=\"不要刻意去水平对齐\"></a>不要刻意去水平对齐</h1><p>刻意的水平像是在强调不重要的东西，分散读者注意力</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span>                   leftNum;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>)   <span class=\"built_in\">NSString</span>              *dataKey;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEShareItem        *shareItem;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEONAPosterTitle   *tips;</span><br></pre></td></tr></table></figure>\n<p>下面这段代码更好，因为注意力能更集中在变量的类型上</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span> leftNum;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *dataKey;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEShareItem *shareItem;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) QLJCEONAPosterTitle *tips;</span><br></pre></td></tr></table></figure>\n<h1 id=\"要编写简洁的代码，必须先写肮脏的代码，然后再清理它\"><a href=\"#要编写简洁的代码，必须先写肮脏的代码，然后再清理它\" class=\"headerlink\" title=\"要编写简洁的代码，必须先写肮脏的代码，然后再清理它\"></a>要编写简洁的代码，必须先写肮脏的代码，然后再清理它</h1><p>问题是写完了肮脏的可运行的代码之后，别着急开始下一个任务而忘记改进它</p>\n<h1 id=\"使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\"><a href=\"#使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\" class=\"headerlink\" title=\"使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\"></a>使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</h1><p>先看一个例子</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pay:(<span class=\"built_in\">BOOL</span>)isVip</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isVip)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// VIP处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先作者认为这种代码不好，因为调用的时候应该去记住传递的 BOOL 代表什么意思，应该改为以下这种</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isVip])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Vip处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或这种</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)vipPay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// VIP处理代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)commonPay</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通用代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通成员处理代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先方法1并不是处处可行，因为对于 Vip 的判断是否合适放在本类要根据具体情况讨论，合适则方法1可行</p>\n<p>而方法2我不敢苟同，因为这首先违背了一种重要的原则——DRY，通用代码在2处地方重复，维护起来十分恶心</p>\n<p>同时，在 IDE 日益强大的今天，多写一个参数并不对程序员的记忆有所挑战，即使有，也比重复代码好</p>\n<h1 id=\"代码要尽可能具有表达力\"><a href=\"#代码要尽可能具有表达力\" class=\"headerlink\" title=\"代码要尽可能具有表达力\"></a>代码要尽可能具有表达力</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (curTime &gt;= startTime &amp;&amp; curTime &lt;= endTime &amp;&amp; !hasShown)    <span class=\"comment\">// 是否应该展示</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>应该处理为下面这种，这比写注释好</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)shouldShow</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (curTime &gt;= startTime &amp;&amp; curTime &lt;= endTime &amp;&amp; !hasShown);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> shouldShow])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"得墨忒耳定律（最少了解原理）\"><a href=\"#得墨忒耳定律（最少了解原理）\" class=\"headerlink\" title=\"得墨忒耳定律（最少了解原理）\"></a>得墨忒耳定律（最少了解原理）</h1><p>A 有一个属性叫 B，B 有一个属性叫 C，C 有一个 doSomething 的函数。现在需要在 A 里面调用 C 的函数。有以下2种写法</p>\n<p>方法1，B 把属性 C 暴露在头文件，让 A 可以直接读取</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.m</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.b.c doSomething];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) C *c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello World!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法2，B 把 C 中的函数封装成接口提供给外部使用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.m</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.b doSomething];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.c doSomething];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.h</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doSomething</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello World!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>曾经，我不知道方法1和方法2孰优孰劣，甚至更倾向于方法1，因为代码量更少，但读了这本书后，我明白了，方法2更好，为什么？</p>\n<ul>\n<li>方法1违背了<code>得墨忒耳定律</code>，C 不是 A 的属性，而 A 居然要去了解 C 里面的函数</li>\n<li>假如不止A，还有A1,A2,A3…直接调用了 C 的函数，那么有一天，当 C 修改 doSomething 这个函数名，或者想在 B 和 C 之间再添加一个类 D 的时候，此时方法1就需要修改很多地方，而方法2只需要修改 B 文件</li>\n</ul>\n","sticky":0},{"title":"那些年，我看过的","date":"2013-02-28T16:00:00.000Z","description":"我的书籍/电影/电视剧/动漫列表","photos":["images/girl.jpg"],"_content":"\n# 二零一八年\n## 一月\n+ 《神秘巨星》\n+ 《无问西东》\n+ 《奇门遁甲》\n\n## 二月\n+ 《唐人街探案2》\n+ 《活着本来单纯》\n \n# 二零一七年\n## 一月\n+ 《鲨滩》\n+ 《三少爷的剑》\n+ 《西游伏妖篇》\n+ 《乘风破浪》\n\n## 二月\n+ 《你的名字》\n\n## 六月\n+ 《非暴力沟通》\n\n## 七月\n+ 《假面饭店》\n+ 《悟空传》\n+ 《小黄人3》\n+ 《嫌疑人x的献身》\n\n## 八月\n+ 《战狼2》\n\n## 九月\n+ 《太空旅客》4\n+ 《目击者之追凶》4\n+ 《时光倒流的女孩》3\n+ 《猩球崛起3》3\n\n## 十月\n+ 《看不见的客人》4\n+ 《羞羞的铁拳》4\n+ 《天才枪手》5\n\n## 十一月\n+ 《地球脉动2》\n+ 《缝纫机乐队》 3\n+ 《哈利波特与魔法石》\n\n## 十二月\n+ 《少有人走的路》\n+ 《解忧杂货店》\n\n# 二零一六年\n## 一月\n+ 《像素大战》4星 满满的都是回忆。萌。彩蛋超赞。\n+ 《亲爱的》\n+ 《心迷宫》\n+ 《越女剑》\n+ 《枭雄》\n\n## 二月\n+ 《火星救援》\n+ 《扑克王》\n+ 《赌侠大战拉斯维加斯》\n+ 《我的少女时代》\n+ 《国产凌凌漆》\n+ 《美人鱼》\n+ 《时间的朋友2015》\n+ 《荒蛮故事》\n\n## 三月\n+ 《伟大的隐藏者》4 好喜欢里面东九生活的小村子，让我想到了童年。韩国的电影，却没有故意吹捧自己的国家。\n\n## 五月\n+ 《火锅英雄》\n+ 《美国队长3》\n+ 《信号》\n+ 《乒乓侠》\n\n## 六月\n+ 《功夫熊猫3》\n+ 《家和万事兴之我爱我车》\n+ 《明日世界》\n+ 《独立日2》\n+ 《澳门风云3》\n\n## 七月\n+ 《大鱼海棠》\n+ 《六扇门》\n+ 《完美陌生人》意大利 b站看的，弹幕笑死，结局不错\n+ 《代码整洁之道》\n+ 《妮玛的唠嗑馆》\n+ 《安妮和王小明第一季》安妮也是金中的，真的把我带回到我的金中生活，怀念\n+ 《安妮和王小明第二季》\n+ 《妮玛！这就是大学！》\n\n## 八月\n+ 《一起同过窗》\n+ 《三毛流浪记》（漫画）\n+ 《余罪 第一季》\n\n## 九月\n+ 《龙珠Z：复活的F》\n+ 《叶问3》\n+ 《人间失格》\n+ 《余罪 第二季》\n+ 《招魂2》\n+ 《小白理财第一课》\n+ 《五次方谋杀》\n+ 《绝对小孩》\n+ 《One of Us》\n\n## 十月\n+ 《湄公河行动》\n+ 《选老顶》\n+ 《绝对小孩2》\n+ 《刑警兄弟》\n+ 《七堂极简物理课》\n+ 《嫌疑人X的献身》\n+ 《送你一颗子弹》\n+ 《三观易碎》\n+ 《把时间当做朋友》\n\n# 十一月\n+ 《不正常人类症候群》\n+ 《荒岛余生》\n\n# 二零一五年\n## 一月\n+ 《十三度凶间》\n+ 《恐怖直播》\n+ 《鹿鼎记》\n+ 《鹿鼎记2神龙教》\n+ 《名侦探柯南剧场版6 贝克街的亡灵》\n+ 《最佳出价》\n+ 《宿敌》\n+ 《在我入睡前》\n+ 《源代码》\n+ 《牛奶可乐经济学》\n+ 《智取威虎山》\n\n## 二月\n+ 《K-PAX》\n+ 《十万个冷笑话》电影\n+ 《爱情公寓4》完结\n+ 《天降之物》\n+ 《匆匆那年》\n+ 《无声言证》\n+ 《时空恋旅人》\n+ 《暴走恐怖故事》第一季\n+ 《Premature》\n+ 《地球回音》\n\n## 三月\n+ 《穹顶之下》\n+ 《等一个人咖啡》\n+ 《解忧杂货店》\n+ 《我的互联网方法论》\n+ 《超能陆战队》\n+ 《爆裂鼓手》\n+ 《黑洞频率》\n\n## 四月\n+ 《哆啦A梦：伴我同行》\n\n## 五月\n+ 《生人活祭》\n+ 《伊甸湖》\n\n## 六月\n+ 《侏罗纪世界》\n+ 《侏罗纪公园》\n+ 《名侦探狄仁杰》\n+ 《澳门风云2》\n+ 《左耳》\n+ 《两个月亮》\n+ 《附身》\n+ 《海洋之歌》\n\n## 七月\n+ 《名侦探柯南剧场版 异次元的狙击手》\n+ 《五十度灰》\n+ 《速度与激情7》\n+ 《小森林·夏秋篇》\n+ 《小森林·冬春篇》\n+ 《捉妖记》\n+ 《煎饼侠》\n\n## 八月\n+ 《道士下山》\n+ 《笑傲江湖》(书)\n+ 《笑傲江湖》(电视剧)\n\n## 九月\n+ 《港囧》\n\n## 十月\n+ 《我是路人甲》 \n+ 《这个男人来自地球》 \n+ 《决战紫禁之巅》 \n+ 《Programming with Objective-C》\n+ 《画江湖之不良人》\n\n## 十一月\n+ 《夏洛特烦恼》\n+ 《暗时间》\n+ 《荒庙》 \n\n## 十二月\n+ 《尘曲》\n+ 《移动迷宫》\n+ 《西游记之大圣归来》\n+ 《消失的凶手》\n+ 《真实魔鬼游戏》\n\n# 二零一四年\n## 三月\n+ 《死亡笔记》\n\n## 四月\n+ 《同桌的你》\n+ 《零下一度》\n+ 《逆光飞翔》\n+ 《古墓丽影》\n+ 《古墓丽影2》\n+ 《麦兜响当当》\n\n## 五月\n+ 《麦兜故事》\n+ 《C++程序设计》\n+ 《潘金莲之前世今生》\n+ 《警察故事2013》\n+ 《你是下一个》\n+ 《X战警：逆转未来》\n+ 《百年孤独》\n \n## 六月\n+ 《六福喜事》\n+ 《X战警：第一战》\n+ 《X战警Ⅰ》\n+ 《c++基础教程》\n+ 《杂的文》\n+ 《爆笑角斗士》\n+ 《天才在左，疯子在右》\n+ 《X战警Ⅱ》\n+ 《X战警Ⅲ》\n+ 《金刚狼》\n+ 《金刚狼Ⅱ》\n+ 《生死停留》\n+ 《三重门》\n+ 《警察故事2013》\n\n## 七月\n+ 《澳门风云》\n+ 《无人区》\n+ 《十二生肖》\n+ 《变形金刚4：绝迹重生》\n+ 《进击的巨人》\n+ 《狄仁杰之神都龙王》\n+ 《后会无期》\n+ 《秒速5厘米》\n\n## 八月\n+ 《志明与春娇》\n\n## 九月\n+ 《惊天魔盗团》\n+ 《猩球崛起2》\n+ 《安德的游戏》\n+ 《春娇与志明》\n+ 《分歧者——异类崛起》\n+ 《催眠大师》\n+ 《绣春刀》\n+ 《明日边缘》\n\n## 十月\n+ 《生活启示录》\n+ 《归来》\n+ 《被偷走的那五年》\n+ 《牯岭街少年杀人事件》\n+ 《触不可及》\n+ 《平凡的世界Ⅰ》\n+ 《猎头游戏》\n+ 《黑暗面》\n+ 《控方证人》\n+ 《一级恐惧》\n+ 《飞狐外传》\n+ 《四大名捕大结局》\n+ 《平凡的世界Ⅱ》\n+ 《决战猩球》\n+ 《那夜凌晨 我坐上旺角开往大埔的红van》\n+ 《惊声尖叫》\n+ 《平凡的世界Ⅲ》\n\n## 十一月\n+ 《银河护卫队》\n+ 《失踪罪》\n+ 《早晨从中午开始》\n+ 《连城诀》\n+ 《透明人》\n+ 《透明人2》\n+ 《魔女嘉莉》\n+ 《鬼子来了》\n+ 《太阳照常升起》\n+ 《1988——我想和这个世界谈谈》\n+ 《十七岁的单车》\n+ 《一个人的好天气》\n+ 《心花路放》\n+ 《侧耳倾听》\n+ 《林中小屋》\n+ 《彗星来的那一夜》\n+ 《In Your Eyes》\n+ 《The One I Love》\n+ 《哆啦A梦：新·大雄的大魔境》\n+ 《沙僧吐槽日记》\n+ 《大地飞鹰》\n+ 《极速前进》第1-4期\n+ 《寒战》\n\n## 十二月\n+ 《极速前进》第5-10期\n+ 《关于时间旅行的热门问题》\n+ 《超体》\n+ 《楚留香传奇之血海飘香》\n+ 《麦兜菠萝油王子》\n+ 《星际穿越》\n+ 《月亮》\n+ 《不惧风暴》\n+ 《理科的人Ⅰ》\n+ 《The Giver》\n+ 《楚留香传奇之大沙漠》\n+ 《一步之遥》\n+ 《黄飞鸿之英雄有梦》\n+ 《新大头儿子和小头爸爸之秘密计划》\n+ 《马达加斯加的企鹅》\n+ 《刺杀金正恩》\n+ 《名侦探柯南剧场版1 引爆摩天楼》\n+ 《一个人的武林》\n+ 《弹窗惊魂》\n+ 《楚留香传奇之画眉鸟》","source":"_posts/那些年，我看过的.md","raw":"---\ntitle: 那些年，我看过的\ndate: 2013-3-1\ndescription: 我的书籍/电影/电视剧/动漫列表\ncategories:\n- 代码之外 \nphotos: images/girl.jpg\n---\n\n# 二零一八年\n## 一月\n+ 《神秘巨星》\n+ 《无问西东》\n+ 《奇门遁甲》\n\n## 二月\n+ 《唐人街探案2》\n+ 《活着本来单纯》\n \n# 二零一七年\n## 一月\n+ 《鲨滩》\n+ 《三少爷的剑》\n+ 《西游伏妖篇》\n+ 《乘风破浪》\n\n## 二月\n+ 《你的名字》\n\n## 六月\n+ 《非暴力沟通》\n\n## 七月\n+ 《假面饭店》\n+ 《悟空传》\n+ 《小黄人3》\n+ 《嫌疑人x的献身》\n\n## 八月\n+ 《战狼2》\n\n## 九月\n+ 《太空旅客》4\n+ 《目击者之追凶》4\n+ 《时光倒流的女孩》3\n+ 《猩球崛起3》3\n\n## 十月\n+ 《看不见的客人》4\n+ 《羞羞的铁拳》4\n+ 《天才枪手》5\n\n## 十一月\n+ 《地球脉动2》\n+ 《缝纫机乐队》 3\n+ 《哈利波特与魔法石》\n\n## 十二月\n+ 《少有人走的路》\n+ 《解忧杂货店》\n\n# 二零一六年\n## 一月\n+ 《像素大战》4星 满满的都是回忆。萌。彩蛋超赞。\n+ 《亲爱的》\n+ 《心迷宫》\n+ 《越女剑》\n+ 《枭雄》\n\n## 二月\n+ 《火星救援》\n+ 《扑克王》\n+ 《赌侠大战拉斯维加斯》\n+ 《我的少女时代》\n+ 《国产凌凌漆》\n+ 《美人鱼》\n+ 《时间的朋友2015》\n+ 《荒蛮故事》\n\n## 三月\n+ 《伟大的隐藏者》4 好喜欢里面东九生活的小村子，让我想到了童年。韩国的电影，却没有故意吹捧自己的国家。\n\n## 五月\n+ 《火锅英雄》\n+ 《美国队长3》\n+ 《信号》\n+ 《乒乓侠》\n\n## 六月\n+ 《功夫熊猫3》\n+ 《家和万事兴之我爱我车》\n+ 《明日世界》\n+ 《独立日2》\n+ 《澳门风云3》\n\n## 七月\n+ 《大鱼海棠》\n+ 《六扇门》\n+ 《完美陌生人》意大利 b站看的，弹幕笑死，结局不错\n+ 《代码整洁之道》\n+ 《妮玛的唠嗑馆》\n+ 《安妮和王小明第一季》安妮也是金中的，真的把我带回到我的金中生活，怀念\n+ 《安妮和王小明第二季》\n+ 《妮玛！这就是大学！》\n\n## 八月\n+ 《一起同过窗》\n+ 《三毛流浪记》（漫画）\n+ 《余罪 第一季》\n\n## 九月\n+ 《龙珠Z：复活的F》\n+ 《叶问3》\n+ 《人间失格》\n+ 《余罪 第二季》\n+ 《招魂2》\n+ 《小白理财第一课》\n+ 《五次方谋杀》\n+ 《绝对小孩》\n+ 《One of Us》\n\n## 十月\n+ 《湄公河行动》\n+ 《选老顶》\n+ 《绝对小孩2》\n+ 《刑警兄弟》\n+ 《七堂极简物理课》\n+ 《嫌疑人X的献身》\n+ 《送你一颗子弹》\n+ 《三观易碎》\n+ 《把时间当做朋友》\n\n# 十一月\n+ 《不正常人类症候群》\n+ 《荒岛余生》\n\n# 二零一五年\n## 一月\n+ 《十三度凶间》\n+ 《恐怖直播》\n+ 《鹿鼎记》\n+ 《鹿鼎记2神龙教》\n+ 《名侦探柯南剧场版6 贝克街的亡灵》\n+ 《最佳出价》\n+ 《宿敌》\n+ 《在我入睡前》\n+ 《源代码》\n+ 《牛奶可乐经济学》\n+ 《智取威虎山》\n\n## 二月\n+ 《K-PAX》\n+ 《十万个冷笑话》电影\n+ 《爱情公寓4》完结\n+ 《天降之物》\n+ 《匆匆那年》\n+ 《无声言证》\n+ 《时空恋旅人》\n+ 《暴走恐怖故事》第一季\n+ 《Premature》\n+ 《地球回音》\n\n## 三月\n+ 《穹顶之下》\n+ 《等一个人咖啡》\n+ 《解忧杂货店》\n+ 《我的互联网方法论》\n+ 《超能陆战队》\n+ 《爆裂鼓手》\n+ 《黑洞频率》\n\n## 四月\n+ 《哆啦A梦：伴我同行》\n\n## 五月\n+ 《生人活祭》\n+ 《伊甸湖》\n\n## 六月\n+ 《侏罗纪世界》\n+ 《侏罗纪公园》\n+ 《名侦探狄仁杰》\n+ 《澳门风云2》\n+ 《左耳》\n+ 《两个月亮》\n+ 《附身》\n+ 《海洋之歌》\n\n## 七月\n+ 《名侦探柯南剧场版 异次元的狙击手》\n+ 《五十度灰》\n+ 《速度与激情7》\n+ 《小森林·夏秋篇》\n+ 《小森林·冬春篇》\n+ 《捉妖记》\n+ 《煎饼侠》\n\n## 八月\n+ 《道士下山》\n+ 《笑傲江湖》(书)\n+ 《笑傲江湖》(电视剧)\n\n## 九月\n+ 《港囧》\n\n## 十月\n+ 《我是路人甲》 \n+ 《这个男人来自地球》 \n+ 《决战紫禁之巅》 \n+ 《Programming with Objective-C》\n+ 《画江湖之不良人》\n\n## 十一月\n+ 《夏洛特烦恼》\n+ 《暗时间》\n+ 《荒庙》 \n\n## 十二月\n+ 《尘曲》\n+ 《移动迷宫》\n+ 《西游记之大圣归来》\n+ 《消失的凶手》\n+ 《真实魔鬼游戏》\n\n# 二零一四年\n## 三月\n+ 《死亡笔记》\n\n## 四月\n+ 《同桌的你》\n+ 《零下一度》\n+ 《逆光飞翔》\n+ 《古墓丽影》\n+ 《古墓丽影2》\n+ 《麦兜响当当》\n\n## 五月\n+ 《麦兜故事》\n+ 《C++程序设计》\n+ 《潘金莲之前世今生》\n+ 《警察故事2013》\n+ 《你是下一个》\n+ 《X战警：逆转未来》\n+ 《百年孤独》\n \n## 六月\n+ 《六福喜事》\n+ 《X战警：第一战》\n+ 《X战警Ⅰ》\n+ 《c++基础教程》\n+ 《杂的文》\n+ 《爆笑角斗士》\n+ 《天才在左，疯子在右》\n+ 《X战警Ⅱ》\n+ 《X战警Ⅲ》\n+ 《金刚狼》\n+ 《金刚狼Ⅱ》\n+ 《生死停留》\n+ 《三重门》\n+ 《警察故事2013》\n\n## 七月\n+ 《澳门风云》\n+ 《无人区》\n+ 《十二生肖》\n+ 《变形金刚4：绝迹重生》\n+ 《进击的巨人》\n+ 《狄仁杰之神都龙王》\n+ 《后会无期》\n+ 《秒速5厘米》\n\n## 八月\n+ 《志明与春娇》\n\n## 九月\n+ 《惊天魔盗团》\n+ 《猩球崛起2》\n+ 《安德的游戏》\n+ 《春娇与志明》\n+ 《分歧者——异类崛起》\n+ 《催眠大师》\n+ 《绣春刀》\n+ 《明日边缘》\n\n## 十月\n+ 《生活启示录》\n+ 《归来》\n+ 《被偷走的那五年》\n+ 《牯岭街少年杀人事件》\n+ 《触不可及》\n+ 《平凡的世界Ⅰ》\n+ 《猎头游戏》\n+ 《黑暗面》\n+ 《控方证人》\n+ 《一级恐惧》\n+ 《飞狐外传》\n+ 《四大名捕大结局》\n+ 《平凡的世界Ⅱ》\n+ 《决战猩球》\n+ 《那夜凌晨 我坐上旺角开往大埔的红van》\n+ 《惊声尖叫》\n+ 《平凡的世界Ⅲ》\n\n## 十一月\n+ 《银河护卫队》\n+ 《失踪罪》\n+ 《早晨从中午开始》\n+ 《连城诀》\n+ 《透明人》\n+ 《透明人2》\n+ 《魔女嘉莉》\n+ 《鬼子来了》\n+ 《太阳照常升起》\n+ 《1988——我想和这个世界谈谈》\n+ 《十七岁的单车》\n+ 《一个人的好天气》\n+ 《心花路放》\n+ 《侧耳倾听》\n+ 《林中小屋》\n+ 《彗星来的那一夜》\n+ 《In Your Eyes》\n+ 《The One I Love》\n+ 《哆啦A梦：新·大雄的大魔境》\n+ 《沙僧吐槽日记》\n+ 《大地飞鹰》\n+ 《极速前进》第1-4期\n+ 《寒战》\n\n## 十二月\n+ 《极速前进》第5-10期\n+ 《关于时间旅行的热门问题》\n+ 《超体》\n+ 《楚留香传奇之血海飘香》\n+ 《麦兜菠萝油王子》\n+ 《星际穿越》\n+ 《月亮》\n+ 《不惧风暴》\n+ 《理科的人Ⅰ》\n+ 《The Giver》\n+ 《楚留香传奇之大沙漠》\n+ 《一步之遥》\n+ 《黄飞鸿之英雄有梦》\n+ 《新大头儿子和小头爸爸之秘密计划》\n+ 《马达加斯加的企鹅》\n+ 《刺杀金正恩》\n+ 《名侦探柯南剧场版1 引爆摩天楼》\n+ 《一个人的武林》\n+ 《弹窗惊魂》\n+ 《楚留香传奇之画眉鸟》","slug":"那些年，我看过的","published":1,"updated":"2018-02-26T02:36:54.000Z","comments":1,"layout":"post","link":"","_id":"cje87q09h000stjqwuug38uiq","content":"<h1 id=\"二零一八年\"><a href=\"#二零一八年\" class=\"headerlink\" title=\"二零一八年\"></a>二零一八年</h1><h2 id=\"一月\"><a href=\"#一月\" class=\"headerlink\" title=\"一月\"></a>一月</h2><ul>\n<li>《神秘巨星》</li>\n<li>《无问西东》</li>\n<li>《奇门遁甲》</li>\n</ul>\n<h2 id=\"二月\"><a href=\"#二月\" class=\"headerlink\" title=\"二月\"></a>二月</h2><ul>\n<li>《唐人街探案2》</li>\n<li>《活着本来单纯》</li>\n</ul>\n<h1 id=\"二零一七年\"><a href=\"#二零一七年\" class=\"headerlink\" title=\"二零一七年\"></a>二零一七年</h1><h2 id=\"一月-1\"><a href=\"#一月-1\" class=\"headerlink\" title=\"一月\"></a>一月</h2><ul>\n<li>《鲨滩》</li>\n<li>《三少爷的剑》</li>\n<li>《西游伏妖篇》</li>\n<li>《乘风破浪》</li>\n</ul>\n<h2 id=\"二月-1\"><a href=\"#二月-1\" class=\"headerlink\" title=\"二月\"></a>二月</h2><ul>\n<li>《你的名字》</li>\n</ul>\n<h2 id=\"六月\"><a href=\"#六月\" class=\"headerlink\" title=\"六月\"></a>六月</h2><ul>\n<li>《非暴力沟通》</li>\n</ul>\n<h2 id=\"七月\"><a href=\"#七月\" class=\"headerlink\" title=\"七月\"></a>七月</h2><ul>\n<li>《假面饭店》</li>\n<li>《悟空传》</li>\n<li>《小黄人3》</li>\n<li>《嫌疑人x的献身》</li>\n</ul>\n<h2 id=\"八月\"><a href=\"#八月\" class=\"headerlink\" title=\"八月\"></a>八月</h2><ul>\n<li>《战狼2》</li>\n</ul>\n<h2 id=\"九月\"><a href=\"#九月\" class=\"headerlink\" title=\"九月\"></a>九月</h2><ul>\n<li>《太空旅客》4</li>\n<li>《目击者之追凶》4</li>\n<li>《时光倒流的女孩》3</li>\n<li>《猩球崛起3》3</li>\n</ul>\n<h2 id=\"十月\"><a href=\"#十月\" class=\"headerlink\" title=\"十月\"></a>十月</h2><ul>\n<li>《看不见的客人》4</li>\n<li>《羞羞的铁拳》4</li>\n<li>《天才枪手》5</li>\n</ul>\n<h2 id=\"十一月\"><a href=\"#十一月\" class=\"headerlink\" title=\"十一月\"></a>十一月</h2><ul>\n<li>《地球脉动2》</li>\n<li>《缝纫机乐队》 3</li>\n<li>《哈利波特与魔法石》</li>\n</ul>\n<h2 id=\"十二月\"><a href=\"#十二月\" class=\"headerlink\" title=\"十二月\"></a>十二月</h2><ul>\n<li>《少有人走的路》</li>\n<li>《解忧杂货店》</li>\n</ul>\n<h1 id=\"二零一六年\"><a href=\"#二零一六年\" class=\"headerlink\" title=\"二零一六年\"></a>二零一六年</h1><h2 id=\"一月-2\"><a href=\"#一月-2\" class=\"headerlink\" title=\"一月\"></a>一月</h2><ul>\n<li>《像素大战》4星 满满的都是回忆。萌。彩蛋超赞。</li>\n<li>《亲爱的》</li>\n<li>《心迷宫》</li>\n<li>《越女剑》</li>\n<li>《枭雄》</li>\n</ul>\n<h2 id=\"二月-2\"><a href=\"#二月-2\" class=\"headerlink\" title=\"二月\"></a>二月</h2><ul>\n<li>《火星救援》</li>\n<li>《扑克王》</li>\n<li>《赌侠大战拉斯维加斯》</li>\n<li>《我的少女时代》</li>\n<li>《国产凌凌漆》</li>\n<li>《美人鱼》</li>\n<li>《时间的朋友2015》</li>\n<li>《荒蛮故事》</li>\n</ul>\n<h2 id=\"三月\"><a href=\"#三月\" class=\"headerlink\" title=\"三月\"></a>三月</h2><ul>\n<li>《伟大的隐藏者》4 好喜欢里面东九生活的小村子，让我想到了童年。韩国的电影，却没有故意吹捧自己的国家。</li>\n</ul>\n<h2 id=\"五月\"><a href=\"#五月\" class=\"headerlink\" title=\"五月\"></a>五月</h2><ul>\n<li>《火锅英雄》</li>\n<li>《美国队长3》</li>\n<li>《信号》</li>\n<li>《乒乓侠》</li>\n</ul>\n<h2 id=\"六月-1\"><a href=\"#六月-1\" class=\"headerlink\" title=\"六月\"></a>六月</h2><ul>\n<li>《功夫熊猫3》</li>\n<li>《家和万事兴之我爱我车》</li>\n<li>《明日世界》</li>\n<li>《独立日2》</li>\n<li>《澳门风云3》</li>\n</ul>\n<h2 id=\"七月-1\"><a href=\"#七月-1\" class=\"headerlink\" title=\"七月\"></a>七月</h2><ul>\n<li>《大鱼海棠》</li>\n<li>《六扇门》</li>\n<li>《完美陌生人》意大利 b站看的，弹幕笑死，结局不错</li>\n<li>《代码整洁之道》</li>\n<li>《妮玛的唠嗑馆》</li>\n<li>《安妮和王小明第一季》安妮也是金中的，真的把我带回到我的金中生活，怀念</li>\n<li>《安妮和王小明第二季》</li>\n<li>《妮玛！这就是大学！》</li>\n</ul>\n<h2 id=\"八月-1\"><a href=\"#八月-1\" class=\"headerlink\" title=\"八月\"></a>八月</h2><ul>\n<li>《一起同过窗》</li>\n<li>《三毛流浪记》（漫画）</li>\n<li>《余罪 第一季》</li>\n</ul>\n<h2 id=\"九月-1\"><a href=\"#九月-1\" class=\"headerlink\" title=\"九月\"></a>九月</h2><ul>\n<li>《龙珠Z：复活的F》</li>\n<li>《叶问3》</li>\n<li>《人间失格》</li>\n<li>《余罪 第二季》</li>\n<li>《招魂2》</li>\n<li>《小白理财第一课》</li>\n<li>《五次方谋杀》</li>\n<li>《绝对小孩》</li>\n<li>《One of Us》</li>\n</ul>\n<h2 id=\"十月-1\"><a href=\"#十月-1\" class=\"headerlink\" title=\"十月\"></a>十月</h2><ul>\n<li>《湄公河行动》</li>\n<li>《选老顶》</li>\n<li>《绝对小孩2》</li>\n<li>《刑警兄弟》</li>\n<li>《七堂极简物理课》</li>\n<li>《嫌疑人X的献身》</li>\n<li>《送你一颗子弹》</li>\n<li>《三观易碎》</li>\n<li>《把时间当做朋友》</li>\n</ul>\n<h1 id=\"十一月-1\"><a href=\"#十一月-1\" class=\"headerlink\" title=\"十一月\"></a>十一月</h1><ul>\n<li>《不正常人类症候群》</li>\n<li>《荒岛余生》</li>\n</ul>\n<h1 id=\"二零一五年\"><a href=\"#二零一五年\" class=\"headerlink\" title=\"二零一五年\"></a>二零一五年</h1><h2 id=\"一月-3\"><a href=\"#一月-3\" class=\"headerlink\" title=\"一月\"></a>一月</h2><ul>\n<li>《十三度凶间》</li>\n<li>《恐怖直播》</li>\n<li>《鹿鼎记》</li>\n<li>《鹿鼎记2神龙教》</li>\n<li>《名侦探柯南剧场版6 贝克街的亡灵》</li>\n<li>《最佳出价》</li>\n<li>《宿敌》</li>\n<li>《在我入睡前》</li>\n<li>《源代码》</li>\n<li>《牛奶可乐经济学》</li>\n<li>《智取威虎山》</li>\n</ul>\n<h2 id=\"二月-3\"><a href=\"#二月-3\" class=\"headerlink\" title=\"二月\"></a>二月</h2><ul>\n<li>《K-PAX》</li>\n<li>《十万个冷笑话》电影</li>\n<li>《爱情公寓4》完结</li>\n<li>《天降之物》</li>\n<li>《匆匆那年》</li>\n<li>《无声言证》</li>\n<li>《时空恋旅人》</li>\n<li>《暴走恐怖故事》第一季</li>\n<li>《Premature》</li>\n<li>《地球回音》</li>\n</ul>\n<h2 id=\"三月-1\"><a href=\"#三月-1\" class=\"headerlink\" title=\"三月\"></a>三月</h2><ul>\n<li>《穹顶之下》</li>\n<li>《等一个人咖啡》</li>\n<li>《解忧杂货店》</li>\n<li>《我的互联网方法论》</li>\n<li>《超能陆战队》</li>\n<li>《爆裂鼓手》</li>\n<li>《黑洞频率》</li>\n</ul>\n<h2 id=\"四月\"><a href=\"#四月\" class=\"headerlink\" title=\"四月\"></a>四月</h2><ul>\n<li>《哆啦A梦：伴我同行》</li>\n</ul>\n<h2 id=\"五月-1\"><a href=\"#五月-1\" class=\"headerlink\" title=\"五月\"></a>五月</h2><ul>\n<li>《生人活祭》</li>\n<li>《伊甸湖》</li>\n</ul>\n<h2 id=\"六月-2\"><a href=\"#六月-2\" class=\"headerlink\" title=\"六月\"></a>六月</h2><ul>\n<li>《侏罗纪世界》</li>\n<li>《侏罗纪公园》</li>\n<li>《名侦探狄仁杰》</li>\n<li>《澳门风云2》</li>\n<li>《左耳》</li>\n<li>《两个月亮》</li>\n<li>《附身》</li>\n<li>《海洋之歌》</li>\n</ul>\n<h2 id=\"七月-2\"><a href=\"#七月-2\" class=\"headerlink\" title=\"七月\"></a>七月</h2><ul>\n<li>《名侦探柯南剧场版 异次元的狙击手》</li>\n<li>《五十度灰》</li>\n<li>《速度与激情7》</li>\n<li>《小森林·夏秋篇》</li>\n<li>《小森林·冬春篇》</li>\n<li>《捉妖记》</li>\n<li>《煎饼侠》</li>\n</ul>\n<h2 id=\"八月-2\"><a href=\"#八月-2\" class=\"headerlink\" title=\"八月\"></a>八月</h2><ul>\n<li>《道士下山》</li>\n<li>《笑傲江湖》(书)</li>\n<li>《笑傲江湖》(电视剧)</li>\n</ul>\n<h2 id=\"九月-2\"><a href=\"#九月-2\" class=\"headerlink\" title=\"九月\"></a>九月</h2><ul>\n<li>《港囧》</li>\n</ul>\n<h2 id=\"十月-2\"><a href=\"#十月-2\" class=\"headerlink\" title=\"十月\"></a>十月</h2><ul>\n<li>《我是路人甲》 </li>\n<li>《这个男人来自地球》 </li>\n<li>《决战紫禁之巅》 </li>\n<li>《Programming with Objective-C》</li>\n<li>《画江湖之不良人》</li>\n</ul>\n<h2 id=\"十一月-2\"><a href=\"#十一月-2\" class=\"headerlink\" title=\"十一月\"></a>十一月</h2><ul>\n<li>《夏洛特烦恼》</li>\n<li>《暗时间》</li>\n<li>《荒庙》 </li>\n</ul>\n<h2 id=\"十二月-1\"><a href=\"#十二月-1\" class=\"headerlink\" title=\"十二月\"></a>十二月</h2><ul>\n<li>《尘曲》</li>\n<li>《移动迷宫》</li>\n<li>《西游记之大圣归来》</li>\n<li>《消失的凶手》</li>\n<li>《真实魔鬼游戏》</li>\n</ul>\n<h1 id=\"二零一四年\"><a href=\"#二零一四年\" class=\"headerlink\" title=\"二零一四年\"></a>二零一四年</h1><h2 id=\"三月-2\"><a href=\"#三月-2\" class=\"headerlink\" title=\"三月\"></a>三月</h2><ul>\n<li>《死亡笔记》</li>\n</ul>\n<h2 id=\"四月-1\"><a href=\"#四月-1\" class=\"headerlink\" title=\"四月\"></a>四月</h2><ul>\n<li>《同桌的你》</li>\n<li>《零下一度》</li>\n<li>《逆光飞翔》</li>\n<li>《古墓丽影》</li>\n<li>《古墓丽影2》</li>\n<li>《麦兜响当当》</li>\n</ul>\n<h2 id=\"五月-2\"><a href=\"#五月-2\" class=\"headerlink\" title=\"五月\"></a>五月</h2><ul>\n<li>《麦兜故事》</li>\n<li>《C++程序设计》</li>\n<li>《潘金莲之前世今生》</li>\n<li>《警察故事2013》</li>\n<li>《你是下一个》</li>\n<li>《X战警：逆转未来》</li>\n<li>《百年孤独》</li>\n</ul>\n<h2 id=\"六月-3\"><a href=\"#六月-3\" class=\"headerlink\" title=\"六月\"></a>六月</h2><ul>\n<li>《六福喜事》</li>\n<li>《X战警：第一战》</li>\n<li>《X战警Ⅰ》</li>\n<li>《c++基础教程》</li>\n<li>《杂的文》</li>\n<li>《爆笑角斗士》</li>\n<li>《天才在左，疯子在右》</li>\n<li>《X战警Ⅱ》</li>\n<li>《X战警Ⅲ》</li>\n<li>《金刚狼》</li>\n<li>《金刚狼Ⅱ》</li>\n<li>《生死停留》</li>\n<li>《三重门》</li>\n<li>《警察故事2013》</li>\n</ul>\n<h2 id=\"七月-3\"><a href=\"#七月-3\" class=\"headerlink\" title=\"七月\"></a>七月</h2><ul>\n<li>《澳门风云》</li>\n<li>《无人区》</li>\n<li>《十二生肖》</li>\n<li>《变形金刚4：绝迹重生》</li>\n<li>《进击的巨人》</li>\n<li>《狄仁杰之神都龙王》</li>\n<li>《后会无期》</li>\n<li>《秒速5厘米》</li>\n</ul>\n<h2 id=\"八月-3\"><a href=\"#八月-3\" class=\"headerlink\" title=\"八月\"></a>八月</h2><ul>\n<li>《志明与春娇》</li>\n</ul>\n<h2 id=\"九月-3\"><a href=\"#九月-3\" class=\"headerlink\" title=\"九月\"></a>九月</h2><ul>\n<li>《惊天魔盗团》</li>\n<li>《猩球崛起2》</li>\n<li>《安德的游戏》</li>\n<li>《春娇与志明》</li>\n<li>《分歧者——异类崛起》</li>\n<li>《催眠大师》</li>\n<li>《绣春刀》</li>\n<li>《明日边缘》</li>\n</ul>\n<h2 id=\"十月-3\"><a href=\"#十月-3\" class=\"headerlink\" title=\"十月\"></a>十月</h2><ul>\n<li>《生活启示录》</li>\n<li>《归来》</li>\n<li>《被偷走的那五年》</li>\n<li>《牯岭街少年杀人事件》</li>\n<li>《触不可及》</li>\n<li>《平凡的世界Ⅰ》</li>\n<li>《猎头游戏》</li>\n<li>《黑暗面》</li>\n<li>《控方证人》</li>\n<li>《一级恐惧》</li>\n<li>《飞狐外传》</li>\n<li>《四大名捕大结局》</li>\n<li>《平凡的世界Ⅱ》</li>\n<li>《决战猩球》</li>\n<li>《那夜凌晨 我坐上旺角开往大埔的红van》</li>\n<li>《惊声尖叫》</li>\n<li>《平凡的世界Ⅲ》</li>\n</ul>\n<h2 id=\"十一月-3\"><a href=\"#十一月-3\" class=\"headerlink\" title=\"十一月\"></a>十一月</h2><ul>\n<li>《银河护卫队》</li>\n<li>《失踪罪》</li>\n<li>《早晨从中午开始》</li>\n<li>《连城诀》</li>\n<li>《透明人》</li>\n<li>《透明人2》</li>\n<li>《魔女嘉莉》</li>\n<li>《鬼子来了》</li>\n<li>《太阳照常升起》</li>\n<li>《1988——我想和这个世界谈谈》</li>\n<li>《十七岁的单车》</li>\n<li>《一个人的好天气》</li>\n<li>《心花路放》</li>\n<li>《侧耳倾听》</li>\n<li>《林中小屋》</li>\n<li>《彗星来的那一夜》</li>\n<li>《In Your Eyes》</li>\n<li>《The One I Love》</li>\n<li>《哆啦A梦：新·大雄的大魔境》</li>\n<li>《沙僧吐槽日记》</li>\n<li>《大地飞鹰》</li>\n<li>《极速前进》第1-4期</li>\n<li>《寒战》</li>\n</ul>\n<h2 id=\"十二月-2\"><a href=\"#十二月-2\" class=\"headerlink\" title=\"十二月\"></a>十二月</h2><ul>\n<li>《极速前进》第5-10期</li>\n<li>《关于时间旅行的热门问题》</li>\n<li>《超体》</li>\n<li>《楚留香传奇之血海飘香》</li>\n<li>《麦兜菠萝油王子》</li>\n<li>《星际穿越》</li>\n<li>《月亮》</li>\n<li>《不惧风暴》</li>\n<li>《理科的人Ⅰ》</li>\n<li>《The Giver》</li>\n<li>《楚留香传奇之大沙漠》</li>\n<li>《一步之遥》</li>\n<li>《黄飞鸿之英雄有梦》</li>\n<li>《新大头儿子和小头爸爸之秘密计划》</li>\n<li>《马达加斯加的企鹅》</li>\n<li>《刺杀金正恩》</li>\n<li>《名侦探柯南剧场版1 引爆摩天楼》</li>\n<li>《一个人的武林》</li>\n<li>《弹窗惊魂》</li>\n<li>《楚留香传奇之画眉鸟》</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"二零一八年\"><a href=\"#二零一八年\" class=\"headerlink\" title=\"二零一八年\"></a>二零一八年</h1><h2 id=\"一月\"><a href=\"#一月\" class=\"headerlink\" title=\"一月\"></a>一月</h2><ul>\n<li>《神秘巨星》</li>\n<li>《无问西东》</li>\n<li>《奇门遁甲》</li>\n</ul>\n<h2 id=\"二月\"><a href=\"#二月\" class=\"headerlink\" title=\"二月\"></a>二月</h2><ul>\n<li>《唐人街探案2》</li>\n<li>《活着本来单纯》</li>\n</ul>\n<h1 id=\"二零一七年\"><a href=\"#二零一七年\" class=\"headerlink\" title=\"二零一七年\"></a>二零一七年</h1><h2 id=\"一月-1\"><a href=\"#一月-1\" class=\"headerlink\" title=\"一月\"></a>一月</h2><ul>\n<li>《鲨滩》</li>\n<li>《三少爷的剑》</li>\n<li>《西游伏妖篇》</li>\n<li>《乘风破浪》</li>\n</ul>\n<h2 id=\"二月-1\"><a href=\"#二月-1\" class=\"headerlink\" title=\"二月\"></a>二月</h2><ul>\n<li>《你的名字》</li>\n</ul>\n<h2 id=\"六月\"><a href=\"#六月\" class=\"headerlink\" title=\"六月\"></a>六月</h2><ul>\n<li>《非暴力沟通》</li>\n</ul>\n<h2 id=\"七月\"><a href=\"#七月\" class=\"headerlink\" title=\"七月\"></a>七月</h2><ul>\n<li>《假面饭店》</li>\n<li>《悟空传》</li>\n<li>《小黄人3》</li>\n<li>《嫌疑人x的献身》</li>\n</ul>\n<h2 id=\"八月\"><a href=\"#八月\" class=\"headerlink\" title=\"八月\"></a>八月</h2><ul>\n<li>《战狼2》</li>\n</ul>\n<h2 id=\"九月\"><a href=\"#九月\" class=\"headerlink\" title=\"九月\"></a>九月</h2><ul>\n<li>《太空旅客》4</li>\n<li>《目击者之追凶》4</li>\n<li>《时光倒流的女孩》3</li>\n<li>《猩球崛起3》3</li>\n</ul>\n<h2 id=\"十月\"><a href=\"#十月\" class=\"headerlink\" title=\"十月\"></a>十月</h2><ul>\n<li>《看不见的客人》4</li>\n<li>《羞羞的铁拳》4</li>\n<li>《天才枪手》5</li>\n</ul>\n<h2 id=\"十一月\"><a href=\"#十一月\" class=\"headerlink\" title=\"十一月\"></a>十一月</h2><ul>\n<li>《地球脉动2》</li>\n<li>《缝纫机乐队》 3</li>\n<li>《哈利波特与魔法石》</li>\n</ul>\n<h2 id=\"十二月\"><a href=\"#十二月\" class=\"headerlink\" title=\"十二月\"></a>十二月</h2><ul>\n<li>《少有人走的路》</li>\n<li>《解忧杂货店》</li>\n</ul>\n<h1 id=\"二零一六年\"><a href=\"#二零一六年\" class=\"headerlink\" title=\"二零一六年\"></a>二零一六年</h1><h2 id=\"一月-2\"><a href=\"#一月-2\" class=\"headerlink\" title=\"一月\"></a>一月</h2><ul>\n<li>《像素大战》4星 满满的都是回忆。萌。彩蛋超赞。</li>\n<li>《亲爱的》</li>\n<li>《心迷宫》</li>\n<li>《越女剑》</li>\n<li>《枭雄》</li>\n</ul>\n<h2 id=\"二月-2\"><a href=\"#二月-2\" class=\"headerlink\" title=\"二月\"></a>二月</h2><ul>\n<li>《火星救援》</li>\n<li>《扑克王》</li>\n<li>《赌侠大战拉斯维加斯》</li>\n<li>《我的少女时代》</li>\n<li>《国产凌凌漆》</li>\n<li>《美人鱼》</li>\n<li>《时间的朋友2015》</li>\n<li>《荒蛮故事》</li>\n</ul>\n<h2 id=\"三月\"><a href=\"#三月\" class=\"headerlink\" title=\"三月\"></a>三月</h2><ul>\n<li>《伟大的隐藏者》4 好喜欢里面东九生活的小村子，让我想到了童年。韩国的电影，却没有故意吹捧自己的国家。</li>\n</ul>\n<h2 id=\"五月\"><a href=\"#五月\" class=\"headerlink\" title=\"五月\"></a>五月</h2><ul>\n<li>《火锅英雄》</li>\n<li>《美国队长3》</li>\n<li>《信号》</li>\n<li>《乒乓侠》</li>\n</ul>\n<h2 id=\"六月-1\"><a href=\"#六月-1\" class=\"headerlink\" title=\"六月\"></a>六月</h2><ul>\n<li>《功夫熊猫3》</li>\n<li>《家和万事兴之我爱我车》</li>\n<li>《明日世界》</li>\n<li>《独立日2》</li>\n<li>《澳门风云3》</li>\n</ul>\n<h2 id=\"七月-1\"><a href=\"#七月-1\" class=\"headerlink\" title=\"七月\"></a>七月</h2><ul>\n<li>《大鱼海棠》</li>\n<li>《六扇门》</li>\n<li>《完美陌生人》意大利 b站看的，弹幕笑死，结局不错</li>\n<li>《代码整洁之道》</li>\n<li>《妮玛的唠嗑馆》</li>\n<li>《安妮和王小明第一季》安妮也是金中的，真的把我带回到我的金中生活，怀念</li>\n<li>《安妮和王小明第二季》</li>\n<li>《妮玛！这就是大学！》</li>\n</ul>\n<h2 id=\"八月-1\"><a href=\"#八月-1\" class=\"headerlink\" title=\"八月\"></a>八月</h2><ul>\n<li>《一起同过窗》</li>\n<li>《三毛流浪记》（漫画）</li>\n<li>《余罪 第一季》</li>\n</ul>\n<h2 id=\"九月-1\"><a href=\"#九月-1\" class=\"headerlink\" title=\"九月\"></a>九月</h2><ul>\n<li>《龙珠Z：复活的F》</li>\n<li>《叶问3》</li>\n<li>《人间失格》</li>\n<li>《余罪 第二季》</li>\n<li>《招魂2》</li>\n<li>《小白理财第一课》</li>\n<li>《五次方谋杀》</li>\n<li>《绝对小孩》</li>\n<li>《One of Us》</li>\n</ul>\n<h2 id=\"十月-1\"><a href=\"#十月-1\" class=\"headerlink\" title=\"十月\"></a>十月</h2><ul>\n<li>《湄公河行动》</li>\n<li>《选老顶》</li>\n<li>《绝对小孩2》</li>\n<li>《刑警兄弟》</li>\n<li>《七堂极简物理课》</li>\n<li>《嫌疑人X的献身》</li>\n<li>《送你一颗子弹》</li>\n<li>《三观易碎》</li>\n<li>《把时间当做朋友》</li>\n</ul>\n<h1 id=\"十一月-1\"><a href=\"#十一月-1\" class=\"headerlink\" title=\"十一月\"></a>十一月</h1><ul>\n<li>《不正常人类症候群》</li>\n<li>《荒岛余生》</li>\n</ul>\n<h1 id=\"二零一五年\"><a href=\"#二零一五年\" class=\"headerlink\" title=\"二零一五年\"></a>二零一五年</h1><h2 id=\"一月-3\"><a href=\"#一月-3\" class=\"headerlink\" title=\"一月\"></a>一月</h2><ul>\n<li>《十三度凶间》</li>\n<li>《恐怖直播》</li>\n<li>《鹿鼎记》</li>\n<li>《鹿鼎记2神龙教》</li>\n<li>《名侦探柯南剧场版6 贝克街的亡灵》</li>\n<li>《最佳出价》</li>\n<li>《宿敌》</li>\n<li>《在我入睡前》</li>\n<li>《源代码》</li>\n<li>《牛奶可乐经济学》</li>\n<li>《智取威虎山》</li>\n</ul>\n<h2 id=\"二月-3\"><a href=\"#二月-3\" class=\"headerlink\" title=\"二月\"></a>二月</h2><ul>\n<li>《K-PAX》</li>\n<li>《十万个冷笑话》电影</li>\n<li>《爱情公寓4》完结</li>\n<li>《天降之物》</li>\n<li>《匆匆那年》</li>\n<li>《无声言证》</li>\n<li>《时空恋旅人》</li>\n<li>《暴走恐怖故事》第一季</li>\n<li>《Premature》</li>\n<li>《地球回音》</li>\n</ul>\n<h2 id=\"三月-1\"><a href=\"#三月-1\" class=\"headerlink\" title=\"三月\"></a>三月</h2><ul>\n<li>《穹顶之下》</li>\n<li>《等一个人咖啡》</li>\n<li>《解忧杂货店》</li>\n<li>《我的互联网方法论》</li>\n<li>《超能陆战队》</li>\n<li>《爆裂鼓手》</li>\n<li>《黑洞频率》</li>\n</ul>\n<h2 id=\"四月\"><a href=\"#四月\" class=\"headerlink\" title=\"四月\"></a>四月</h2><ul>\n<li>《哆啦A梦：伴我同行》</li>\n</ul>\n<h2 id=\"五月-1\"><a href=\"#五月-1\" class=\"headerlink\" title=\"五月\"></a>五月</h2><ul>\n<li>《生人活祭》</li>\n<li>《伊甸湖》</li>\n</ul>\n<h2 id=\"六月-2\"><a href=\"#六月-2\" class=\"headerlink\" title=\"六月\"></a>六月</h2><ul>\n<li>《侏罗纪世界》</li>\n<li>《侏罗纪公园》</li>\n<li>《名侦探狄仁杰》</li>\n<li>《澳门风云2》</li>\n<li>《左耳》</li>\n<li>《两个月亮》</li>\n<li>《附身》</li>\n<li>《海洋之歌》</li>\n</ul>\n<h2 id=\"七月-2\"><a href=\"#七月-2\" class=\"headerlink\" title=\"七月\"></a>七月</h2><ul>\n<li>《名侦探柯南剧场版 异次元的狙击手》</li>\n<li>《五十度灰》</li>\n<li>《速度与激情7》</li>\n<li>《小森林·夏秋篇》</li>\n<li>《小森林·冬春篇》</li>\n<li>《捉妖记》</li>\n<li>《煎饼侠》</li>\n</ul>\n<h2 id=\"八月-2\"><a href=\"#八月-2\" class=\"headerlink\" title=\"八月\"></a>八月</h2><ul>\n<li>《道士下山》</li>\n<li>《笑傲江湖》(书)</li>\n<li>《笑傲江湖》(电视剧)</li>\n</ul>\n<h2 id=\"九月-2\"><a href=\"#九月-2\" class=\"headerlink\" title=\"九月\"></a>九月</h2><ul>\n<li>《港囧》</li>\n</ul>\n<h2 id=\"十月-2\"><a href=\"#十月-2\" class=\"headerlink\" title=\"十月\"></a>十月</h2><ul>\n<li>《我是路人甲》 </li>\n<li>《这个男人来自地球》 </li>\n<li>《决战紫禁之巅》 </li>\n<li>《Programming with Objective-C》</li>\n<li>《画江湖之不良人》</li>\n</ul>\n<h2 id=\"十一月-2\"><a href=\"#十一月-2\" class=\"headerlink\" title=\"十一月\"></a>十一月</h2><ul>\n<li>《夏洛特烦恼》</li>\n<li>《暗时间》</li>\n<li>《荒庙》 </li>\n</ul>\n<h2 id=\"十二月-1\"><a href=\"#十二月-1\" class=\"headerlink\" title=\"十二月\"></a>十二月</h2><ul>\n<li>《尘曲》</li>\n<li>《移动迷宫》</li>\n<li>《西游记之大圣归来》</li>\n<li>《消失的凶手》</li>\n<li>《真实魔鬼游戏》</li>\n</ul>\n<h1 id=\"二零一四年\"><a href=\"#二零一四年\" class=\"headerlink\" title=\"二零一四年\"></a>二零一四年</h1><h2 id=\"三月-2\"><a href=\"#三月-2\" class=\"headerlink\" title=\"三月\"></a>三月</h2><ul>\n<li>《死亡笔记》</li>\n</ul>\n<h2 id=\"四月-1\"><a href=\"#四月-1\" class=\"headerlink\" title=\"四月\"></a>四月</h2><ul>\n<li>《同桌的你》</li>\n<li>《零下一度》</li>\n<li>《逆光飞翔》</li>\n<li>《古墓丽影》</li>\n<li>《古墓丽影2》</li>\n<li>《麦兜响当当》</li>\n</ul>\n<h2 id=\"五月-2\"><a href=\"#五月-2\" class=\"headerlink\" title=\"五月\"></a>五月</h2><ul>\n<li>《麦兜故事》</li>\n<li>《C++程序设计》</li>\n<li>《潘金莲之前世今生》</li>\n<li>《警察故事2013》</li>\n<li>《你是下一个》</li>\n<li>《X战警：逆转未来》</li>\n<li>《百年孤独》</li>\n</ul>\n<h2 id=\"六月-3\"><a href=\"#六月-3\" class=\"headerlink\" title=\"六月\"></a>六月</h2><ul>\n<li>《六福喜事》</li>\n<li>《X战警：第一战》</li>\n<li>《X战警Ⅰ》</li>\n<li>《c++基础教程》</li>\n<li>《杂的文》</li>\n<li>《爆笑角斗士》</li>\n<li>《天才在左，疯子在右》</li>\n<li>《X战警Ⅱ》</li>\n<li>《X战警Ⅲ》</li>\n<li>《金刚狼》</li>\n<li>《金刚狼Ⅱ》</li>\n<li>《生死停留》</li>\n<li>《三重门》</li>\n<li>《警察故事2013》</li>\n</ul>\n<h2 id=\"七月-3\"><a href=\"#七月-3\" class=\"headerlink\" title=\"七月\"></a>七月</h2><ul>\n<li>《澳门风云》</li>\n<li>《无人区》</li>\n<li>《十二生肖》</li>\n<li>《变形金刚4：绝迹重生》</li>\n<li>《进击的巨人》</li>\n<li>《狄仁杰之神都龙王》</li>\n<li>《后会无期》</li>\n<li>《秒速5厘米》</li>\n</ul>\n<h2 id=\"八月-3\"><a href=\"#八月-3\" class=\"headerlink\" title=\"八月\"></a>八月</h2><ul>\n<li>《志明与春娇》</li>\n</ul>\n<h2 id=\"九月-3\"><a href=\"#九月-3\" class=\"headerlink\" title=\"九月\"></a>九月</h2><ul>\n<li>《惊天魔盗团》</li>\n<li>《猩球崛起2》</li>\n<li>《安德的游戏》</li>\n<li>《春娇与志明》</li>\n<li>《分歧者——异类崛起》</li>\n<li>《催眠大师》</li>\n<li>《绣春刀》</li>\n<li>《明日边缘》</li>\n</ul>\n<h2 id=\"十月-3\"><a href=\"#十月-3\" class=\"headerlink\" title=\"十月\"></a>十月</h2><ul>\n<li>《生活启示录》</li>\n<li>《归来》</li>\n<li>《被偷走的那五年》</li>\n<li>《牯岭街少年杀人事件》</li>\n<li>《触不可及》</li>\n<li>《平凡的世界Ⅰ》</li>\n<li>《猎头游戏》</li>\n<li>《黑暗面》</li>\n<li>《控方证人》</li>\n<li>《一级恐惧》</li>\n<li>《飞狐外传》</li>\n<li>《四大名捕大结局》</li>\n<li>《平凡的世界Ⅱ》</li>\n<li>《决战猩球》</li>\n<li>《那夜凌晨 我坐上旺角开往大埔的红van》</li>\n<li>《惊声尖叫》</li>\n<li>《平凡的世界Ⅲ》</li>\n</ul>\n<h2 id=\"十一月-3\"><a href=\"#十一月-3\" class=\"headerlink\" title=\"十一月\"></a>十一月</h2><ul>\n<li>《银河护卫队》</li>\n<li>《失踪罪》</li>\n<li>《早晨从中午开始》</li>\n<li>《连城诀》</li>\n<li>《透明人》</li>\n<li>《透明人2》</li>\n<li>《魔女嘉莉》</li>\n<li>《鬼子来了》</li>\n<li>《太阳照常升起》</li>\n<li>《1988——我想和这个世界谈谈》</li>\n<li>《十七岁的单车》</li>\n<li>《一个人的好天气》</li>\n<li>《心花路放》</li>\n<li>《侧耳倾听》</li>\n<li>《林中小屋》</li>\n<li>《彗星来的那一夜》</li>\n<li>《In Your Eyes》</li>\n<li>《The One I Love》</li>\n<li>《哆啦A梦：新·大雄的大魔境》</li>\n<li>《沙僧吐槽日记》</li>\n<li>《大地飞鹰》</li>\n<li>《极速前进》第1-4期</li>\n<li>《寒战》</li>\n</ul>\n<h2 id=\"十二月-2\"><a href=\"#十二月-2\" class=\"headerlink\" title=\"十二月\"></a>十二月</h2><ul>\n<li>《极速前进》第5-10期</li>\n<li>《关于时间旅行的热门问题》</li>\n<li>《超体》</li>\n<li>《楚留香传奇之血海飘香》</li>\n<li>《麦兜菠萝油王子》</li>\n<li>《星际穿越》</li>\n<li>《月亮》</li>\n<li>《不惧风暴》</li>\n<li>《理科的人Ⅰ》</li>\n<li>《The Giver》</li>\n<li>《楚留香传奇之大沙漠》</li>\n<li>《一步之遥》</li>\n<li>《黄飞鸿之英雄有梦》</li>\n<li>《新大头儿子和小头爸爸之秘密计划》</li>\n<li>《马达加斯加的企鹅》</li>\n<li>《刺杀金正恩》</li>\n<li>《名侦探柯南剧场版1 引爆摩天楼》</li>\n<li>《一个人的武林》</li>\n<li>《弹窗惊魂》</li>\n<li>《楚留香传奇之画眉鸟》</li>\n</ul>\n","sticky":0}],"PostAsset":[],"PostCategory":[{"post_id":"cje87q08v0000tjqwlj587dz9","category_id":"cje87q0920004tjqwgqgzv1z1","_id":"cje87q098000ctjqwm0dxa3pp"},{"post_id":"cje87q097000atjqweawpdx0t","category_id":"cje87q0960009tjqwuwmq34ht","_id":"cje87q09b000gtjqw1en20j6w"},{"post_id":"cje87q08z0002tjqwjygvx2ca","category_id":"cje87q0960009tjqwuwmq34ht","_id":"cje87q09d000jtjqw06af8lmy"},{"post_id":"cje87q098000btjqw3s0xrq9m","category_id":"cje87q0960009tjqwuwmq34ht","_id":"cje87q09e000ltjqwrfjo0li1"},{"post_id":"cje87q099000etjqw9dnr3yrm","category_id":"cje87q0920004tjqwgqgzv1z1","_id":"cje87q09f000otjqw1gbq5h4n"},{"post_id":"cje87q0930005tjqw9d1ffoxo","category_id":"cje87q099000dtjqw6212joqv","_id":"cje87q09g000qtjqwnof2d1ef"},{"post_id":"cje87q09a000ftjqwv8lxitbk","category_id":"cje87q0960009tjqwuwmq34ht","_id":"cje87q09h000ttjqwtjl6604t"},{"post_id":"cje87q09c000itjqwug6swg14","category_id":"cje87q0960009tjqwuwmq34ht","_id":"cje87q09i000utjqworiisqcp"},{"post_id":"cje87q0950007tjqwz2zhyzqa","category_id":"cje87q0960009tjqwuwmq34ht","_id":"cje87q09i000wtjqwvwzejjgy"},{"post_id":"cje87q09d000ktjqwiysp314c","category_id":"cje87q0920004tjqwgqgzv1z1","_id":"cje87q09j000xtjqwvxvayfmc"},{"post_id":"cje87q0950008tjqwz4l5hdml","category_id":"cje87q0960009tjqwuwmq34ht","_id":"cje87q09j000ytjqw55e0fj8c"},{"post_id":"cje87q09g000ptjqwzd5y18va","category_id":"cje87q099000dtjqw6212joqv","_id":"cje87q09j000ztjqwgd5ne203"},{"post_id":"cje87q09f000ntjqww8ehg3bx","category_id":"cje87q09h000rtjqwp4qgq3iu","_id":"cje87q09j0010tjqw7rzet9e5"},{"post_id":"cje87q09h000stjqwuug38uiq","category_id":"cje87q09h000rtjqwp4qgq3iu","_id":"cje87q09k0011tjqwi7gwz7rs"}],"PostTag":[],"Tag":[]}}